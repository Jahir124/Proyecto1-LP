Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    ADD
    AND_EQUAL
    AS
    ASSERT
    ASYNC
    AT_SIGN
    AWAIT
    BACKSLASH
    BACKTICK
    BASE
    BITAND
    BITNOT
    BITOR
    BITXOR
    BOOLEAN_LITERAL
    CASE
    CHAR_LITERAL
    CIRCUMFLEX
    CLEAR
    COMMENT_DOC
    COMMENT_MULTI
    COMMENT_SINGLE
    CONTAINS
    CONTINUE
    DEBUGPRINT
    DEFAULT
    DEFERRED
    DO
    DOLLAR_SIGN
    DOUBLE_COLON
    DOUBLE_LITERAL
    ENUM
    EXCLAMATION
    EXPORT
    EXTERNAL
    FACTORY
    FAT_ARROW
    FINALLY
    FIRST
    FOREACH
    FUNCTION
    GET
    HASH
    HIDE
    IDENTICAL
    IMPORT
    INTERFACE
    INT_DIVIDE_EQUAL
    INT_LITERAL
    IS
    ISEMPTY
    ISNOTEMPTY
    IS_NOT
    ITERABLE
    LAST
    LATE
    LEFT_SHIFT
    LEFT_SHIFT_EQUAL
    LENGTH
    LIBRARY
    MAP_FUNC
    MIXIN_CLASS
    MULTILINE_STRING_LITERAL
    NEVER
    NOT_IDENTICAL
    NULL
    NUM
    OBJECT
    OF
    ON
    OPERATOR
    OR_EQUAL
    PART
    PART_OF
    POWER
    POWER_EQUAL
    QUESTION_DOT
    QUOTATION_MARK
    RAW_STRING_LITERAL
    REMOVE
    RETHROW
    RIGHT_SHIFT
    RIGHT_SHIFT_EQUAL
    SEALED
    SETTER
    SHOW
    SINGLE_QUOTE
    STDERR
    STDOUT
    STRING_LITERAL
    SUPER
    SWITCH
    SYNC
    THIS
    THROW
    TRIPLE_DOT
    TYPEDEF
    UNDERSCORE
    UNSIGNED_RIGHT_SHIFT
    WHERE
    XOR_EQUAL
    YIELD

Grammar

Rule 0     S' -> compiler
Rule 1     compiler -> statement_composed
Rule 2     statement_composed -> statement
Rule 3     statement_composed -> statement_composed statement
Rule 4     statement -> print_stmt
Rule 5     statement -> input_stmt
Rule 6     statement -> control_structures
Rule 7     statement -> function
Rule 8     statement -> lambda_function
Rule 9     statement -> list_def
Rule 10    statement -> map_def
Rule 11    statement -> variable_def
Rule 12    statement -> variable_only_def
Rule 13    statement -> SEMICOLON
Rule 14    statement -> function_call
Rule 15    statement -> return_statement
Rule 16    statement -> incdec_statement
Rule 17    statement -> class_def
Rule 18    statement -> object_instantiation
Rule 19    statement -> break_stmt
Rule 20    statement -> expression SEMICOLON
Rule 21    statement -> <empty>
Rule 22    variable_only_def -> type ID SEMICOLON
Rule 23    variable_only_def -> DYNAMIC ID SEMICOLON
Rule 24    variable_only_def -> VAR ID SEMICOLON
Rule 25    variable_only_def -> STATIC type ID SEMICOLON
Rule 26    variable_only_def -> STATIC VAR ID SEMICOLON
Rule 27    variable_only_def -> STATIC DYNAMIC ID SEMICOLON
Rule 28    variable_def -> type ID ASSIGN expression SEMICOLON
Rule 29    variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 30    variable_def -> VAR ID ASSIGN expression SEMICOLON
Rule 31    variable_def -> STATIC type ID ASSIGN expression SEMICOLON
Rule 32    variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON
Rule 33    variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON
Rule 34    expression -> expression PLUS expression
Rule 35    expression -> expression MINUS expression
Rule 36    expression -> expression TIMES expression
Rule 37    expression -> expression DIVIDE expression
Rule 38    expression -> expression INT_DIVIDE expression
Rule 39    expression -> expression MODULE expression
Rule 40    expression -> LPAREN expression RPAREN
Rule 41    expression -> value
Rule 42    expression -> ID INCREMENT
Rule 43    expression -> ID DECREMENT
Rule 44    expression -> expression DOT ID
Rule 45    expression -> expression DOT function_call
Rule 46    expression -> expression DOT ID LPAREN argument_list_opt RPAREN
Rule 47    expression -> ID PLUS_EQUAL expression
Rule 48    expression -> ID MINUS_EQUAL expression
Rule 49    expression -> ID TIMES_EQUAL expression
Rule 50    expression -> ID DIVIDE_EQUAL expression
Rule 51    expression -> ID MODULE_EQUAL expression
Rule 52    expression -> INCREMENT ID
Rule 53    expression -> DECREMENT ID
Rule 54    expression -> PLUS ID
Rule 55    expression -> MINUS ID
Rule 56    expression -> expression QUESTION expression COLON expression
Rule 57    expression -> expression DOUBLE_DOT expression
Rule 58    expression -> LPAREN parameters RPAREN ARROW expression
Rule 59    expression -> LPAREN RPAREN ARROW expression
Rule 60    expression -> TRUE
Rule 61    expression -> FALSE
Rule 62    expression -> NULL_LITERAL
Rule 63    control_structures -> if_block
Rule 64    control_structures -> if_block else_block
Rule 65    control_structures -> while_loop
Rule 66    control_structures -> for_loop
Rule 67    if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
Rule 68    else_block -> ELSE LBRACE statement_composed RBRACE
Rule 69    conditions -> condition
Rule 70    conditions -> conditions AND condition
Rule 71    conditions -> conditions OR condition
Rule 72    condition -> value comparison_operator value
Rule 73    condition -> NOT value
Rule 74    condition -> TRUE
Rule 75    condition -> FALSE
Rule 76    condition -> ID comparison_operator value
Rule 77    condition -> ID comparison_operator ID
Rule 78    comparison_operator -> GREATER
Rule 79    comparison_operator -> LESS
Rule 80    comparison_operator -> GREATER_EQUAL
Rule 81    comparison_operator -> LESS_EQUAL
Rule 82    comparison_operator -> EQUALS
Rule 83    comparison_operator -> NOT_EQUALS
Rule 84    while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
Rule 85    for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
Rule 86    for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
Rule 87    for_init -> variable_def
Rule 88    for_init -> empty
Rule 89    for_update -> incdec_statement
Rule 90    for_update -> ID ASSIGN expression
Rule 91    for_update -> empty
Rule 92    break_stmt -> BREAK SEMICOLON
Rule 93    for_in_loop -> FOR LPAREN VAR ID IN ID RPAREN LBRACE statement_composed RBRACE
Rule 94    for_in_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
Rule 95    try_catch_block -> TRY LBRACE statement_composed RBRACE CATCH LPAREN ID RPAREN LBRACE statement_composed RBRACE
Rule 96    function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 97    function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 98    function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 99    function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 100   function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
Rule 101   function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
Rule 102   parameters -> parameter
Rule 103   parameters -> parameters COMMA parameter
Rule 104   parameter -> type ID
Rule 105   parameter -> REQUIRED type ID
Rule 106   optional_parameters -> LBRACKET parameters RBRACKET
Rule 107   optional_parameters -> LBRACE named_parameters RBRACE
Rule 108   named_parameters -> named_parameter
Rule 109   named_parameters -> named_parameters COMMA named_parameter
Rule 110   named_parameter -> type ID
Rule 111   named_parameter -> REQUIRED type ID
Rule 112   function_call -> ID LPAREN RPAREN SEMICOLON
Rule 113   function_call -> ID LPAREN argument_list RPAREN SEMICOLON
Rule 114   argument_list -> expression
Rule 115   argument_list -> argument_list COMMA expression
Rule 116   argument_list_opt -> argument_list
Rule 117   argument_list_opt -> empty
Rule 118   return_statement -> RETURN expression SEMICOLON
Rule 119   return_statement -> RETURN SEMICOLON
Rule 120   lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
Rule 121   lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
Rule 122   lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
Rule 123   lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
Rule 124   anonymous_function -> LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 125   anonymous_function -> LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 126   variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON
Rule 127   variable_def -> type ID ASSIGN anonymous_function SEMICOLON
Rule 128   list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON
Rule 129   list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 130   list_def -> LIST LESS type GREATER ID SEMICOLON
Rule 131   list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
Rule 132   value_list -> value
Rule 133   value_list -> value_list COMMA value
Rule 134   list_of_lists -> LBRACKET value_list RBRACKET
Rule 135   list_of_lists -> list_of_lists COMMA LBRACKET value_list RBRACKET
Rule 136   map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
Rule 137   map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
Rule 138   map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
Rule 139   map_entries -> map_entry
Rule 140   map_entries -> map_entries COMMA map_entry
Rule 141   map_entry -> value COLON value
Rule 142   map_of_lists -> map_list_entry
Rule 143   map_of_lists -> map_of_lists COMMA map_list_entry
Rule 144   map_list_entry -> value COLON LBRACKET value_list RBRACKET
Rule 145   set_value -> LBRACE value_list RBRACE
Rule 146   class_def -> CLASS ID LBRACE class_body RBRACE
Rule 147   class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE
Rule 148   class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
Rule 149   class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
Rule 150   class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
Rule 151   class_body -> class_member
Rule 152   class_body -> class_body class_member
Rule 153   class_member -> class_property
Rule 154   class_member -> class_method
Rule 155   class_member -> constructor
Rule 156   class_property -> type ID SEMICOLON
Rule 157   class_property -> VAR ID SEMICOLON
Rule 158   class_property -> FINAL type ID SEMICOLON
Rule 159   class_property -> CONST type ID SEMICOLON
Rule 160   class_property -> STATIC type ID SEMICOLON
Rule 161   class_property -> type ID ASSIGN expression SEMICOLON
Rule 162   class_property -> VAR ID ASSIGN expression SEMICOLON
Rule 163   class_property -> FINAL type ID ASSIGN expression SEMICOLON
Rule 164   class_property -> CONST type ID ASSIGN expression SEMICOLON
Rule 165   class_property -> STATIC type ID ASSIGN expression SEMICOLON
Rule 166   class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 167   class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 168   class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 169   class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 170   class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 171   class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 172   constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 173   constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 174   object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 175   object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 176   object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 177   object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 178   object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 179   object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 180   object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 181   object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 182   object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
Rule 183   object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON
Rule 184   object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
Rule 185   object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
Rule 186   object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
Rule 187   object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON
Rule 188   print_stmt -> PRINT LPAREN RPAREN SEMICOLON
Rule 189   print_stmt -> PRINT LPAREN value RPAREN SEMICOLON
Rule 190   print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 191   input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 192   input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 193   input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 194   type -> STRING
Rule 195   type -> INT
Rule 196   type -> DOUBLE
Rule 197   type -> BOOL
Rule 198   type -> set_type
Rule 199   set_type -> SET
Rule 200   set_type -> SET LESS type GREATER
Rule 201   value -> INT
Rule 202   value -> DOUBLE
Rule 203   value -> STRING
Rule 204   value -> ID
Rule 205   value -> TRUE
Rule 206   value -> FALSE
Rule 207   value -> set_value
Rule 208   incdec_statement -> ID INCREMENT SEMICOLON
Rule 209   incdec_statement -> ID DECREMENT SEMICOLON
Rule 210   incdec_statement -> INCREMENT ID SEMICOLON
Rule 211   incdec_statement -> DECREMENT ID SEMICOLON
Rule 212   empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
ADD                  : 
AND                  : 70
AND_EQUAL            : 
ARROW                : 58 59 120 121 122 123
AS                   : 
ASSERT               : 
ASSIGN               : 28 29 30 31 32 33 90 120 121 122 123 126 127 129 131 136 137 138 161 162 163 164 165 174 175 176 177 178 179 180 181 182 183 184 185 186 187 192 193
ASYNC                : 
AT_SIGN              : 
AWAIT                : 
BACKSLASH            : 
BACKTICK             : 
BASE                 : 
BITAND               : 
BITNOT               : 
BITOR                : 
BITXOR               : 
BOOL                 : 197
BOOLEAN_LITERAL      : 
BREAK                : 92
CASE                 : 
CATCH                : 95
CHAR_LITERAL         : 
CIRCUMFLEX           : 
CLASS                : 146 147 148 149 150
CLEAR                : 
COLON                : 56 141 144
COMMA                : 103 109 115 133 135 136 138 140 143
COMMENT_DOC          : 
COMMENT_MULTI        : 
COMMENT_SINGLE       : 
CONST                : 159 164
CONTAINS             : 
CONTINUE             : 
DEBUGPRINT           : 
DECREMENT            : 43 53 209 211
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 37
DIVIDE_EQUAL         : 50
DO                   : 
DOLLAR_SIGN          : 
DOT                  : 44 45 46 191 192 193
DOUBLE               : 196 202
DOUBLE_COLON         : 
DOUBLE_DOT           : 57
DOUBLE_LITERAL       : 
DYNAMIC              : 23 27 29 33
ELSE                 : 68
ENUM                 : 
EQUALS               : 82
EXCLAMATION          : 
EXPORT               : 
EXTENDS              : 147 149 150
EXTERNAL             : 
FACTORY              : 
FALSE                : 61 75 206
FAT_ARROW            : 
FINAL                : 158 163
FINALLY              : 
FIRST                : 
FOR                  : 85 86 93 94
FOREACH              : 
FUNCTION             : 
GET                  : 
GREATER              : 78 129 130 131 136 138 200
GREATER_EQUAL        : 80
HASH                 : 
HIDE                 : 
ID                   : 22 23 24 25 26 27 28 29 30 31 32 33 42 43 44 46 47 48 49 50 51 52 53 54 55 76 77 77 86 86 90 93 93 94 94 95 96 97 98 99 100 101 104 105 110 111 112 113 120 121 122 123 126 127 129 130 131 136 137 138 146 147 147 148 148 149 149 149 150 150 150 150 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 174 175 175 176 176 177 177 178 178 178 179 179 179 180 180 181 181 182 182 183 183 184 184 185 185 186 186 187 187 192 193 204 208 209 210 211
IDENTICAL            : 
IF                   : 67
IMPLEMENTS           : 148 149 150
IMPORT               : 
IN                   : 86 93 94
INCREMENT            : 42 52 208 210
INT                  : 195 201
INTERFACE            : 
INT_DIVIDE           : 38
INT_DIVIDE_EQUAL     : 
INT_LITERAL          : 
IS                   : 
ISEMPTY              : 
ISNOTEMPTY           : 
IS_NOT               : 
ITERABLE             : 
LAST                 : 
LATE                 : 
LBRACE               : 67 68 84 85 86 93 94 95 95 96 97 98 99 100 101 107 124 125 136 137 138 145 146 147 148 149 150 166 167 168 169 170 171 172 173
LBRACKET             : 106 128 129 131 134 135 144
LEFT_SHIFT           : 
LEFT_SHIFT_EQUAL     : 
LENGTH               : 
LESS                 : 79 129 130 131 136 138 200
LESS_EQUAL           : 81
LIBRARY              : 
LIST                 : 128 129 130 131
LPAREN               : 40 46 58 59 67 84 85 86 93 94 95 96 97 98 99 100 101 112 113 120 121 122 123 124 125 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193
MAP                  : 136 137 138
MAP_FUNC             : 
MINUS                : 35 55
MINUS_EQUAL          : 48
MIXIN_CLASS          : 
MODULE               : 39
MODULE_EQUAL         : 51
MULTILINE_STRING_LITERAL : 
NEVER                : 
NEW                  : 174 175 178 180 182 184 186
NOT                  : 73
NOT_EQUALS           : 83
NOT_IDENTICAL        : 
NULL                 : 
NULL_LITERAL         : 62
NUM                  : 
OBJECT               : 
OF                   : 
ON                   : 
OPERATOR             : 
OR                   : 71
OR_EQUAL             : 
PART                 : 
PART_OF              : 
PLUS                 : 34 54
PLUS_EQUAL           : 47
POWER                : 
POWER_EQUAL          : 
PRINT                : 188 189 190
QUESTION             : 56
QUESTION_DOT         : 
QUOTATION_MARK       : 
RAW_STRING_LITERAL   : 
RBRACE               : 67 68 84 85 86 93 94 95 95 96 97 98 99 100 101 107 124 125 136 137 138 145 146 147 148 149 150 166 167 168 169 170 171 172 173
RBRACKET             : 106 128 129 131 134 135 144
READLINESYNC         : 191 192 193
REMOVE               : 
REQUIRED             : 105 111
RETHROW              : 
RETURN               : 118 119
RIGHT_SHIFT          : 
RIGHT_SHIFT_EQUAL    : 
RPAREN               : 40 46 58 59 67 84 85 86 93 94 95 96 97 98 99 100 101 112 113 120 121 122 123 124 125 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193
SEALED               : 
SEMICOLON            : 13 20 22 23 24 25 26 27 28 29 30 31 32 33 85 85 92 112 113 118 119 120 121 122 123 126 127 128 129 130 131 136 137 138 156 157 158 159 160 161 162 163 164 165 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 208 209 210 211
SET                  : 199 200
SETTER               : 
SHOW                 : 
SINGLE_QUOTE         : 
STATIC               : 25 26 27 31 32 33 160 165 170 171
STDERR               : 
STDIN                : 191 192 193
STDOUT               : 
STRING               : 194 203
STRING_LITERAL       : 
SUPER                : 
SWITCH               : 
SYNC                 : 
THIS                 : 
THROW                : 
TIMES                : 36
TIMES_EQUAL          : 49
TRIPLE_DOT           : 
TRUE                 : 60 74 205
TRY                  : 95
TYPEDEF              : 
UNDERSCORE           : 
UNSIGNED_RIGHT_SHIFT : 
VAR                  : 24 26 30 32 93 121 123 126 157 162 174 176 184 185 192
VOID                 : 97 99 101 167 169 171
WHERE                : 
WHILE                : 84
WITH                 : 150
XOR_EQUAL            : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

anonymous_function   : 126 127
argument_list        : 113 115 116
argument_list_opt    : 46 174 175 176 177 178 179 180 181
break_stmt           : 19
class_body           : 146 147 148 149 150 152
class_def            : 17
class_member         : 151 152
class_method         : 154
class_property       : 153
comparison_operator  : 72 76 77
compiler             : 0
condition            : 69 70 71
conditions           : 67 70 71 84 85
constructor          : 155
control_structures   : 6
else_block           : 64
empty                : 88 91 117
expression           : 20 28 29 30 31 32 33 34 34 35 35 36 36 37 37 38 38 39 39 40 44 45 46 47 48 49 50 51 56 56 56 57 57 58 59 90 114 115 118 120 121 122 123 161 162 163 164 165 190
for_in_loop          : 
for_init             : 85
for_loop             : 66
for_update           : 85
function             : 7
function_call        : 14 45
if_block             : 63 64
incdec_statement     : 16 89
input_stmt           : 5
lambda_function      : 8
list_def             : 9
list_of_lists        : 131 135
map_def              : 10
map_entries          : 136 137 140
map_entry            : 139 140
map_list_entry       : 142 143
map_of_lists         : 138 143
named_parameter      : 108 109
named_parameters     : 107 109
object_instantiation : 18
optional_parameters  : 100 101
parameter            : 102 103
parameters           : 58 96 97 103 106 120 121 124 166 167 170 171 172
print_stmt           : 4
return_statement     : 15
set_type             : 198
set_value            : 207
statement            : 2 3
statement_composed   : 1 3 67 68 84 85 86 93 94 95 95 96 97 98 99 100 101 124 125 166 167 168 169 170 171 172 173
try_catch_block      : 
type                 : 22 25 28 31 86 94 96 98 100 104 105 110 111 120 122 127 129 130 131 136 136 138 138 156 158 159 160 161 163 164 165 166 168 170 175 177 186 187 193 200
value                : 41 72 72 73 76 132 133 141 141 144 189
value_list           : 128 129 133 134 135 144 145
variable_def         : 11 87
variable_only_def    : 12
while_loop           : 65

Parsing method: LALR

state 0

    (0) S' -> . compiler
    (1) compiler -> . statement_composed
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    $end            reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    compiler                       shift and go to state 1
    statement_composed             shift and go to state 2
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 1

    (0) S' -> compiler .



state 2

    (1) compiler -> statement_composed .
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (compiler -> statement_composed .)
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    $end            reduce using rule 1 (compiler -> statement_composed .)
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]
  ! $end            [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 3

    (2) statement_composed -> statement .

    SEMICOLON       reduce using rule 2 (statement_composed -> statement .)
    PRINT           reduce using rule 2 (statement_composed -> statement .)
    STDIN           reduce using rule 2 (statement_composed -> statement .)
    VAR             reduce using rule 2 (statement_composed -> statement .)
    VOID            reduce using rule 2 (statement_composed -> statement .)
    LIST            reduce using rule 2 (statement_composed -> statement .)
    MAP             reduce using rule 2 (statement_composed -> statement .)
    DYNAMIC         reduce using rule 2 (statement_composed -> statement .)
    STATIC          reduce using rule 2 (statement_composed -> statement .)
    ID              reduce using rule 2 (statement_composed -> statement .)
    RETURN          reduce using rule 2 (statement_composed -> statement .)
    INCREMENT       reduce using rule 2 (statement_composed -> statement .)
    DECREMENT       reduce using rule 2 (statement_composed -> statement .)
    CLASS           reduce using rule 2 (statement_composed -> statement .)
    BREAK           reduce using rule 2 (statement_composed -> statement .)
    LPAREN          reduce using rule 2 (statement_composed -> statement .)
    PLUS            reduce using rule 2 (statement_composed -> statement .)
    MINUS           reduce using rule 2 (statement_composed -> statement .)
    TRUE            reduce using rule 2 (statement_composed -> statement .)
    FALSE           reduce using rule 2 (statement_composed -> statement .)
    NULL_LITERAL    reduce using rule 2 (statement_composed -> statement .)
    STRING          reduce using rule 2 (statement_composed -> statement .)
    INT             reduce using rule 2 (statement_composed -> statement .)
    DOUBLE          reduce using rule 2 (statement_composed -> statement .)
    BOOL            reduce using rule 2 (statement_composed -> statement .)
    IF              reduce using rule 2 (statement_composed -> statement .)
    WHILE           reduce using rule 2 (statement_composed -> statement .)
    FOR             reduce using rule 2 (statement_composed -> statement .)
    SET             reduce using rule 2 (statement_composed -> statement .)
    LBRACE          reduce using rule 2 (statement_composed -> statement .)
    $end            reduce using rule 2 (statement_composed -> statement .)
    RBRACE          reduce using rule 2 (statement_composed -> statement .)


state 4

    (4) statement -> print_stmt .

    SEMICOLON       reduce using rule 4 (statement -> print_stmt .)
    PRINT           reduce using rule 4 (statement -> print_stmt .)
    STDIN           reduce using rule 4 (statement -> print_stmt .)
    VAR             reduce using rule 4 (statement -> print_stmt .)
    VOID            reduce using rule 4 (statement -> print_stmt .)
    LIST            reduce using rule 4 (statement -> print_stmt .)
    MAP             reduce using rule 4 (statement -> print_stmt .)
    DYNAMIC         reduce using rule 4 (statement -> print_stmt .)
    STATIC          reduce using rule 4 (statement -> print_stmt .)
    ID              reduce using rule 4 (statement -> print_stmt .)
    RETURN          reduce using rule 4 (statement -> print_stmt .)
    INCREMENT       reduce using rule 4 (statement -> print_stmt .)
    DECREMENT       reduce using rule 4 (statement -> print_stmt .)
    CLASS           reduce using rule 4 (statement -> print_stmt .)
    BREAK           reduce using rule 4 (statement -> print_stmt .)
    LPAREN          reduce using rule 4 (statement -> print_stmt .)
    PLUS            reduce using rule 4 (statement -> print_stmt .)
    MINUS           reduce using rule 4 (statement -> print_stmt .)
    TRUE            reduce using rule 4 (statement -> print_stmt .)
    FALSE           reduce using rule 4 (statement -> print_stmt .)
    NULL_LITERAL    reduce using rule 4 (statement -> print_stmt .)
    STRING          reduce using rule 4 (statement -> print_stmt .)
    INT             reduce using rule 4 (statement -> print_stmt .)
    DOUBLE          reduce using rule 4 (statement -> print_stmt .)
    BOOL            reduce using rule 4 (statement -> print_stmt .)
    IF              reduce using rule 4 (statement -> print_stmt .)
    WHILE           reduce using rule 4 (statement -> print_stmt .)
    FOR             reduce using rule 4 (statement -> print_stmt .)
    SET             reduce using rule 4 (statement -> print_stmt .)
    LBRACE          reduce using rule 4 (statement -> print_stmt .)
    $end            reduce using rule 4 (statement -> print_stmt .)
    RBRACE          reduce using rule 4 (statement -> print_stmt .)


state 5

    (5) statement -> input_stmt .

    SEMICOLON       reduce using rule 5 (statement -> input_stmt .)
    PRINT           reduce using rule 5 (statement -> input_stmt .)
    STDIN           reduce using rule 5 (statement -> input_stmt .)
    VAR             reduce using rule 5 (statement -> input_stmt .)
    VOID            reduce using rule 5 (statement -> input_stmt .)
    LIST            reduce using rule 5 (statement -> input_stmt .)
    MAP             reduce using rule 5 (statement -> input_stmt .)
    DYNAMIC         reduce using rule 5 (statement -> input_stmt .)
    STATIC          reduce using rule 5 (statement -> input_stmt .)
    ID              reduce using rule 5 (statement -> input_stmt .)
    RETURN          reduce using rule 5 (statement -> input_stmt .)
    INCREMENT       reduce using rule 5 (statement -> input_stmt .)
    DECREMENT       reduce using rule 5 (statement -> input_stmt .)
    CLASS           reduce using rule 5 (statement -> input_stmt .)
    BREAK           reduce using rule 5 (statement -> input_stmt .)
    LPAREN          reduce using rule 5 (statement -> input_stmt .)
    PLUS            reduce using rule 5 (statement -> input_stmt .)
    MINUS           reduce using rule 5 (statement -> input_stmt .)
    TRUE            reduce using rule 5 (statement -> input_stmt .)
    FALSE           reduce using rule 5 (statement -> input_stmt .)
    NULL_LITERAL    reduce using rule 5 (statement -> input_stmt .)
    STRING          reduce using rule 5 (statement -> input_stmt .)
    INT             reduce using rule 5 (statement -> input_stmt .)
    DOUBLE          reduce using rule 5 (statement -> input_stmt .)
    BOOL            reduce using rule 5 (statement -> input_stmt .)
    IF              reduce using rule 5 (statement -> input_stmt .)
    WHILE           reduce using rule 5 (statement -> input_stmt .)
    FOR             reduce using rule 5 (statement -> input_stmt .)
    SET             reduce using rule 5 (statement -> input_stmt .)
    LBRACE          reduce using rule 5 (statement -> input_stmt .)
    $end            reduce using rule 5 (statement -> input_stmt .)
    RBRACE          reduce using rule 5 (statement -> input_stmt .)


state 6

    (6) statement -> control_structures .

    SEMICOLON       reduce using rule 6 (statement -> control_structures .)
    PRINT           reduce using rule 6 (statement -> control_structures .)
    STDIN           reduce using rule 6 (statement -> control_structures .)
    VAR             reduce using rule 6 (statement -> control_structures .)
    VOID            reduce using rule 6 (statement -> control_structures .)
    LIST            reduce using rule 6 (statement -> control_structures .)
    MAP             reduce using rule 6 (statement -> control_structures .)
    DYNAMIC         reduce using rule 6 (statement -> control_structures .)
    STATIC          reduce using rule 6 (statement -> control_structures .)
    ID              reduce using rule 6 (statement -> control_structures .)
    RETURN          reduce using rule 6 (statement -> control_structures .)
    INCREMENT       reduce using rule 6 (statement -> control_structures .)
    DECREMENT       reduce using rule 6 (statement -> control_structures .)
    CLASS           reduce using rule 6 (statement -> control_structures .)
    BREAK           reduce using rule 6 (statement -> control_structures .)
    LPAREN          reduce using rule 6 (statement -> control_structures .)
    PLUS            reduce using rule 6 (statement -> control_structures .)
    MINUS           reduce using rule 6 (statement -> control_structures .)
    TRUE            reduce using rule 6 (statement -> control_structures .)
    FALSE           reduce using rule 6 (statement -> control_structures .)
    NULL_LITERAL    reduce using rule 6 (statement -> control_structures .)
    STRING          reduce using rule 6 (statement -> control_structures .)
    INT             reduce using rule 6 (statement -> control_structures .)
    DOUBLE          reduce using rule 6 (statement -> control_structures .)
    BOOL            reduce using rule 6 (statement -> control_structures .)
    IF              reduce using rule 6 (statement -> control_structures .)
    WHILE           reduce using rule 6 (statement -> control_structures .)
    FOR             reduce using rule 6 (statement -> control_structures .)
    SET             reduce using rule 6 (statement -> control_structures .)
    LBRACE          reduce using rule 6 (statement -> control_structures .)
    $end            reduce using rule 6 (statement -> control_structures .)
    RBRACE          reduce using rule 6 (statement -> control_structures .)


state 7

    (7) statement -> function .

    SEMICOLON       reduce using rule 7 (statement -> function .)
    PRINT           reduce using rule 7 (statement -> function .)
    STDIN           reduce using rule 7 (statement -> function .)
    VAR             reduce using rule 7 (statement -> function .)
    VOID            reduce using rule 7 (statement -> function .)
    LIST            reduce using rule 7 (statement -> function .)
    MAP             reduce using rule 7 (statement -> function .)
    DYNAMIC         reduce using rule 7 (statement -> function .)
    STATIC          reduce using rule 7 (statement -> function .)
    ID              reduce using rule 7 (statement -> function .)
    RETURN          reduce using rule 7 (statement -> function .)
    INCREMENT       reduce using rule 7 (statement -> function .)
    DECREMENT       reduce using rule 7 (statement -> function .)
    CLASS           reduce using rule 7 (statement -> function .)
    BREAK           reduce using rule 7 (statement -> function .)
    LPAREN          reduce using rule 7 (statement -> function .)
    PLUS            reduce using rule 7 (statement -> function .)
    MINUS           reduce using rule 7 (statement -> function .)
    TRUE            reduce using rule 7 (statement -> function .)
    FALSE           reduce using rule 7 (statement -> function .)
    NULL_LITERAL    reduce using rule 7 (statement -> function .)
    STRING          reduce using rule 7 (statement -> function .)
    INT             reduce using rule 7 (statement -> function .)
    DOUBLE          reduce using rule 7 (statement -> function .)
    BOOL            reduce using rule 7 (statement -> function .)
    IF              reduce using rule 7 (statement -> function .)
    WHILE           reduce using rule 7 (statement -> function .)
    FOR             reduce using rule 7 (statement -> function .)
    SET             reduce using rule 7 (statement -> function .)
    LBRACE          reduce using rule 7 (statement -> function .)
    $end            reduce using rule 7 (statement -> function .)
    RBRACE          reduce using rule 7 (statement -> function .)


state 8

    (8) statement -> lambda_function .

    SEMICOLON       reduce using rule 8 (statement -> lambda_function .)
    PRINT           reduce using rule 8 (statement -> lambda_function .)
    STDIN           reduce using rule 8 (statement -> lambda_function .)
    VAR             reduce using rule 8 (statement -> lambda_function .)
    VOID            reduce using rule 8 (statement -> lambda_function .)
    LIST            reduce using rule 8 (statement -> lambda_function .)
    MAP             reduce using rule 8 (statement -> lambda_function .)
    DYNAMIC         reduce using rule 8 (statement -> lambda_function .)
    STATIC          reduce using rule 8 (statement -> lambda_function .)
    ID              reduce using rule 8 (statement -> lambda_function .)
    RETURN          reduce using rule 8 (statement -> lambda_function .)
    INCREMENT       reduce using rule 8 (statement -> lambda_function .)
    DECREMENT       reduce using rule 8 (statement -> lambda_function .)
    CLASS           reduce using rule 8 (statement -> lambda_function .)
    BREAK           reduce using rule 8 (statement -> lambda_function .)
    LPAREN          reduce using rule 8 (statement -> lambda_function .)
    PLUS            reduce using rule 8 (statement -> lambda_function .)
    MINUS           reduce using rule 8 (statement -> lambda_function .)
    TRUE            reduce using rule 8 (statement -> lambda_function .)
    FALSE           reduce using rule 8 (statement -> lambda_function .)
    NULL_LITERAL    reduce using rule 8 (statement -> lambda_function .)
    STRING          reduce using rule 8 (statement -> lambda_function .)
    INT             reduce using rule 8 (statement -> lambda_function .)
    DOUBLE          reduce using rule 8 (statement -> lambda_function .)
    BOOL            reduce using rule 8 (statement -> lambda_function .)
    IF              reduce using rule 8 (statement -> lambda_function .)
    WHILE           reduce using rule 8 (statement -> lambda_function .)
    FOR             reduce using rule 8 (statement -> lambda_function .)
    SET             reduce using rule 8 (statement -> lambda_function .)
    LBRACE          reduce using rule 8 (statement -> lambda_function .)
    $end            reduce using rule 8 (statement -> lambda_function .)
    RBRACE          reduce using rule 8 (statement -> lambda_function .)


state 9

    (9) statement -> list_def .

    SEMICOLON       reduce using rule 9 (statement -> list_def .)
    PRINT           reduce using rule 9 (statement -> list_def .)
    STDIN           reduce using rule 9 (statement -> list_def .)
    VAR             reduce using rule 9 (statement -> list_def .)
    VOID            reduce using rule 9 (statement -> list_def .)
    LIST            reduce using rule 9 (statement -> list_def .)
    MAP             reduce using rule 9 (statement -> list_def .)
    DYNAMIC         reduce using rule 9 (statement -> list_def .)
    STATIC          reduce using rule 9 (statement -> list_def .)
    ID              reduce using rule 9 (statement -> list_def .)
    RETURN          reduce using rule 9 (statement -> list_def .)
    INCREMENT       reduce using rule 9 (statement -> list_def .)
    DECREMENT       reduce using rule 9 (statement -> list_def .)
    CLASS           reduce using rule 9 (statement -> list_def .)
    BREAK           reduce using rule 9 (statement -> list_def .)
    LPAREN          reduce using rule 9 (statement -> list_def .)
    PLUS            reduce using rule 9 (statement -> list_def .)
    MINUS           reduce using rule 9 (statement -> list_def .)
    TRUE            reduce using rule 9 (statement -> list_def .)
    FALSE           reduce using rule 9 (statement -> list_def .)
    NULL_LITERAL    reduce using rule 9 (statement -> list_def .)
    STRING          reduce using rule 9 (statement -> list_def .)
    INT             reduce using rule 9 (statement -> list_def .)
    DOUBLE          reduce using rule 9 (statement -> list_def .)
    BOOL            reduce using rule 9 (statement -> list_def .)
    IF              reduce using rule 9 (statement -> list_def .)
    WHILE           reduce using rule 9 (statement -> list_def .)
    FOR             reduce using rule 9 (statement -> list_def .)
    SET             reduce using rule 9 (statement -> list_def .)
    LBRACE          reduce using rule 9 (statement -> list_def .)
    $end            reduce using rule 9 (statement -> list_def .)
    RBRACE          reduce using rule 9 (statement -> list_def .)


state 10

    (10) statement -> map_def .

    SEMICOLON       reduce using rule 10 (statement -> map_def .)
    PRINT           reduce using rule 10 (statement -> map_def .)
    STDIN           reduce using rule 10 (statement -> map_def .)
    VAR             reduce using rule 10 (statement -> map_def .)
    VOID            reduce using rule 10 (statement -> map_def .)
    LIST            reduce using rule 10 (statement -> map_def .)
    MAP             reduce using rule 10 (statement -> map_def .)
    DYNAMIC         reduce using rule 10 (statement -> map_def .)
    STATIC          reduce using rule 10 (statement -> map_def .)
    ID              reduce using rule 10 (statement -> map_def .)
    RETURN          reduce using rule 10 (statement -> map_def .)
    INCREMENT       reduce using rule 10 (statement -> map_def .)
    DECREMENT       reduce using rule 10 (statement -> map_def .)
    CLASS           reduce using rule 10 (statement -> map_def .)
    BREAK           reduce using rule 10 (statement -> map_def .)
    LPAREN          reduce using rule 10 (statement -> map_def .)
    PLUS            reduce using rule 10 (statement -> map_def .)
    MINUS           reduce using rule 10 (statement -> map_def .)
    TRUE            reduce using rule 10 (statement -> map_def .)
    FALSE           reduce using rule 10 (statement -> map_def .)
    NULL_LITERAL    reduce using rule 10 (statement -> map_def .)
    STRING          reduce using rule 10 (statement -> map_def .)
    INT             reduce using rule 10 (statement -> map_def .)
    DOUBLE          reduce using rule 10 (statement -> map_def .)
    BOOL            reduce using rule 10 (statement -> map_def .)
    IF              reduce using rule 10 (statement -> map_def .)
    WHILE           reduce using rule 10 (statement -> map_def .)
    FOR             reduce using rule 10 (statement -> map_def .)
    SET             reduce using rule 10 (statement -> map_def .)
    LBRACE          reduce using rule 10 (statement -> map_def .)
    $end            reduce using rule 10 (statement -> map_def .)
    RBRACE          reduce using rule 10 (statement -> map_def .)


state 11

    (11) statement -> variable_def .

    SEMICOLON       reduce using rule 11 (statement -> variable_def .)
    PRINT           reduce using rule 11 (statement -> variable_def .)
    STDIN           reduce using rule 11 (statement -> variable_def .)
    VAR             reduce using rule 11 (statement -> variable_def .)
    VOID            reduce using rule 11 (statement -> variable_def .)
    LIST            reduce using rule 11 (statement -> variable_def .)
    MAP             reduce using rule 11 (statement -> variable_def .)
    DYNAMIC         reduce using rule 11 (statement -> variable_def .)
    STATIC          reduce using rule 11 (statement -> variable_def .)
    ID              reduce using rule 11 (statement -> variable_def .)
    RETURN          reduce using rule 11 (statement -> variable_def .)
    INCREMENT       reduce using rule 11 (statement -> variable_def .)
    DECREMENT       reduce using rule 11 (statement -> variable_def .)
    CLASS           reduce using rule 11 (statement -> variable_def .)
    BREAK           reduce using rule 11 (statement -> variable_def .)
    LPAREN          reduce using rule 11 (statement -> variable_def .)
    PLUS            reduce using rule 11 (statement -> variable_def .)
    MINUS           reduce using rule 11 (statement -> variable_def .)
    TRUE            reduce using rule 11 (statement -> variable_def .)
    FALSE           reduce using rule 11 (statement -> variable_def .)
    NULL_LITERAL    reduce using rule 11 (statement -> variable_def .)
    STRING          reduce using rule 11 (statement -> variable_def .)
    INT             reduce using rule 11 (statement -> variable_def .)
    DOUBLE          reduce using rule 11 (statement -> variable_def .)
    BOOL            reduce using rule 11 (statement -> variable_def .)
    IF              reduce using rule 11 (statement -> variable_def .)
    WHILE           reduce using rule 11 (statement -> variable_def .)
    FOR             reduce using rule 11 (statement -> variable_def .)
    SET             reduce using rule 11 (statement -> variable_def .)
    LBRACE          reduce using rule 11 (statement -> variable_def .)
    $end            reduce using rule 11 (statement -> variable_def .)
    RBRACE          reduce using rule 11 (statement -> variable_def .)


state 12

    (12) statement -> variable_only_def .

    SEMICOLON       reduce using rule 12 (statement -> variable_only_def .)
    PRINT           reduce using rule 12 (statement -> variable_only_def .)
    STDIN           reduce using rule 12 (statement -> variable_only_def .)
    VAR             reduce using rule 12 (statement -> variable_only_def .)
    VOID            reduce using rule 12 (statement -> variable_only_def .)
    LIST            reduce using rule 12 (statement -> variable_only_def .)
    MAP             reduce using rule 12 (statement -> variable_only_def .)
    DYNAMIC         reduce using rule 12 (statement -> variable_only_def .)
    STATIC          reduce using rule 12 (statement -> variable_only_def .)
    ID              reduce using rule 12 (statement -> variable_only_def .)
    RETURN          reduce using rule 12 (statement -> variable_only_def .)
    INCREMENT       reduce using rule 12 (statement -> variable_only_def .)
    DECREMENT       reduce using rule 12 (statement -> variable_only_def .)
    CLASS           reduce using rule 12 (statement -> variable_only_def .)
    BREAK           reduce using rule 12 (statement -> variable_only_def .)
    LPAREN          reduce using rule 12 (statement -> variable_only_def .)
    PLUS            reduce using rule 12 (statement -> variable_only_def .)
    MINUS           reduce using rule 12 (statement -> variable_only_def .)
    TRUE            reduce using rule 12 (statement -> variable_only_def .)
    FALSE           reduce using rule 12 (statement -> variable_only_def .)
    NULL_LITERAL    reduce using rule 12 (statement -> variable_only_def .)
    STRING          reduce using rule 12 (statement -> variable_only_def .)
    INT             reduce using rule 12 (statement -> variable_only_def .)
    DOUBLE          reduce using rule 12 (statement -> variable_only_def .)
    BOOL            reduce using rule 12 (statement -> variable_only_def .)
    IF              reduce using rule 12 (statement -> variable_only_def .)
    WHILE           reduce using rule 12 (statement -> variable_only_def .)
    FOR             reduce using rule 12 (statement -> variable_only_def .)
    SET             reduce using rule 12 (statement -> variable_only_def .)
    LBRACE          reduce using rule 12 (statement -> variable_only_def .)
    $end            reduce using rule 12 (statement -> variable_only_def .)
    RBRACE          reduce using rule 12 (statement -> variable_only_def .)


state 13

    (13) statement -> SEMICOLON .

    SEMICOLON       reduce using rule 13 (statement -> SEMICOLON .)
    PRINT           reduce using rule 13 (statement -> SEMICOLON .)
    STDIN           reduce using rule 13 (statement -> SEMICOLON .)
    VAR             reduce using rule 13 (statement -> SEMICOLON .)
    VOID            reduce using rule 13 (statement -> SEMICOLON .)
    LIST            reduce using rule 13 (statement -> SEMICOLON .)
    MAP             reduce using rule 13 (statement -> SEMICOLON .)
    DYNAMIC         reduce using rule 13 (statement -> SEMICOLON .)
    STATIC          reduce using rule 13 (statement -> SEMICOLON .)
    ID              reduce using rule 13 (statement -> SEMICOLON .)
    RETURN          reduce using rule 13 (statement -> SEMICOLON .)
    INCREMENT       reduce using rule 13 (statement -> SEMICOLON .)
    DECREMENT       reduce using rule 13 (statement -> SEMICOLON .)
    CLASS           reduce using rule 13 (statement -> SEMICOLON .)
    BREAK           reduce using rule 13 (statement -> SEMICOLON .)
    LPAREN          reduce using rule 13 (statement -> SEMICOLON .)
    PLUS            reduce using rule 13 (statement -> SEMICOLON .)
    MINUS           reduce using rule 13 (statement -> SEMICOLON .)
    TRUE            reduce using rule 13 (statement -> SEMICOLON .)
    FALSE           reduce using rule 13 (statement -> SEMICOLON .)
    NULL_LITERAL    reduce using rule 13 (statement -> SEMICOLON .)
    STRING          reduce using rule 13 (statement -> SEMICOLON .)
    INT             reduce using rule 13 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 13 (statement -> SEMICOLON .)
    BOOL            reduce using rule 13 (statement -> SEMICOLON .)
    IF              reduce using rule 13 (statement -> SEMICOLON .)
    WHILE           reduce using rule 13 (statement -> SEMICOLON .)
    FOR             reduce using rule 13 (statement -> SEMICOLON .)
    SET             reduce using rule 13 (statement -> SEMICOLON .)
    LBRACE          reduce using rule 13 (statement -> SEMICOLON .)
    $end            reduce using rule 13 (statement -> SEMICOLON .)
    RBRACE          reduce using rule 13 (statement -> SEMICOLON .)


state 14

    (14) statement -> function_call .

    SEMICOLON       reduce using rule 14 (statement -> function_call .)
    PRINT           reduce using rule 14 (statement -> function_call .)
    STDIN           reduce using rule 14 (statement -> function_call .)
    VAR             reduce using rule 14 (statement -> function_call .)
    VOID            reduce using rule 14 (statement -> function_call .)
    LIST            reduce using rule 14 (statement -> function_call .)
    MAP             reduce using rule 14 (statement -> function_call .)
    DYNAMIC         reduce using rule 14 (statement -> function_call .)
    STATIC          reduce using rule 14 (statement -> function_call .)
    ID              reduce using rule 14 (statement -> function_call .)
    RETURN          reduce using rule 14 (statement -> function_call .)
    INCREMENT       reduce using rule 14 (statement -> function_call .)
    DECREMENT       reduce using rule 14 (statement -> function_call .)
    CLASS           reduce using rule 14 (statement -> function_call .)
    BREAK           reduce using rule 14 (statement -> function_call .)
    LPAREN          reduce using rule 14 (statement -> function_call .)
    PLUS            reduce using rule 14 (statement -> function_call .)
    MINUS           reduce using rule 14 (statement -> function_call .)
    TRUE            reduce using rule 14 (statement -> function_call .)
    FALSE           reduce using rule 14 (statement -> function_call .)
    NULL_LITERAL    reduce using rule 14 (statement -> function_call .)
    STRING          reduce using rule 14 (statement -> function_call .)
    INT             reduce using rule 14 (statement -> function_call .)
    DOUBLE          reduce using rule 14 (statement -> function_call .)
    BOOL            reduce using rule 14 (statement -> function_call .)
    IF              reduce using rule 14 (statement -> function_call .)
    WHILE           reduce using rule 14 (statement -> function_call .)
    FOR             reduce using rule 14 (statement -> function_call .)
    SET             reduce using rule 14 (statement -> function_call .)
    LBRACE          reduce using rule 14 (statement -> function_call .)
    $end            reduce using rule 14 (statement -> function_call .)
    RBRACE          reduce using rule 14 (statement -> function_call .)


state 15

    (15) statement -> return_statement .

    SEMICOLON       reduce using rule 15 (statement -> return_statement .)
    PRINT           reduce using rule 15 (statement -> return_statement .)
    STDIN           reduce using rule 15 (statement -> return_statement .)
    VAR             reduce using rule 15 (statement -> return_statement .)
    VOID            reduce using rule 15 (statement -> return_statement .)
    LIST            reduce using rule 15 (statement -> return_statement .)
    MAP             reduce using rule 15 (statement -> return_statement .)
    DYNAMIC         reduce using rule 15 (statement -> return_statement .)
    STATIC          reduce using rule 15 (statement -> return_statement .)
    ID              reduce using rule 15 (statement -> return_statement .)
    RETURN          reduce using rule 15 (statement -> return_statement .)
    INCREMENT       reduce using rule 15 (statement -> return_statement .)
    DECREMENT       reduce using rule 15 (statement -> return_statement .)
    CLASS           reduce using rule 15 (statement -> return_statement .)
    BREAK           reduce using rule 15 (statement -> return_statement .)
    LPAREN          reduce using rule 15 (statement -> return_statement .)
    PLUS            reduce using rule 15 (statement -> return_statement .)
    MINUS           reduce using rule 15 (statement -> return_statement .)
    TRUE            reduce using rule 15 (statement -> return_statement .)
    FALSE           reduce using rule 15 (statement -> return_statement .)
    NULL_LITERAL    reduce using rule 15 (statement -> return_statement .)
    STRING          reduce using rule 15 (statement -> return_statement .)
    INT             reduce using rule 15 (statement -> return_statement .)
    DOUBLE          reduce using rule 15 (statement -> return_statement .)
    BOOL            reduce using rule 15 (statement -> return_statement .)
    IF              reduce using rule 15 (statement -> return_statement .)
    WHILE           reduce using rule 15 (statement -> return_statement .)
    FOR             reduce using rule 15 (statement -> return_statement .)
    SET             reduce using rule 15 (statement -> return_statement .)
    LBRACE          reduce using rule 15 (statement -> return_statement .)
    $end            reduce using rule 15 (statement -> return_statement .)
    RBRACE          reduce using rule 15 (statement -> return_statement .)


state 16

    (16) statement -> incdec_statement .

    SEMICOLON       reduce using rule 16 (statement -> incdec_statement .)
    PRINT           reduce using rule 16 (statement -> incdec_statement .)
    STDIN           reduce using rule 16 (statement -> incdec_statement .)
    VAR             reduce using rule 16 (statement -> incdec_statement .)
    VOID            reduce using rule 16 (statement -> incdec_statement .)
    LIST            reduce using rule 16 (statement -> incdec_statement .)
    MAP             reduce using rule 16 (statement -> incdec_statement .)
    DYNAMIC         reduce using rule 16 (statement -> incdec_statement .)
    STATIC          reduce using rule 16 (statement -> incdec_statement .)
    ID              reduce using rule 16 (statement -> incdec_statement .)
    RETURN          reduce using rule 16 (statement -> incdec_statement .)
    INCREMENT       reduce using rule 16 (statement -> incdec_statement .)
    DECREMENT       reduce using rule 16 (statement -> incdec_statement .)
    CLASS           reduce using rule 16 (statement -> incdec_statement .)
    BREAK           reduce using rule 16 (statement -> incdec_statement .)
    LPAREN          reduce using rule 16 (statement -> incdec_statement .)
    PLUS            reduce using rule 16 (statement -> incdec_statement .)
    MINUS           reduce using rule 16 (statement -> incdec_statement .)
    TRUE            reduce using rule 16 (statement -> incdec_statement .)
    FALSE           reduce using rule 16 (statement -> incdec_statement .)
    NULL_LITERAL    reduce using rule 16 (statement -> incdec_statement .)
    STRING          reduce using rule 16 (statement -> incdec_statement .)
    INT             reduce using rule 16 (statement -> incdec_statement .)
    DOUBLE          reduce using rule 16 (statement -> incdec_statement .)
    BOOL            reduce using rule 16 (statement -> incdec_statement .)
    IF              reduce using rule 16 (statement -> incdec_statement .)
    WHILE           reduce using rule 16 (statement -> incdec_statement .)
    FOR             reduce using rule 16 (statement -> incdec_statement .)
    SET             reduce using rule 16 (statement -> incdec_statement .)
    LBRACE          reduce using rule 16 (statement -> incdec_statement .)
    $end            reduce using rule 16 (statement -> incdec_statement .)
    RBRACE          reduce using rule 16 (statement -> incdec_statement .)


state 17

    (17) statement -> class_def .

    SEMICOLON       reduce using rule 17 (statement -> class_def .)
    PRINT           reduce using rule 17 (statement -> class_def .)
    STDIN           reduce using rule 17 (statement -> class_def .)
    VAR             reduce using rule 17 (statement -> class_def .)
    VOID            reduce using rule 17 (statement -> class_def .)
    LIST            reduce using rule 17 (statement -> class_def .)
    MAP             reduce using rule 17 (statement -> class_def .)
    DYNAMIC         reduce using rule 17 (statement -> class_def .)
    STATIC          reduce using rule 17 (statement -> class_def .)
    ID              reduce using rule 17 (statement -> class_def .)
    RETURN          reduce using rule 17 (statement -> class_def .)
    INCREMENT       reduce using rule 17 (statement -> class_def .)
    DECREMENT       reduce using rule 17 (statement -> class_def .)
    CLASS           reduce using rule 17 (statement -> class_def .)
    BREAK           reduce using rule 17 (statement -> class_def .)
    LPAREN          reduce using rule 17 (statement -> class_def .)
    PLUS            reduce using rule 17 (statement -> class_def .)
    MINUS           reduce using rule 17 (statement -> class_def .)
    TRUE            reduce using rule 17 (statement -> class_def .)
    FALSE           reduce using rule 17 (statement -> class_def .)
    NULL_LITERAL    reduce using rule 17 (statement -> class_def .)
    STRING          reduce using rule 17 (statement -> class_def .)
    INT             reduce using rule 17 (statement -> class_def .)
    DOUBLE          reduce using rule 17 (statement -> class_def .)
    BOOL            reduce using rule 17 (statement -> class_def .)
    IF              reduce using rule 17 (statement -> class_def .)
    WHILE           reduce using rule 17 (statement -> class_def .)
    FOR             reduce using rule 17 (statement -> class_def .)
    SET             reduce using rule 17 (statement -> class_def .)
    LBRACE          reduce using rule 17 (statement -> class_def .)
    $end            reduce using rule 17 (statement -> class_def .)
    RBRACE          reduce using rule 17 (statement -> class_def .)


state 18

    (18) statement -> object_instantiation .

    SEMICOLON       reduce using rule 18 (statement -> object_instantiation .)
    PRINT           reduce using rule 18 (statement -> object_instantiation .)
    STDIN           reduce using rule 18 (statement -> object_instantiation .)
    VAR             reduce using rule 18 (statement -> object_instantiation .)
    VOID            reduce using rule 18 (statement -> object_instantiation .)
    LIST            reduce using rule 18 (statement -> object_instantiation .)
    MAP             reduce using rule 18 (statement -> object_instantiation .)
    DYNAMIC         reduce using rule 18 (statement -> object_instantiation .)
    STATIC          reduce using rule 18 (statement -> object_instantiation .)
    ID              reduce using rule 18 (statement -> object_instantiation .)
    RETURN          reduce using rule 18 (statement -> object_instantiation .)
    INCREMENT       reduce using rule 18 (statement -> object_instantiation .)
    DECREMENT       reduce using rule 18 (statement -> object_instantiation .)
    CLASS           reduce using rule 18 (statement -> object_instantiation .)
    BREAK           reduce using rule 18 (statement -> object_instantiation .)
    LPAREN          reduce using rule 18 (statement -> object_instantiation .)
    PLUS            reduce using rule 18 (statement -> object_instantiation .)
    MINUS           reduce using rule 18 (statement -> object_instantiation .)
    TRUE            reduce using rule 18 (statement -> object_instantiation .)
    FALSE           reduce using rule 18 (statement -> object_instantiation .)
    NULL_LITERAL    reduce using rule 18 (statement -> object_instantiation .)
    STRING          reduce using rule 18 (statement -> object_instantiation .)
    INT             reduce using rule 18 (statement -> object_instantiation .)
    DOUBLE          reduce using rule 18 (statement -> object_instantiation .)
    BOOL            reduce using rule 18 (statement -> object_instantiation .)
    IF              reduce using rule 18 (statement -> object_instantiation .)
    WHILE           reduce using rule 18 (statement -> object_instantiation .)
    FOR             reduce using rule 18 (statement -> object_instantiation .)
    SET             reduce using rule 18 (statement -> object_instantiation .)
    LBRACE          reduce using rule 18 (statement -> object_instantiation .)
    $end            reduce using rule 18 (statement -> object_instantiation .)
    RBRACE          reduce using rule 18 (statement -> object_instantiation .)


state 19

    (19) statement -> break_stmt .

    SEMICOLON       reduce using rule 19 (statement -> break_stmt .)
    PRINT           reduce using rule 19 (statement -> break_stmt .)
    STDIN           reduce using rule 19 (statement -> break_stmt .)
    VAR             reduce using rule 19 (statement -> break_stmt .)
    VOID            reduce using rule 19 (statement -> break_stmt .)
    LIST            reduce using rule 19 (statement -> break_stmt .)
    MAP             reduce using rule 19 (statement -> break_stmt .)
    DYNAMIC         reduce using rule 19 (statement -> break_stmt .)
    STATIC          reduce using rule 19 (statement -> break_stmt .)
    ID              reduce using rule 19 (statement -> break_stmt .)
    RETURN          reduce using rule 19 (statement -> break_stmt .)
    INCREMENT       reduce using rule 19 (statement -> break_stmt .)
    DECREMENT       reduce using rule 19 (statement -> break_stmt .)
    CLASS           reduce using rule 19 (statement -> break_stmt .)
    BREAK           reduce using rule 19 (statement -> break_stmt .)
    LPAREN          reduce using rule 19 (statement -> break_stmt .)
    PLUS            reduce using rule 19 (statement -> break_stmt .)
    MINUS           reduce using rule 19 (statement -> break_stmt .)
    TRUE            reduce using rule 19 (statement -> break_stmt .)
    FALSE           reduce using rule 19 (statement -> break_stmt .)
    NULL_LITERAL    reduce using rule 19 (statement -> break_stmt .)
    STRING          reduce using rule 19 (statement -> break_stmt .)
    INT             reduce using rule 19 (statement -> break_stmt .)
    DOUBLE          reduce using rule 19 (statement -> break_stmt .)
    BOOL            reduce using rule 19 (statement -> break_stmt .)
    IF              reduce using rule 19 (statement -> break_stmt .)
    WHILE           reduce using rule 19 (statement -> break_stmt .)
    FOR             reduce using rule 19 (statement -> break_stmt .)
    SET             reduce using rule 19 (statement -> break_stmt .)
    LBRACE          reduce using rule 19 (statement -> break_stmt .)
    $end            reduce using rule 19 (statement -> break_stmt .)
    RBRACE          reduce using rule 19 (statement -> break_stmt .)


state 20

    (20) statement -> expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 21

    (188) print_stmt -> PRINT . LPAREN RPAREN SEMICOLON
    (189) print_stmt -> PRINT . LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> PRINT . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 68


state 22

    (40) expression -> LPAREN . expression RPAREN
    (58) expression -> LPAREN . parameters RPAREN ARROW expression
    (59) expression -> LPAREN . RPAREN ARROW expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (145) set_value -> . LBRACE value_list RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 70
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    REQUIRED        shift and go to state 80
    LBRACE          shift and go to state 31
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    expression                     shift and go to state 69
    parameters                     shift and go to state 71
    value                          shift and go to state 23
    parameter                      shift and go to state 75
    set_value                      shift and go to state 55
    type                           shift and go to state 79
    set_type                       shift and go to state 51

state 23

    (41) expression -> value .

    SEMICOLON       reduce using rule 41 (expression -> value .)
    PLUS            reduce using rule 41 (expression -> value .)
    MINUS           reduce using rule 41 (expression -> value .)
    TIMES           reduce using rule 41 (expression -> value .)
    DIVIDE          reduce using rule 41 (expression -> value .)
    INT_DIVIDE      reduce using rule 41 (expression -> value .)
    MODULE          reduce using rule 41 (expression -> value .)
    DOT             reduce using rule 41 (expression -> value .)
    QUESTION        reduce using rule 41 (expression -> value .)
    DOUBLE_DOT      reduce using rule 41 (expression -> value .)
    RPAREN          reduce using rule 41 (expression -> value .)
    COLON           reduce using rule 41 (expression -> value .)
    COMMA           reduce using rule 41 (expression -> value .)


state 24

    (191) input_stmt -> STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 81


state 25

    (192) input_stmt -> VAR . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (121) lambda_function -> VAR . ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> VAR . ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (30) variable_def -> VAR . ID ASSIGN expression SEMICOLON
    (126) variable_def -> VAR . ID ASSIGN anonymous_function SEMICOLON
    (24) variable_only_def -> VAR . ID SEMICOLON
    (174) object_instantiation -> VAR . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> VAR . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (184) object_instantiation -> VAR . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> VAR . ID ASSIGN ID LPAREN RPAREN SEMICOLON

    ID              shift and go to state 82


state 26

    (112) function_call -> ID . LPAREN RPAREN SEMICOLON
    (113) function_call -> ID . LPAREN argument_list RPAREN SEMICOLON
    (208) incdec_statement -> ID . INCREMENT SEMICOLON
    (209) incdec_statement -> ID . DECREMENT SEMICOLON
    (178) object_instantiation -> ID . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> ID . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> ID . ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> ID . ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> ID . ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> ID . ASSIGN ID LPAREN RPAREN SEMICOLON
    (42) expression -> ID . INCREMENT
    (43) expression -> ID . DECREMENT
    (47) expression -> ID . PLUS_EQUAL expression
    (48) expression -> ID . MINUS_EQUAL expression
    (49) expression -> ID . TIMES_EQUAL expression
    (50) expression -> ID . DIVIDE_EQUAL expression
    (51) expression -> ID . MODULE_EQUAL expression
    (204) value -> ID .

    LPAREN          shift and go to state 84
    INCREMENT       shift and go to state 85
    DECREMENT       shift and go to state 86
    ID              shift and go to state 83
    ASSIGN          shift and go to state 87
    PLUS_EQUAL      shift and go to state 88
    MINUS_EQUAL     shift and go to state 89
    TIMES_EQUAL     shift and go to state 90
    DIVIDE_EQUAL    shift and go to state 91
    MODULE_EQUAL    shift and go to state 92
    SEMICOLON       reduce using rule 204 (value -> ID .)
    PLUS            reduce using rule 204 (value -> ID .)
    MINUS           reduce using rule 204 (value -> ID .)
    TIMES           reduce using rule 204 (value -> ID .)
    DIVIDE          reduce using rule 204 (value -> ID .)
    INT_DIVIDE      reduce using rule 204 (value -> ID .)
    MODULE          reduce using rule 204 (value -> ID .)
    DOT             reduce using rule 204 (value -> ID .)
    QUESTION        reduce using rule 204 (value -> ID .)
    DOUBLE_DOT      reduce using rule 204 (value -> ID .)


state 27

    (193) input_stmt -> type . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (96) function -> type . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> type . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> type . ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> type . ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> type . ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (28) variable_def -> type . ID ASSIGN expression SEMICOLON
    (127) variable_def -> type . ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> type . ID SEMICOLON
    (175) object_instantiation -> type . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> type . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (186) object_instantiation -> type . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> type . ID ASSIGN ID LPAREN RPAREN SEMICOLON

    ID              shift and go to state 93


state 28

    (63) control_structures -> if_block .
    (64) control_structures -> if_block . else_block
    (68) else_block -> . ELSE LBRACE statement_composed RBRACE

    SEMICOLON       reduce using rule 63 (control_structures -> if_block .)
    PRINT           reduce using rule 63 (control_structures -> if_block .)
    STDIN           reduce using rule 63 (control_structures -> if_block .)
    VAR             reduce using rule 63 (control_structures -> if_block .)
    VOID            reduce using rule 63 (control_structures -> if_block .)
    LIST            reduce using rule 63 (control_structures -> if_block .)
    MAP             reduce using rule 63 (control_structures -> if_block .)
    DYNAMIC         reduce using rule 63 (control_structures -> if_block .)
    STATIC          reduce using rule 63 (control_structures -> if_block .)
    ID              reduce using rule 63 (control_structures -> if_block .)
    RETURN          reduce using rule 63 (control_structures -> if_block .)
    INCREMENT       reduce using rule 63 (control_structures -> if_block .)
    DECREMENT       reduce using rule 63 (control_structures -> if_block .)
    CLASS           reduce using rule 63 (control_structures -> if_block .)
    BREAK           reduce using rule 63 (control_structures -> if_block .)
    LPAREN          reduce using rule 63 (control_structures -> if_block .)
    PLUS            reduce using rule 63 (control_structures -> if_block .)
    MINUS           reduce using rule 63 (control_structures -> if_block .)
    TRUE            reduce using rule 63 (control_structures -> if_block .)
    FALSE           reduce using rule 63 (control_structures -> if_block .)
    NULL_LITERAL    reduce using rule 63 (control_structures -> if_block .)
    STRING          reduce using rule 63 (control_structures -> if_block .)
    INT             reduce using rule 63 (control_structures -> if_block .)
    DOUBLE          reduce using rule 63 (control_structures -> if_block .)
    BOOL            reduce using rule 63 (control_structures -> if_block .)
    IF              reduce using rule 63 (control_structures -> if_block .)
    WHILE           reduce using rule 63 (control_structures -> if_block .)
    FOR             reduce using rule 63 (control_structures -> if_block .)
    SET             reduce using rule 63 (control_structures -> if_block .)
    LBRACE          reduce using rule 63 (control_structures -> if_block .)
    $end            reduce using rule 63 (control_structures -> if_block .)
    RBRACE          reduce using rule 63 (control_structures -> if_block .)
    ELSE            shift and go to state 95

    else_block                     shift and go to state 94

state 29

    (65) control_structures -> while_loop .

    SEMICOLON       reduce using rule 65 (control_structures -> while_loop .)
    PRINT           reduce using rule 65 (control_structures -> while_loop .)
    STDIN           reduce using rule 65 (control_structures -> while_loop .)
    VAR             reduce using rule 65 (control_structures -> while_loop .)
    VOID            reduce using rule 65 (control_structures -> while_loop .)
    LIST            reduce using rule 65 (control_structures -> while_loop .)
    MAP             reduce using rule 65 (control_structures -> while_loop .)
    DYNAMIC         reduce using rule 65 (control_structures -> while_loop .)
    STATIC          reduce using rule 65 (control_structures -> while_loop .)
    ID              reduce using rule 65 (control_structures -> while_loop .)
    RETURN          reduce using rule 65 (control_structures -> while_loop .)
    INCREMENT       reduce using rule 65 (control_structures -> while_loop .)
    DECREMENT       reduce using rule 65 (control_structures -> while_loop .)
    CLASS           reduce using rule 65 (control_structures -> while_loop .)
    BREAK           reduce using rule 65 (control_structures -> while_loop .)
    LPAREN          reduce using rule 65 (control_structures -> while_loop .)
    PLUS            reduce using rule 65 (control_structures -> while_loop .)
    MINUS           reduce using rule 65 (control_structures -> while_loop .)
    TRUE            reduce using rule 65 (control_structures -> while_loop .)
    FALSE           reduce using rule 65 (control_structures -> while_loop .)
    NULL_LITERAL    reduce using rule 65 (control_structures -> while_loop .)
    STRING          reduce using rule 65 (control_structures -> while_loop .)
    INT             reduce using rule 65 (control_structures -> while_loop .)
    DOUBLE          reduce using rule 65 (control_structures -> while_loop .)
    BOOL            reduce using rule 65 (control_structures -> while_loop .)
    IF              reduce using rule 65 (control_structures -> while_loop .)
    WHILE           reduce using rule 65 (control_structures -> while_loop .)
    FOR             reduce using rule 65 (control_structures -> while_loop .)
    SET             reduce using rule 65 (control_structures -> while_loop .)
    LBRACE          reduce using rule 65 (control_structures -> while_loop .)
    $end            reduce using rule 65 (control_structures -> while_loop .)
    RBRACE          reduce using rule 65 (control_structures -> while_loop .)


state 30

    (66) control_structures -> for_loop .

    SEMICOLON       reduce using rule 66 (control_structures -> for_loop .)
    PRINT           reduce using rule 66 (control_structures -> for_loop .)
    STDIN           reduce using rule 66 (control_structures -> for_loop .)
    VAR             reduce using rule 66 (control_structures -> for_loop .)
    VOID            reduce using rule 66 (control_structures -> for_loop .)
    LIST            reduce using rule 66 (control_structures -> for_loop .)
    MAP             reduce using rule 66 (control_structures -> for_loop .)
    DYNAMIC         reduce using rule 66 (control_structures -> for_loop .)
    STATIC          reduce using rule 66 (control_structures -> for_loop .)
    ID              reduce using rule 66 (control_structures -> for_loop .)
    RETURN          reduce using rule 66 (control_structures -> for_loop .)
    INCREMENT       reduce using rule 66 (control_structures -> for_loop .)
    DECREMENT       reduce using rule 66 (control_structures -> for_loop .)
    CLASS           reduce using rule 66 (control_structures -> for_loop .)
    BREAK           reduce using rule 66 (control_structures -> for_loop .)
    LPAREN          reduce using rule 66 (control_structures -> for_loop .)
    PLUS            reduce using rule 66 (control_structures -> for_loop .)
    MINUS           reduce using rule 66 (control_structures -> for_loop .)
    TRUE            reduce using rule 66 (control_structures -> for_loop .)
    FALSE           reduce using rule 66 (control_structures -> for_loop .)
    NULL_LITERAL    reduce using rule 66 (control_structures -> for_loop .)
    STRING          reduce using rule 66 (control_structures -> for_loop .)
    INT             reduce using rule 66 (control_structures -> for_loop .)
    DOUBLE          reduce using rule 66 (control_structures -> for_loop .)
    BOOL            reduce using rule 66 (control_structures -> for_loop .)
    IF              reduce using rule 66 (control_structures -> for_loop .)
    WHILE           reduce using rule 66 (control_structures -> for_loop .)
    FOR             reduce using rule 66 (control_structures -> for_loop .)
    SET             reduce using rule 66 (control_structures -> for_loop .)
    LBRACE          reduce using rule 66 (control_structures -> for_loop .)
    $end            reduce using rule 66 (control_structures -> for_loop .)
    RBRACE          reduce using rule 66 (control_structures -> for_loop .)


state 31

    (145) set_value -> LBRACE . value_list RBRACE
    (132) value_list -> . value
    (133) value_list -> . value_list COMMA value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value_list                     shift and go to state 96
    value                          shift and go to state 97
    set_value                      shift and go to state 55

state 32

    (97) function -> VOID . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (99) function -> VOID . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (101) function -> VOID . ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE

    ID              shift and go to state 104


state 33

    (128) list_def -> LIST . LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> LIST . LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> LIST . LESS type GREATER ID SEMICOLON
    (131) list_def -> LIST . LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON

    LBRACKET        shift and go to state 105
    LESS            shift and go to state 106


state 34

    (136) map_def -> MAP . LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> MAP . ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> MAP . LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON

    LESS            shift and go to state 107
    ID              shift and go to state 108


state 35

    (29) variable_def -> DYNAMIC . ID ASSIGN expression SEMICOLON
    (23) variable_only_def -> DYNAMIC . ID SEMICOLON

    ID              shift and go to state 109


state 36

    (31) variable_def -> STATIC . type ID ASSIGN expression SEMICOLON
    (32) variable_def -> STATIC . VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> STATIC . DYNAMIC ID ASSIGN expression SEMICOLON
    (25) variable_only_def -> STATIC . type ID SEMICOLON
    (26) variable_only_def -> STATIC . VAR ID SEMICOLON
    (27) variable_only_def -> STATIC . DYNAMIC ID SEMICOLON
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    VAR             shift and go to state 111
    DYNAMIC         shift and go to state 112
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 110
    set_type                       shift and go to state 51

state 37

    (118) return_statement -> RETURN . expression SEMICOLON
    (119) return_statement -> RETURN . SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    SEMICOLON       shift and go to state 117
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 116
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 38

    (210) incdec_statement -> INCREMENT . ID SEMICOLON
    (52) expression -> INCREMENT . ID

    ID              shift and go to state 118


state 39

    (211) incdec_statement -> DECREMENT . ID SEMICOLON
    (53) expression -> DECREMENT . ID

    ID              shift and go to state 119


state 40

    (146) class_def -> CLASS . ID LBRACE class_body RBRACE
    (147) class_def -> CLASS . ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> CLASS . ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> CLASS . ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> CLASS . ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE

    ID              shift and go to state 120


state 41

    (92) break_stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 121


state 42

    (54) expression -> PLUS . ID

    ID              shift and go to state 122


state 43

    (55) expression -> MINUS . ID

    ID              shift and go to state 123


state 44

    (60) expression -> TRUE .
    (205) value -> TRUE .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for PLUS resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for MINUS resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for TIMES resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for INT_DIVIDE resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for MODULE resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for DOT resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for QUESTION resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for DOUBLE_DOT resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for COLON resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for COMMA resolved using rule 60 (expression -> TRUE .)
    SEMICOLON       reduce using rule 60 (expression -> TRUE .)
    PLUS            reduce using rule 60 (expression -> TRUE .)
    MINUS           reduce using rule 60 (expression -> TRUE .)
    TIMES           reduce using rule 60 (expression -> TRUE .)
    DIVIDE          reduce using rule 60 (expression -> TRUE .)
    INT_DIVIDE      reduce using rule 60 (expression -> TRUE .)
    MODULE          reduce using rule 60 (expression -> TRUE .)
    DOT             reduce using rule 60 (expression -> TRUE .)
    QUESTION        reduce using rule 60 (expression -> TRUE .)
    DOUBLE_DOT      reduce using rule 60 (expression -> TRUE .)
    RPAREN          reduce using rule 60 (expression -> TRUE .)
    COLON           reduce using rule 60 (expression -> TRUE .)
    COMMA           reduce using rule 60 (expression -> TRUE .)

  ! SEMICOLON       [ reduce using rule 205 (value -> TRUE .) ]
  ! PLUS            [ reduce using rule 205 (value -> TRUE .) ]
  ! MINUS           [ reduce using rule 205 (value -> TRUE .) ]
  ! TIMES           [ reduce using rule 205 (value -> TRUE .) ]
  ! DIVIDE          [ reduce using rule 205 (value -> TRUE .) ]
  ! INT_DIVIDE      [ reduce using rule 205 (value -> TRUE .) ]
  ! MODULE          [ reduce using rule 205 (value -> TRUE .) ]
  ! DOT             [ reduce using rule 205 (value -> TRUE .) ]
  ! QUESTION        [ reduce using rule 205 (value -> TRUE .) ]
  ! DOUBLE_DOT      [ reduce using rule 205 (value -> TRUE .) ]
  ! RPAREN          [ reduce using rule 205 (value -> TRUE .) ]
  ! COLON           [ reduce using rule 205 (value -> TRUE .) ]
  ! COMMA           [ reduce using rule 205 (value -> TRUE .) ]


state 45

    (61) expression -> FALSE .
    (206) value -> FALSE .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for PLUS resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for MINUS resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for TIMES resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for INT_DIVIDE resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for MODULE resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for DOT resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for QUESTION resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for DOUBLE_DOT resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for COLON resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for COMMA resolved using rule 61 (expression -> FALSE .)
    SEMICOLON       reduce using rule 61 (expression -> FALSE .)
    PLUS            reduce using rule 61 (expression -> FALSE .)
    MINUS           reduce using rule 61 (expression -> FALSE .)
    TIMES           reduce using rule 61 (expression -> FALSE .)
    DIVIDE          reduce using rule 61 (expression -> FALSE .)
    INT_DIVIDE      reduce using rule 61 (expression -> FALSE .)
    MODULE          reduce using rule 61 (expression -> FALSE .)
    DOT             reduce using rule 61 (expression -> FALSE .)
    QUESTION        reduce using rule 61 (expression -> FALSE .)
    DOUBLE_DOT      reduce using rule 61 (expression -> FALSE .)
    RPAREN          reduce using rule 61 (expression -> FALSE .)
    COLON           reduce using rule 61 (expression -> FALSE .)
    COMMA           reduce using rule 61 (expression -> FALSE .)

  ! SEMICOLON       [ reduce using rule 206 (value -> FALSE .) ]
  ! PLUS            [ reduce using rule 206 (value -> FALSE .) ]
  ! MINUS           [ reduce using rule 206 (value -> FALSE .) ]
  ! TIMES           [ reduce using rule 206 (value -> FALSE .) ]
  ! DIVIDE          [ reduce using rule 206 (value -> FALSE .) ]
  ! INT_DIVIDE      [ reduce using rule 206 (value -> FALSE .) ]
  ! MODULE          [ reduce using rule 206 (value -> FALSE .) ]
  ! DOT             [ reduce using rule 206 (value -> FALSE .) ]
  ! QUESTION        [ reduce using rule 206 (value -> FALSE .) ]
  ! DOUBLE_DOT      [ reduce using rule 206 (value -> FALSE .) ]
  ! RPAREN          [ reduce using rule 206 (value -> FALSE .) ]
  ! COLON           [ reduce using rule 206 (value -> FALSE .) ]
  ! COMMA           [ reduce using rule 206 (value -> FALSE .) ]


state 46

    (62) expression -> NULL_LITERAL .

    SEMICOLON       reduce using rule 62 (expression -> NULL_LITERAL .)
    PLUS            reduce using rule 62 (expression -> NULL_LITERAL .)
    MINUS           reduce using rule 62 (expression -> NULL_LITERAL .)
    TIMES           reduce using rule 62 (expression -> NULL_LITERAL .)
    DIVIDE          reduce using rule 62 (expression -> NULL_LITERAL .)
    INT_DIVIDE      reduce using rule 62 (expression -> NULL_LITERAL .)
    MODULE          reduce using rule 62 (expression -> NULL_LITERAL .)
    DOT             reduce using rule 62 (expression -> NULL_LITERAL .)
    QUESTION        reduce using rule 62 (expression -> NULL_LITERAL .)
    DOUBLE_DOT      reduce using rule 62 (expression -> NULL_LITERAL .)
    RPAREN          reduce using rule 62 (expression -> NULL_LITERAL .)
    COLON           reduce using rule 62 (expression -> NULL_LITERAL .)
    COMMA           reduce using rule 62 (expression -> NULL_LITERAL .)


state 47

    (194) type -> STRING .
    (203) value -> STRING .

    ID              reduce using rule 194 (type -> STRING .)
    SEMICOLON       reduce using rule 203 (value -> STRING .)
    PLUS            reduce using rule 203 (value -> STRING .)
    MINUS           reduce using rule 203 (value -> STRING .)
    TIMES           reduce using rule 203 (value -> STRING .)
    DIVIDE          reduce using rule 203 (value -> STRING .)
    INT_DIVIDE      reduce using rule 203 (value -> STRING .)
    MODULE          reduce using rule 203 (value -> STRING .)
    DOT             reduce using rule 203 (value -> STRING .)
    QUESTION        reduce using rule 203 (value -> STRING .)
    DOUBLE_DOT      reduce using rule 203 (value -> STRING .)


state 48

    (195) type -> INT .
    (201) value -> INT .

    ID              reduce using rule 195 (type -> INT .)
    SEMICOLON       reduce using rule 201 (value -> INT .)
    PLUS            reduce using rule 201 (value -> INT .)
    MINUS           reduce using rule 201 (value -> INT .)
    TIMES           reduce using rule 201 (value -> INT .)
    DIVIDE          reduce using rule 201 (value -> INT .)
    INT_DIVIDE      reduce using rule 201 (value -> INT .)
    MODULE          reduce using rule 201 (value -> INT .)
    DOT             reduce using rule 201 (value -> INT .)
    QUESTION        reduce using rule 201 (value -> INT .)
    DOUBLE_DOT      reduce using rule 201 (value -> INT .)


state 49

    (196) type -> DOUBLE .
    (202) value -> DOUBLE .

    ID              reduce using rule 196 (type -> DOUBLE .)
    SEMICOLON       reduce using rule 202 (value -> DOUBLE .)
    PLUS            reduce using rule 202 (value -> DOUBLE .)
    MINUS           reduce using rule 202 (value -> DOUBLE .)
    TIMES           reduce using rule 202 (value -> DOUBLE .)
    DIVIDE          reduce using rule 202 (value -> DOUBLE .)
    INT_DIVIDE      reduce using rule 202 (value -> DOUBLE .)
    MODULE          reduce using rule 202 (value -> DOUBLE .)
    DOT             reduce using rule 202 (value -> DOUBLE .)
    QUESTION        reduce using rule 202 (value -> DOUBLE .)
    DOUBLE_DOT      reduce using rule 202 (value -> DOUBLE .)


state 50

    (197) type -> BOOL .

    ID              reduce using rule 197 (type -> BOOL .)
    GREATER         reduce using rule 197 (type -> BOOL .)
    COMMA           reduce using rule 197 (type -> BOOL .)


state 51

    (198) type -> set_type .

    ID              reduce using rule 198 (type -> set_type .)
    GREATER         reduce using rule 198 (type -> set_type .)
    COMMA           reduce using rule 198 (type -> set_type .)


state 52

    (67) if_block -> IF . LPAREN conditions RPAREN LBRACE statement_composed RBRACE

    LPAREN          shift and go to state 124


state 53

    (84) while_loop -> WHILE . LPAREN conditions RPAREN LBRACE statement_composed RBRACE

    LPAREN          shift and go to state 125


state 54

    (85) for_loop -> FOR . LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> FOR . LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE

    LPAREN          shift and go to state 126


state 55

    (207) value -> set_value .

    SEMICOLON       reduce using rule 207 (value -> set_value .)
    PLUS            reduce using rule 207 (value -> set_value .)
    MINUS           reduce using rule 207 (value -> set_value .)
    TIMES           reduce using rule 207 (value -> set_value .)
    DIVIDE          reduce using rule 207 (value -> set_value .)
    INT_DIVIDE      reduce using rule 207 (value -> set_value .)
    MODULE          reduce using rule 207 (value -> set_value .)
    DOT             reduce using rule 207 (value -> set_value .)
    QUESTION        reduce using rule 207 (value -> set_value .)
    DOUBLE_DOT      reduce using rule 207 (value -> set_value .)
    RPAREN          reduce using rule 207 (value -> set_value .)
    RBRACE          reduce using rule 207 (value -> set_value .)
    COMMA           reduce using rule 207 (value -> set_value .)
    COLON           reduce using rule 207 (value -> set_value .)
    RBRACKET        reduce using rule 207 (value -> set_value .)
    GREATER         reduce using rule 207 (value -> set_value .)
    LESS            reduce using rule 207 (value -> set_value .)
    GREATER_EQUAL   reduce using rule 207 (value -> set_value .)
    LESS_EQUAL      reduce using rule 207 (value -> set_value .)
    EQUALS          reduce using rule 207 (value -> set_value .)
    NOT_EQUALS      reduce using rule 207 (value -> set_value .)
    AND             reduce using rule 207 (value -> set_value .)
    OR              reduce using rule 207 (value -> set_value .)


state 56

    (199) set_type -> SET .
    (200) set_type -> SET . LESS type GREATER

    ID              reduce using rule 199 (set_type -> SET .)
    GREATER         reduce using rule 199 (set_type -> SET .)
    COMMA           reduce using rule 199 (set_type -> SET .)
    LESS            shift and go to state 127


state 57

    (3) statement_composed -> statement_composed statement .

    SEMICOLON       reduce using rule 3 (statement_composed -> statement_composed statement .)
    PRINT           reduce using rule 3 (statement_composed -> statement_composed statement .)
    STDIN           reduce using rule 3 (statement_composed -> statement_composed statement .)
    VAR             reduce using rule 3 (statement_composed -> statement_composed statement .)
    VOID            reduce using rule 3 (statement_composed -> statement_composed statement .)
    LIST            reduce using rule 3 (statement_composed -> statement_composed statement .)
    MAP             reduce using rule 3 (statement_composed -> statement_composed statement .)
    DYNAMIC         reduce using rule 3 (statement_composed -> statement_composed statement .)
    STATIC          reduce using rule 3 (statement_composed -> statement_composed statement .)
    ID              reduce using rule 3 (statement_composed -> statement_composed statement .)
    RETURN          reduce using rule 3 (statement_composed -> statement_composed statement .)
    INCREMENT       reduce using rule 3 (statement_composed -> statement_composed statement .)
    DECREMENT       reduce using rule 3 (statement_composed -> statement_composed statement .)
    CLASS           reduce using rule 3 (statement_composed -> statement_composed statement .)
    BREAK           reduce using rule 3 (statement_composed -> statement_composed statement .)
    LPAREN          reduce using rule 3 (statement_composed -> statement_composed statement .)
    PLUS            reduce using rule 3 (statement_composed -> statement_composed statement .)
    MINUS           reduce using rule 3 (statement_composed -> statement_composed statement .)
    TRUE            reduce using rule 3 (statement_composed -> statement_composed statement .)
    FALSE           reduce using rule 3 (statement_composed -> statement_composed statement .)
    NULL_LITERAL    reduce using rule 3 (statement_composed -> statement_composed statement .)
    STRING          reduce using rule 3 (statement_composed -> statement_composed statement .)
    INT             reduce using rule 3 (statement_composed -> statement_composed statement .)
    DOUBLE          reduce using rule 3 (statement_composed -> statement_composed statement .)
    BOOL            reduce using rule 3 (statement_composed -> statement_composed statement .)
    IF              reduce using rule 3 (statement_composed -> statement_composed statement .)
    WHILE           reduce using rule 3 (statement_composed -> statement_composed statement .)
    FOR             reduce using rule 3 (statement_composed -> statement_composed statement .)
    SET             reduce using rule 3 (statement_composed -> statement_composed statement .)
    LBRACE          reduce using rule 3 (statement_composed -> statement_composed statement .)
    $end            reduce using rule 3 (statement_composed -> statement_composed statement .)
    RBRACE          reduce using rule 3 (statement_composed -> statement_composed statement .)


state 58

    (20) statement -> expression SEMICOLON .

    SEMICOLON       reduce using rule 20 (statement -> expression SEMICOLON .)
    PRINT           reduce using rule 20 (statement -> expression SEMICOLON .)
    STDIN           reduce using rule 20 (statement -> expression SEMICOLON .)
    VAR             reduce using rule 20 (statement -> expression SEMICOLON .)
    VOID            reduce using rule 20 (statement -> expression SEMICOLON .)
    LIST            reduce using rule 20 (statement -> expression SEMICOLON .)
    MAP             reduce using rule 20 (statement -> expression SEMICOLON .)
    DYNAMIC         reduce using rule 20 (statement -> expression SEMICOLON .)
    STATIC          reduce using rule 20 (statement -> expression SEMICOLON .)
    ID              reduce using rule 20 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 20 (statement -> expression SEMICOLON .)
    INCREMENT       reduce using rule 20 (statement -> expression SEMICOLON .)
    DECREMENT       reduce using rule 20 (statement -> expression SEMICOLON .)
    CLASS           reduce using rule 20 (statement -> expression SEMICOLON .)
    BREAK           reduce using rule 20 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 20 (statement -> expression SEMICOLON .)
    PLUS            reduce using rule 20 (statement -> expression SEMICOLON .)
    MINUS           reduce using rule 20 (statement -> expression SEMICOLON .)
    TRUE            reduce using rule 20 (statement -> expression SEMICOLON .)
    FALSE           reduce using rule 20 (statement -> expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 20 (statement -> expression SEMICOLON .)
    STRING          reduce using rule 20 (statement -> expression SEMICOLON .)
    INT             reduce using rule 20 (statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 20 (statement -> expression SEMICOLON .)
    BOOL            reduce using rule 20 (statement -> expression SEMICOLON .)
    IF              reduce using rule 20 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 20 (statement -> expression SEMICOLON .)
    FOR             reduce using rule 20 (statement -> expression SEMICOLON .)
    SET             reduce using rule 20 (statement -> expression SEMICOLON .)
    LBRACE          reduce using rule 20 (statement -> expression SEMICOLON .)
    $end            reduce using rule 20 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 20 (statement -> expression SEMICOLON .)


state 59

    (34) expression -> expression PLUS . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 128
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 60

    (35) expression -> expression MINUS . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 129
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 61

    (36) expression -> expression TIMES . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 130
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 62

    (37) expression -> expression DIVIDE . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 131
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 63

    (38) expression -> expression INT_DIVIDE . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 132
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 64

    (39) expression -> expression MODULE . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 133
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 65

    (44) expression -> expression DOT . ID
    (45) expression -> expression DOT . function_call
    (46) expression -> expression DOT . ID LPAREN argument_list_opt RPAREN
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON

    ID              shift and go to state 134

    function_call                  shift and go to state 135

state 66

    (56) expression -> expression QUESTION . expression COLON expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 136
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 67

    (57) expression -> expression DOUBLE_DOT . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 137
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 68

    (188) print_stmt -> PRINT LPAREN . RPAREN SEMICOLON
    (189) print_stmt -> PRINT LPAREN . value RPAREN SEMICOLON
    (190) print_stmt -> PRINT LPAREN . expression RPAREN SEMICOLON
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (145) set_value -> . LBRACE value_list RBRACE

    RPAREN          shift and go to state 138
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 141
    TRUE            shift and go to state 142
    FALSE           shift and go to state 143
    LPAREN          shift and go to state 22
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    NULL_LITERAL    shift and go to state 46
    LBRACE          shift and go to state 31

    value                          shift and go to state 139
    expression                     shift and go to state 140
    set_value                      shift and go to state 55

state 69

    (40) expression -> LPAREN expression . RPAREN
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    RPAREN          shift and go to state 144
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 70

    (59) expression -> LPAREN RPAREN . ARROW expression

    ARROW           shift and go to state 145


state 71

    (58) expression -> LPAREN parameters . RPAREN ARROW expression
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 146
    COMMA           shift and go to state 147


state 72

    (42) expression -> ID . INCREMENT
    (43) expression -> ID . DECREMENT
    (47) expression -> ID . PLUS_EQUAL expression
    (48) expression -> ID . MINUS_EQUAL expression
    (49) expression -> ID . TIMES_EQUAL expression
    (50) expression -> ID . DIVIDE_EQUAL expression
    (51) expression -> ID . MODULE_EQUAL expression
    (204) value -> ID .

    INCREMENT       shift and go to state 148
    DECREMENT       shift and go to state 149
    PLUS_EQUAL      shift and go to state 88
    MINUS_EQUAL     shift and go to state 89
    TIMES_EQUAL     shift and go to state 90
    DIVIDE_EQUAL    shift and go to state 91
    MODULE_EQUAL    shift and go to state 92
    RPAREN          reduce using rule 204 (value -> ID .)
    PLUS            reduce using rule 204 (value -> ID .)
    MINUS           reduce using rule 204 (value -> ID .)
    TIMES           reduce using rule 204 (value -> ID .)
    DIVIDE          reduce using rule 204 (value -> ID .)
    INT_DIVIDE      reduce using rule 204 (value -> ID .)
    MODULE          reduce using rule 204 (value -> ID .)
    DOT             reduce using rule 204 (value -> ID .)
    QUESTION        reduce using rule 204 (value -> ID .)
    DOUBLE_DOT      reduce using rule 204 (value -> ID .)
    SEMICOLON       reduce using rule 204 (value -> ID .)
    COLON           reduce using rule 204 (value -> ID .)
    COMMA           reduce using rule 204 (value -> ID .)


state 73

    (52) expression -> INCREMENT . ID

    ID              shift and go to state 150


state 74

    (53) expression -> DECREMENT . ID

    ID              shift and go to state 151


state 75

    (102) parameters -> parameter .

    RPAREN          reduce using rule 102 (parameters -> parameter .)
    COMMA           reduce using rule 102 (parameters -> parameter .)
    RBRACKET        reduce using rule 102 (parameters -> parameter .)


state 76

    (201) value -> INT .
    (195) type -> INT .

    RPAREN          reduce using rule 201 (value -> INT .)
    PLUS            reduce using rule 201 (value -> INT .)
    MINUS           reduce using rule 201 (value -> INT .)
    TIMES           reduce using rule 201 (value -> INT .)
    DIVIDE          reduce using rule 201 (value -> INT .)
    INT_DIVIDE      reduce using rule 201 (value -> INT .)
    MODULE          reduce using rule 201 (value -> INT .)
    DOT             reduce using rule 201 (value -> INT .)
    QUESTION        reduce using rule 201 (value -> INT .)
    DOUBLE_DOT      reduce using rule 201 (value -> INT .)
    ID              reduce using rule 195 (type -> INT .)


state 77

    (202) value -> DOUBLE .
    (196) type -> DOUBLE .

    RPAREN          reduce using rule 202 (value -> DOUBLE .)
    PLUS            reduce using rule 202 (value -> DOUBLE .)
    MINUS           reduce using rule 202 (value -> DOUBLE .)
    TIMES           reduce using rule 202 (value -> DOUBLE .)
    DIVIDE          reduce using rule 202 (value -> DOUBLE .)
    INT_DIVIDE      reduce using rule 202 (value -> DOUBLE .)
    MODULE          reduce using rule 202 (value -> DOUBLE .)
    DOT             reduce using rule 202 (value -> DOUBLE .)
    QUESTION        reduce using rule 202 (value -> DOUBLE .)
    DOUBLE_DOT      reduce using rule 202 (value -> DOUBLE .)
    ID              reduce using rule 196 (type -> DOUBLE .)


state 78

    (203) value -> STRING .
    (194) type -> STRING .

    RPAREN          reduce using rule 203 (value -> STRING .)
    PLUS            reduce using rule 203 (value -> STRING .)
    MINUS           reduce using rule 203 (value -> STRING .)
    TIMES           reduce using rule 203 (value -> STRING .)
    DIVIDE          reduce using rule 203 (value -> STRING .)
    INT_DIVIDE      reduce using rule 203 (value -> STRING .)
    MODULE          reduce using rule 203 (value -> STRING .)
    DOT             reduce using rule 203 (value -> STRING .)
    QUESTION        reduce using rule 203 (value -> STRING .)
    DOUBLE_DOT      reduce using rule 203 (value -> STRING .)
    ID              reduce using rule 194 (type -> STRING .)


state 79

    (104) parameter -> type . ID

    ID              shift and go to state 152


state 80

    (105) parameter -> REQUIRED . type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 153
    set_type                       shift and go to state 51

state 81

    (191) input_stmt -> STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 154


state 82

    (192) input_stmt -> VAR ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (121) lambda_function -> VAR ID . ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> VAR ID . ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (30) variable_def -> VAR ID . ASSIGN expression SEMICOLON
    (126) variable_def -> VAR ID . ASSIGN anonymous_function SEMICOLON
    (24) variable_only_def -> VAR ID . SEMICOLON
    (174) object_instantiation -> VAR ID . ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> VAR ID . ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (184) object_instantiation -> VAR ID . ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> VAR ID . ASSIGN ID LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 155
    SEMICOLON       shift and go to state 156


state 83

    (178) object_instantiation -> ID ID . ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> ID ID . ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON

    ASSIGN          shift and go to state 157


state 84

    (112) function_call -> ID LPAREN . RPAREN SEMICOLON
    (113) function_call -> ID LPAREN . argument_list RPAREN SEMICOLON
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    RPAREN          shift and go to state 158
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    argument_list                  shift and go to state 159
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 85

    (208) incdec_statement -> ID INCREMENT . SEMICOLON
    (42) expression -> ID INCREMENT .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 161
    PLUS            reduce using rule 42 (expression -> ID INCREMENT .)
    MINUS           reduce using rule 42 (expression -> ID INCREMENT .)
    TIMES           reduce using rule 42 (expression -> ID INCREMENT .)
    DIVIDE          reduce using rule 42 (expression -> ID INCREMENT .)
    INT_DIVIDE      reduce using rule 42 (expression -> ID INCREMENT .)
    MODULE          reduce using rule 42 (expression -> ID INCREMENT .)
    DOT             reduce using rule 42 (expression -> ID INCREMENT .)
    QUESTION        reduce using rule 42 (expression -> ID INCREMENT .)
    DOUBLE_DOT      reduce using rule 42 (expression -> ID INCREMENT .)

  ! SEMICOLON       [ reduce using rule 42 (expression -> ID INCREMENT .) ]


state 86

    (209) incdec_statement -> ID DECREMENT . SEMICOLON
    (43) expression -> ID DECREMENT .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 162
    PLUS            reduce using rule 43 (expression -> ID DECREMENT .)
    MINUS           reduce using rule 43 (expression -> ID DECREMENT .)
    TIMES           reduce using rule 43 (expression -> ID DECREMENT .)
    DIVIDE          reduce using rule 43 (expression -> ID DECREMENT .)
    INT_DIVIDE      reduce using rule 43 (expression -> ID DECREMENT .)
    MODULE          reduce using rule 43 (expression -> ID DECREMENT .)
    DOT             reduce using rule 43 (expression -> ID DECREMENT .)
    QUESTION        reduce using rule 43 (expression -> ID DECREMENT .)
    DOUBLE_DOT      reduce using rule 43 (expression -> ID DECREMENT .)

  ! SEMICOLON       [ reduce using rule 43 (expression -> ID DECREMENT .) ]


state 87

    (180) object_instantiation -> ID ASSIGN . NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> ID ASSIGN . ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> ID ASSIGN . NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> ID ASSIGN . ID LPAREN RPAREN SEMICOLON

    NEW             shift and go to state 164
    ID              shift and go to state 163


state 88

    (47) expression -> ID PLUS_EQUAL . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 165
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 89

    (48) expression -> ID MINUS_EQUAL . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 166
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 90

    (49) expression -> ID TIMES_EQUAL . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 167
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 91

    (50) expression -> ID DIVIDE_EQUAL . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 168
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 92

    (51) expression -> ID MODULE_EQUAL . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 169
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 93

    (193) input_stmt -> type ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (96) function -> type ID . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> type ID . LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> type ID . LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> type ID . ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> type ID . ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (28) variable_def -> type ID . ASSIGN expression SEMICOLON
    (127) variable_def -> type ID . ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> type ID . SEMICOLON
    (175) object_instantiation -> type ID . ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> type ID . ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (186) object_instantiation -> type ID . ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> type ID . ASSIGN ID LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 170
    LPAREN          shift and go to state 171
    SEMICOLON       shift and go to state 172


state 94

    (64) control_structures -> if_block else_block .

    SEMICOLON       reduce using rule 64 (control_structures -> if_block else_block .)
    PRINT           reduce using rule 64 (control_structures -> if_block else_block .)
    STDIN           reduce using rule 64 (control_structures -> if_block else_block .)
    VAR             reduce using rule 64 (control_structures -> if_block else_block .)
    VOID            reduce using rule 64 (control_structures -> if_block else_block .)
    LIST            reduce using rule 64 (control_structures -> if_block else_block .)
    MAP             reduce using rule 64 (control_structures -> if_block else_block .)
    DYNAMIC         reduce using rule 64 (control_structures -> if_block else_block .)
    STATIC          reduce using rule 64 (control_structures -> if_block else_block .)
    ID              reduce using rule 64 (control_structures -> if_block else_block .)
    RETURN          reduce using rule 64 (control_structures -> if_block else_block .)
    INCREMENT       reduce using rule 64 (control_structures -> if_block else_block .)
    DECREMENT       reduce using rule 64 (control_structures -> if_block else_block .)
    CLASS           reduce using rule 64 (control_structures -> if_block else_block .)
    BREAK           reduce using rule 64 (control_structures -> if_block else_block .)
    LPAREN          reduce using rule 64 (control_structures -> if_block else_block .)
    PLUS            reduce using rule 64 (control_structures -> if_block else_block .)
    MINUS           reduce using rule 64 (control_structures -> if_block else_block .)
    TRUE            reduce using rule 64 (control_structures -> if_block else_block .)
    FALSE           reduce using rule 64 (control_structures -> if_block else_block .)
    NULL_LITERAL    reduce using rule 64 (control_structures -> if_block else_block .)
    STRING          reduce using rule 64 (control_structures -> if_block else_block .)
    INT             reduce using rule 64 (control_structures -> if_block else_block .)
    DOUBLE          reduce using rule 64 (control_structures -> if_block else_block .)
    BOOL            reduce using rule 64 (control_structures -> if_block else_block .)
    IF              reduce using rule 64 (control_structures -> if_block else_block .)
    WHILE           reduce using rule 64 (control_structures -> if_block else_block .)
    FOR             reduce using rule 64 (control_structures -> if_block else_block .)
    SET             reduce using rule 64 (control_structures -> if_block else_block .)
    LBRACE          reduce using rule 64 (control_structures -> if_block else_block .)
    $end            reduce using rule 64 (control_structures -> if_block else_block .)
    RBRACE          reduce using rule 64 (control_structures -> if_block else_block .)


state 95

    (68) else_block -> ELSE . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 173


state 96

    (145) set_value -> LBRACE value_list . RBRACE
    (133) value_list -> value_list . COMMA value

    RBRACE          shift and go to state 174
    COMMA           shift and go to state 175


state 97

    (132) value_list -> value .

    RBRACE          reduce using rule 132 (value_list -> value .)
    COMMA           reduce using rule 132 (value_list -> value .)
    RBRACKET        reduce using rule 132 (value_list -> value .)


state 98

    (201) value -> INT .

    RBRACE          reduce using rule 201 (value -> INT .)
    COMMA           reduce using rule 201 (value -> INT .)
    SEMICOLON       reduce using rule 201 (value -> INT .)
    PLUS            reduce using rule 201 (value -> INT .)
    MINUS           reduce using rule 201 (value -> INT .)
    TIMES           reduce using rule 201 (value -> INT .)
    DIVIDE          reduce using rule 201 (value -> INT .)
    INT_DIVIDE      reduce using rule 201 (value -> INT .)
    MODULE          reduce using rule 201 (value -> INT .)
    DOT             reduce using rule 201 (value -> INT .)
    QUESTION        reduce using rule 201 (value -> INT .)
    DOUBLE_DOT      reduce using rule 201 (value -> INT .)
    RPAREN          reduce using rule 201 (value -> INT .)
    COLON           reduce using rule 201 (value -> INT .)
    RBRACKET        reduce using rule 201 (value -> INT .)
    GREATER         reduce using rule 201 (value -> INT .)
    LESS            reduce using rule 201 (value -> INT .)
    GREATER_EQUAL   reduce using rule 201 (value -> INT .)
    LESS_EQUAL      reduce using rule 201 (value -> INT .)
    EQUALS          reduce using rule 201 (value -> INT .)
    NOT_EQUALS      reduce using rule 201 (value -> INT .)
    AND             reduce using rule 201 (value -> INT .)
    OR              reduce using rule 201 (value -> INT .)


state 99

    (202) value -> DOUBLE .

    RBRACE          reduce using rule 202 (value -> DOUBLE .)
    COMMA           reduce using rule 202 (value -> DOUBLE .)
    SEMICOLON       reduce using rule 202 (value -> DOUBLE .)
    PLUS            reduce using rule 202 (value -> DOUBLE .)
    MINUS           reduce using rule 202 (value -> DOUBLE .)
    TIMES           reduce using rule 202 (value -> DOUBLE .)
    DIVIDE          reduce using rule 202 (value -> DOUBLE .)
    INT_DIVIDE      reduce using rule 202 (value -> DOUBLE .)
    MODULE          reduce using rule 202 (value -> DOUBLE .)
    DOT             reduce using rule 202 (value -> DOUBLE .)
    QUESTION        reduce using rule 202 (value -> DOUBLE .)
    DOUBLE_DOT      reduce using rule 202 (value -> DOUBLE .)
    RPAREN          reduce using rule 202 (value -> DOUBLE .)
    COLON           reduce using rule 202 (value -> DOUBLE .)
    RBRACKET        reduce using rule 202 (value -> DOUBLE .)
    GREATER         reduce using rule 202 (value -> DOUBLE .)
    LESS            reduce using rule 202 (value -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 202 (value -> DOUBLE .)
    LESS_EQUAL      reduce using rule 202 (value -> DOUBLE .)
    EQUALS          reduce using rule 202 (value -> DOUBLE .)
    NOT_EQUALS      reduce using rule 202 (value -> DOUBLE .)
    AND             reduce using rule 202 (value -> DOUBLE .)
    OR              reduce using rule 202 (value -> DOUBLE .)


state 100

    (203) value -> STRING .

    RBRACE          reduce using rule 203 (value -> STRING .)
    COMMA           reduce using rule 203 (value -> STRING .)
    SEMICOLON       reduce using rule 203 (value -> STRING .)
    PLUS            reduce using rule 203 (value -> STRING .)
    MINUS           reduce using rule 203 (value -> STRING .)
    TIMES           reduce using rule 203 (value -> STRING .)
    DIVIDE          reduce using rule 203 (value -> STRING .)
    INT_DIVIDE      reduce using rule 203 (value -> STRING .)
    MODULE          reduce using rule 203 (value -> STRING .)
    DOT             reduce using rule 203 (value -> STRING .)
    QUESTION        reduce using rule 203 (value -> STRING .)
    DOUBLE_DOT      reduce using rule 203 (value -> STRING .)
    RPAREN          reduce using rule 203 (value -> STRING .)
    COLON           reduce using rule 203 (value -> STRING .)
    RBRACKET        reduce using rule 203 (value -> STRING .)
    GREATER         reduce using rule 203 (value -> STRING .)
    LESS            reduce using rule 203 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 203 (value -> STRING .)
    LESS_EQUAL      reduce using rule 203 (value -> STRING .)
    EQUALS          reduce using rule 203 (value -> STRING .)
    NOT_EQUALS      reduce using rule 203 (value -> STRING .)
    AND             reduce using rule 203 (value -> STRING .)
    OR              reduce using rule 203 (value -> STRING .)


state 101

    (204) value -> ID .

    RBRACE          reduce using rule 204 (value -> ID .)
    COMMA           reduce using rule 204 (value -> ID .)
    RBRACKET        reduce using rule 204 (value -> ID .)
    RPAREN          reduce using rule 204 (value -> ID .)
    AND             reduce using rule 204 (value -> ID .)
    OR              reduce using rule 204 (value -> ID .)
    SEMICOLON       reduce using rule 204 (value -> ID .)
    COLON           reduce using rule 204 (value -> ID .)


state 102

    (205) value -> TRUE .

    RBRACE          reduce using rule 205 (value -> TRUE .)
    COMMA           reduce using rule 205 (value -> TRUE .)
    RBRACKET        reduce using rule 205 (value -> TRUE .)
    RPAREN          reduce using rule 205 (value -> TRUE .)
    AND             reduce using rule 205 (value -> TRUE .)
    OR              reduce using rule 205 (value -> TRUE .)
    SEMICOLON       reduce using rule 205 (value -> TRUE .)
    COLON           reduce using rule 205 (value -> TRUE .)


state 103

    (206) value -> FALSE .

    RBRACE          reduce using rule 206 (value -> FALSE .)
    COMMA           reduce using rule 206 (value -> FALSE .)
    RBRACKET        reduce using rule 206 (value -> FALSE .)
    RPAREN          reduce using rule 206 (value -> FALSE .)
    AND             reduce using rule 206 (value -> FALSE .)
    OR              reduce using rule 206 (value -> FALSE .)
    SEMICOLON       reduce using rule 206 (value -> FALSE .)
    COLON           reduce using rule 206 (value -> FALSE .)


state 104

    (97) function -> VOID ID . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (99) function -> VOID ID . LPAREN RPAREN LBRACE statement_composed RBRACE
    (101) function -> VOID ID . LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE

    LPAREN          shift and go to state 176


state 105

    (128) list_def -> LIST LBRACKET . value_list RBRACKET SEMICOLON
    (132) value_list -> . value
    (133) value_list -> . value_list COMMA value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value_list                     shift and go to state 177
    value                          shift and go to state 97
    set_value                      shift and go to state 55

state 106

    (129) list_def -> LIST LESS . type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> LIST LESS . type GREATER ID SEMICOLON
    (131) list_def -> LIST LESS . type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 178
    set_type                       shift and go to state 51

state 107

    (136) map_def -> MAP LESS . type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> MAP LESS . type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 179
    set_type                       shift and go to state 51

state 108

    (137) map_def -> MAP ID . ASSIGN LBRACE map_entries RBRACE SEMICOLON

    ASSIGN          shift and go to state 180


state 109

    (29) variable_def -> DYNAMIC ID . ASSIGN expression SEMICOLON
    (23) variable_only_def -> DYNAMIC ID . SEMICOLON

    ASSIGN          shift and go to state 181
    SEMICOLON       shift and go to state 182


state 110

    (31) variable_def -> STATIC type . ID ASSIGN expression SEMICOLON
    (25) variable_only_def -> STATIC type . ID SEMICOLON

    ID              shift and go to state 183


state 111

    (32) variable_def -> STATIC VAR . ID ASSIGN expression SEMICOLON
    (26) variable_only_def -> STATIC VAR . ID SEMICOLON

    ID              shift and go to state 184


state 112

    (33) variable_def -> STATIC DYNAMIC . ID ASSIGN expression SEMICOLON
    (27) variable_only_def -> STATIC DYNAMIC . ID SEMICOLON

    ID              shift and go to state 185


state 113

    (194) type -> STRING .

    ID              reduce using rule 194 (type -> STRING .)
    GREATER         reduce using rule 194 (type -> STRING .)
    COMMA           reduce using rule 194 (type -> STRING .)


state 114

    (195) type -> INT .

    ID              reduce using rule 195 (type -> INT .)
    GREATER         reduce using rule 195 (type -> INT .)
    COMMA           reduce using rule 195 (type -> INT .)


state 115

    (196) type -> DOUBLE .

    ID              reduce using rule 196 (type -> DOUBLE .)
    GREATER         reduce using rule 196 (type -> DOUBLE .)
    COMMA           reduce using rule 196 (type -> DOUBLE .)


state 116

    (118) return_statement -> RETURN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 186
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 117

    (119) return_statement -> RETURN SEMICOLON .

    SEMICOLON       reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    PRINT           reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    STDIN           reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    VAR             reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    VOID            reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    LIST            reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    MAP             reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    DYNAMIC         reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    STATIC          reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    ID              reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    DECREMENT       reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    CLASS           reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    BREAK           reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    PLUS            reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    MINUS           reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    TRUE            reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    FALSE           reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    NULL_LITERAL    reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    STRING          reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    INT             reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    DOUBLE          reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    BOOL            reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    IF              reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    WHILE           reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    FOR             reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    SET             reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    $end            reduce using rule 119 (return_statement -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 119 (return_statement -> RETURN SEMICOLON .)


state 118

    (210) incdec_statement -> INCREMENT ID . SEMICOLON
    (52) expression -> INCREMENT ID .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 187
    PLUS            reduce using rule 52 (expression -> INCREMENT ID .)
    MINUS           reduce using rule 52 (expression -> INCREMENT ID .)
    TIMES           reduce using rule 52 (expression -> INCREMENT ID .)
    DIVIDE          reduce using rule 52 (expression -> INCREMENT ID .)
    INT_DIVIDE      reduce using rule 52 (expression -> INCREMENT ID .)
    MODULE          reduce using rule 52 (expression -> INCREMENT ID .)
    DOT             reduce using rule 52 (expression -> INCREMENT ID .)
    QUESTION        reduce using rule 52 (expression -> INCREMENT ID .)
    DOUBLE_DOT      reduce using rule 52 (expression -> INCREMENT ID .)

  ! SEMICOLON       [ reduce using rule 52 (expression -> INCREMENT ID .) ]


state 119

    (211) incdec_statement -> DECREMENT ID . SEMICOLON
    (53) expression -> DECREMENT ID .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 188
    PLUS            reduce using rule 53 (expression -> DECREMENT ID .)
    MINUS           reduce using rule 53 (expression -> DECREMENT ID .)
    TIMES           reduce using rule 53 (expression -> DECREMENT ID .)
    DIVIDE          reduce using rule 53 (expression -> DECREMENT ID .)
    INT_DIVIDE      reduce using rule 53 (expression -> DECREMENT ID .)
    MODULE          reduce using rule 53 (expression -> DECREMENT ID .)
    DOT             reduce using rule 53 (expression -> DECREMENT ID .)
    QUESTION        reduce using rule 53 (expression -> DECREMENT ID .)
    DOUBLE_DOT      reduce using rule 53 (expression -> DECREMENT ID .)

  ! SEMICOLON       [ reduce using rule 53 (expression -> DECREMENT ID .) ]


state 120

    (146) class_def -> CLASS ID . LBRACE class_body RBRACE
    (147) class_def -> CLASS ID . EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> CLASS ID . IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> CLASS ID . EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> CLASS ID . EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE

    LBRACE          shift and go to state 189
    EXTENDS         shift and go to state 190
    IMPLEMENTS      shift and go to state 191


state 121

    (92) break_stmt -> BREAK SEMICOLON .

    SEMICOLON       reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    PRINT           reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    STDIN           reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    VAR             reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    VOID            reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    LIST            reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    MAP             reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    DYNAMIC         reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    STATIC          reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    CLASS           reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    PLUS            reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    MINUS           reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    NULL_LITERAL    reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    STRING          reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    BOOL            reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    SET             reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    $end            reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 92 (break_stmt -> BREAK SEMICOLON .)


state 122

    (54) expression -> PLUS ID .

    SEMICOLON       reduce using rule 54 (expression -> PLUS ID .)
    PLUS            reduce using rule 54 (expression -> PLUS ID .)
    MINUS           reduce using rule 54 (expression -> PLUS ID .)
    TIMES           reduce using rule 54 (expression -> PLUS ID .)
    DIVIDE          reduce using rule 54 (expression -> PLUS ID .)
    INT_DIVIDE      reduce using rule 54 (expression -> PLUS ID .)
    MODULE          reduce using rule 54 (expression -> PLUS ID .)
    DOT             reduce using rule 54 (expression -> PLUS ID .)
    QUESTION        reduce using rule 54 (expression -> PLUS ID .)
    DOUBLE_DOT      reduce using rule 54 (expression -> PLUS ID .)
    RPAREN          reduce using rule 54 (expression -> PLUS ID .)
    COLON           reduce using rule 54 (expression -> PLUS ID .)
    COMMA           reduce using rule 54 (expression -> PLUS ID .)


state 123

    (55) expression -> MINUS ID .

    SEMICOLON       reduce using rule 55 (expression -> MINUS ID .)
    PLUS            reduce using rule 55 (expression -> MINUS ID .)
    MINUS           reduce using rule 55 (expression -> MINUS ID .)
    TIMES           reduce using rule 55 (expression -> MINUS ID .)
    DIVIDE          reduce using rule 55 (expression -> MINUS ID .)
    INT_DIVIDE      reduce using rule 55 (expression -> MINUS ID .)
    MODULE          reduce using rule 55 (expression -> MINUS ID .)
    DOT             reduce using rule 55 (expression -> MINUS ID .)
    QUESTION        reduce using rule 55 (expression -> MINUS ID .)
    DOUBLE_DOT      reduce using rule 55 (expression -> MINUS ID .)
    RPAREN          reduce using rule 55 (expression -> MINUS ID .)
    COLON           reduce using rule 55 (expression -> MINUS ID .)
    COMMA           reduce using rule 55 (expression -> MINUS ID .)


state 124

    (67) if_block -> IF LPAREN . conditions RPAREN LBRACE statement_composed RBRACE
    (69) conditions -> . condition
    (70) conditions -> . conditions AND condition
    (71) conditions -> . conditions OR condition
    (72) condition -> . value comparison_operator value
    (73) condition -> . NOT value
    (74) condition -> . TRUE
    (75) condition -> . FALSE
    (76) condition -> . ID comparison_operator value
    (77) condition -> . ID comparison_operator ID
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    NOT             shift and go to state 195
    TRUE            shift and go to state 196
    FALSE           shift and go to state 197
    ID              shift and go to state 198
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    conditions                     shift and go to state 192
    condition                      shift and go to state 193
    value                          shift and go to state 194
    set_value                      shift and go to state 55

state 125

    (84) while_loop -> WHILE LPAREN . conditions RPAREN LBRACE statement_composed RBRACE
    (69) conditions -> . condition
    (70) conditions -> . conditions AND condition
    (71) conditions -> . conditions OR condition
    (72) condition -> . value comparison_operator value
    (73) condition -> . NOT value
    (74) condition -> . TRUE
    (75) condition -> . FALSE
    (76) condition -> . ID comparison_operator value
    (77) condition -> . ID comparison_operator ID
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    NOT             shift and go to state 195
    TRUE            shift and go to state 196
    FALSE           shift and go to state 197
    ID              shift and go to state 198
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    conditions                     shift and go to state 199
    condition                      shift and go to state 193
    value                          shift and go to state 194
    set_value                      shift and go to state 55

state 126

    (85) for_loop -> FOR LPAREN . for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> FOR LPAREN . type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (87) for_init -> . variable_def
    (88) for_init -> . empty
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (212) empty -> .
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    DYNAMIC         shift and go to state 204
    VAR             shift and go to state 205
    STATIC          shift and go to state 206
    SEMICOLON       reduce using rule 212 (empty -> .)
    SET             shift and go to state 56

    for_init                       shift and go to state 200
    type                           shift and go to state 201
    variable_def                   shift and go to state 202
    empty                          shift and go to state 203
    set_type                       shift and go to state 51

state 127

    (200) set_type -> SET LESS . type GREATER
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 207
    set_type                       shift and go to state 51

state 128

    (34) expression -> expression PLUS expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 34 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 34 (expression -> expression PLUS expression .)
    COLON           reduce using rule 34 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 34 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! INT_DIVIDE      [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! MODULE          [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! DOT             [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! QUESTION        [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 34 (expression -> expression PLUS expression .) ]


state 129

    (35) expression -> expression MINUS expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 35 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 35 (expression -> expression MINUS expression .)
    COLON           reduce using rule 35 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 35 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! INT_DIVIDE      [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! MODULE          [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! DOT             [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! QUESTION        [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 35 (expression -> expression MINUS expression .) ]


state 130

    (36) expression -> expression TIMES expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 36 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 36 (expression -> expression TIMES expression .)
    COLON           reduce using rule 36 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 36 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 36 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> expression TIMES expression .) ]
  ! INT_DIVIDE      [ reduce using rule 36 (expression -> expression TIMES expression .) ]
  ! MODULE          [ reduce using rule 36 (expression -> expression TIMES expression .) ]
  ! DOT             [ reduce using rule 36 (expression -> expression TIMES expression .) ]
  ! QUESTION        [ reduce using rule 36 (expression -> expression TIMES expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 36 (expression -> expression TIMES expression .) ]


state 131

    (37) expression -> expression DIVIDE expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 37 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 37 (expression -> expression DIVIDE expression .)
    COLON           reduce using rule 37 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 37 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]
  ! INT_DIVIDE      [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]
  ! MODULE          [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]
  ! DOT             [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]
  ! QUESTION        [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 37 (expression -> expression DIVIDE expression .) ]


state 132

    (38) expression -> expression INT_DIVIDE expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 38 (expression -> expression INT_DIVIDE expression .)
    RPAREN          reduce using rule 38 (expression -> expression INT_DIVIDE expression .)
    COLON           reduce using rule 38 (expression -> expression INT_DIVIDE expression .)
    COMMA           reduce using rule 38 (expression -> expression INT_DIVIDE expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]
  ! INT_DIVIDE      [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]
  ! MODULE          [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]
  ! DOT             [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]
  ! QUESTION        [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 38 (expression -> expression INT_DIVIDE expression .) ]


state 133

    (39) expression -> expression MODULE expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 39 (expression -> expression MODULE expression .)
    RPAREN          reduce using rule 39 (expression -> expression MODULE expression .)
    COLON           reduce using rule 39 (expression -> expression MODULE expression .)
    COMMA           reduce using rule 39 (expression -> expression MODULE expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 39 (expression -> expression MODULE expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression MODULE expression .) ]
  ! TIMES           [ reduce using rule 39 (expression -> expression MODULE expression .) ]
  ! DIVIDE          [ reduce using rule 39 (expression -> expression MODULE expression .) ]
  ! INT_DIVIDE      [ reduce using rule 39 (expression -> expression MODULE expression .) ]
  ! MODULE          [ reduce using rule 39 (expression -> expression MODULE expression .) ]
  ! DOT             [ reduce using rule 39 (expression -> expression MODULE expression .) ]
  ! QUESTION        [ reduce using rule 39 (expression -> expression MODULE expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 39 (expression -> expression MODULE expression .) ]


state 134

    (44) expression -> expression DOT ID .
    (46) expression -> expression DOT ID . LPAREN argument_list_opt RPAREN
    (112) function_call -> ID . LPAREN RPAREN SEMICOLON
    (113) function_call -> ID . LPAREN argument_list RPAREN SEMICOLON

    SEMICOLON       reduce using rule 44 (expression -> expression DOT ID .)
    PLUS            reduce using rule 44 (expression -> expression DOT ID .)
    MINUS           reduce using rule 44 (expression -> expression DOT ID .)
    TIMES           reduce using rule 44 (expression -> expression DOT ID .)
    DIVIDE          reduce using rule 44 (expression -> expression DOT ID .)
    INT_DIVIDE      reduce using rule 44 (expression -> expression DOT ID .)
    MODULE          reduce using rule 44 (expression -> expression DOT ID .)
    DOT             reduce using rule 44 (expression -> expression DOT ID .)
    QUESTION        reduce using rule 44 (expression -> expression DOT ID .)
    DOUBLE_DOT      reduce using rule 44 (expression -> expression DOT ID .)
    RPAREN          reduce using rule 44 (expression -> expression DOT ID .)
    COLON           reduce using rule 44 (expression -> expression DOT ID .)
    COMMA           reduce using rule 44 (expression -> expression DOT ID .)
    LPAREN          shift and go to state 208


state 135

    (45) expression -> expression DOT function_call .

    SEMICOLON       reduce using rule 45 (expression -> expression DOT function_call .)
    PLUS            reduce using rule 45 (expression -> expression DOT function_call .)
    MINUS           reduce using rule 45 (expression -> expression DOT function_call .)
    TIMES           reduce using rule 45 (expression -> expression DOT function_call .)
    DIVIDE          reduce using rule 45 (expression -> expression DOT function_call .)
    INT_DIVIDE      reduce using rule 45 (expression -> expression DOT function_call .)
    MODULE          reduce using rule 45 (expression -> expression DOT function_call .)
    DOT             reduce using rule 45 (expression -> expression DOT function_call .)
    QUESTION        reduce using rule 45 (expression -> expression DOT function_call .)
    DOUBLE_DOT      reduce using rule 45 (expression -> expression DOT function_call .)
    RPAREN          reduce using rule 45 (expression -> expression DOT function_call .)
    COLON           reduce using rule 45 (expression -> expression DOT function_call .)
    COMMA           reduce using rule 45 (expression -> expression DOT function_call .)


state 136

    (56) expression -> expression QUESTION expression . COLON expression
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    COLON           shift and go to state 209
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 137

    (57) expression -> expression DOUBLE_DOT expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 57 (expression -> expression DOUBLE_DOT expression .)
    RPAREN          reduce using rule 57 (expression -> expression DOUBLE_DOT expression .)
    COLON           reduce using rule 57 (expression -> expression DOUBLE_DOT expression .)
    COMMA           reduce using rule 57 (expression -> expression DOUBLE_DOT expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]
  ! MINUS           [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]
  ! TIMES           [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]
  ! DIVIDE          [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]
  ! INT_DIVIDE      [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]
  ! MODULE          [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]
  ! DOT             [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]
  ! QUESTION        [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 57 (expression -> expression DOUBLE_DOT expression .) ]


state 138

    (188) print_stmt -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 210


state 139

    (189) print_stmt -> PRINT LPAREN value . RPAREN SEMICOLON
    (41) expression -> value .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 211
    PLUS            reduce using rule 41 (expression -> value .)
    MINUS           reduce using rule 41 (expression -> value .)
    TIMES           reduce using rule 41 (expression -> value .)
    DIVIDE          reduce using rule 41 (expression -> value .)
    INT_DIVIDE      reduce using rule 41 (expression -> value .)
    MODULE          reduce using rule 41 (expression -> value .)
    DOT             reduce using rule 41 (expression -> value .)
    QUESTION        reduce using rule 41 (expression -> value .)
    DOUBLE_DOT      reduce using rule 41 (expression -> value .)

  ! RPAREN          [ reduce using rule 41 (expression -> value .) ]


state 140

    (190) print_stmt -> PRINT LPAREN expression . RPAREN SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    RPAREN          shift and go to state 212
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 141

    (204) value -> ID .
    (42) expression -> ID . INCREMENT
    (43) expression -> ID . DECREMENT
    (47) expression -> ID . PLUS_EQUAL expression
    (48) expression -> ID . MINUS_EQUAL expression
    (49) expression -> ID . TIMES_EQUAL expression
    (50) expression -> ID . DIVIDE_EQUAL expression
    (51) expression -> ID . MODULE_EQUAL expression

    RPAREN          reduce using rule 204 (value -> ID .)
    PLUS            reduce using rule 204 (value -> ID .)
    MINUS           reduce using rule 204 (value -> ID .)
    TIMES           reduce using rule 204 (value -> ID .)
    DIVIDE          reduce using rule 204 (value -> ID .)
    INT_DIVIDE      reduce using rule 204 (value -> ID .)
    MODULE          reduce using rule 204 (value -> ID .)
    DOT             reduce using rule 204 (value -> ID .)
    QUESTION        reduce using rule 204 (value -> ID .)
    DOUBLE_DOT      reduce using rule 204 (value -> ID .)
    INCREMENT       shift and go to state 148
    DECREMENT       shift and go to state 149
    PLUS_EQUAL      shift and go to state 88
    MINUS_EQUAL     shift and go to state 89
    TIMES_EQUAL     shift and go to state 90
    DIVIDE_EQUAL    shift and go to state 91
    MODULE_EQUAL    shift and go to state 92


state 142

    (205) value -> TRUE .
    (60) expression -> TRUE .

  ! reduce/reduce conflict for RPAREN resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for PLUS resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for MINUS resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for TIMES resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for INT_DIVIDE resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for MODULE resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for DOT resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for QUESTION resolved using rule 60 (expression -> TRUE .)
  ! reduce/reduce conflict for DOUBLE_DOT resolved using rule 60 (expression -> TRUE .)
    RPAREN          reduce using rule 60 (expression -> TRUE .)
    PLUS            reduce using rule 60 (expression -> TRUE .)
    MINUS           reduce using rule 60 (expression -> TRUE .)
    TIMES           reduce using rule 60 (expression -> TRUE .)
    DIVIDE          reduce using rule 60 (expression -> TRUE .)
    INT_DIVIDE      reduce using rule 60 (expression -> TRUE .)
    MODULE          reduce using rule 60 (expression -> TRUE .)
    DOT             reduce using rule 60 (expression -> TRUE .)
    QUESTION        reduce using rule 60 (expression -> TRUE .)
    DOUBLE_DOT      reduce using rule 60 (expression -> TRUE .)

  ! RPAREN          [ reduce using rule 205 (value -> TRUE .) ]
  ! PLUS            [ reduce using rule 205 (value -> TRUE .) ]
  ! MINUS           [ reduce using rule 205 (value -> TRUE .) ]
  ! TIMES           [ reduce using rule 205 (value -> TRUE .) ]
  ! DIVIDE          [ reduce using rule 205 (value -> TRUE .) ]
  ! INT_DIVIDE      [ reduce using rule 205 (value -> TRUE .) ]
  ! MODULE          [ reduce using rule 205 (value -> TRUE .) ]
  ! DOT             [ reduce using rule 205 (value -> TRUE .) ]
  ! QUESTION        [ reduce using rule 205 (value -> TRUE .) ]
  ! DOUBLE_DOT      [ reduce using rule 205 (value -> TRUE .) ]


state 143

    (206) value -> FALSE .
    (61) expression -> FALSE .

  ! reduce/reduce conflict for RPAREN resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for PLUS resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for MINUS resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for TIMES resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for INT_DIVIDE resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for MODULE resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for DOT resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for QUESTION resolved using rule 61 (expression -> FALSE .)
  ! reduce/reduce conflict for DOUBLE_DOT resolved using rule 61 (expression -> FALSE .)
    RPAREN          reduce using rule 61 (expression -> FALSE .)
    PLUS            reduce using rule 61 (expression -> FALSE .)
    MINUS           reduce using rule 61 (expression -> FALSE .)
    TIMES           reduce using rule 61 (expression -> FALSE .)
    DIVIDE          reduce using rule 61 (expression -> FALSE .)
    INT_DIVIDE      reduce using rule 61 (expression -> FALSE .)
    MODULE          reduce using rule 61 (expression -> FALSE .)
    DOT             reduce using rule 61 (expression -> FALSE .)
    QUESTION        reduce using rule 61 (expression -> FALSE .)
    DOUBLE_DOT      reduce using rule 61 (expression -> FALSE .)

  ! RPAREN          [ reduce using rule 206 (value -> FALSE .) ]
  ! PLUS            [ reduce using rule 206 (value -> FALSE .) ]
  ! MINUS           [ reduce using rule 206 (value -> FALSE .) ]
  ! TIMES           [ reduce using rule 206 (value -> FALSE .) ]
  ! DIVIDE          [ reduce using rule 206 (value -> FALSE .) ]
  ! INT_DIVIDE      [ reduce using rule 206 (value -> FALSE .) ]
  ! MODULE          [ reduce using rule 206 (value -> FALSE .) ]
  ! DOT             [ reduce using rule 206 (value -> FALSE .) ]
  ! QUESTION        [ reduce using rule 206 (value -> FALSE .) ]
  ! DOUBLE_DOT      [ reduce using rule 206 (value -> FALSE .) ]


state 144

    (40) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    INT_DIVIDE      reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    MODULE          reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    QUESTION        reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    DOUBLE_DOT      reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 40 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 40 (expression -> LPAREN expression RPAREN .)


state 145

    (59) expression -> LPAREN RPAREN ARROW . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 213
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 146

    (58) expression -> LPAREN parameters RPAREN . ARROW expression

    ARROW           shift and go to state 214


state 147

    (103) parameters -> parameters COMMA . parameter
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    parameter                      shift and go to state 215
    type                           shift and go to state 79
    set_type                       shift and go to state 51

state 148

    (42) expression -> ID INCREMENT .

    RPAREN          reduce using rule 42 (expression -> ID INCREMENT .)
    PLUS            reduce using rule 42 (expression -> ID INCREMENT .)
    MINUS           reduce using rule 42 (expression -> ID INCREMENT .)
    TIMES           reduce using rule 42 (expression -> ID INCREMENT .)
    DIVIDE          reduce using rule 42 (expression -> ID INCREMENT .)
    INT_DIVIDE      reduce using rule 42 (expression -> ID INCREMENT .)
    MODULE          reduce using rule 42 (expression -> ID INCREMENT .)
    DOT             reduce using rule 42 (expression -> ID INCREMENT .)
    QUESTION        reduce using rule 42 (expression -> ID INCREMENT .)
    DOUBLE_DOT      reduce using rule 42 (expression -> ID INCREMENT .)
    SEMICOLON       reduce using rule 42 (expression -> ID INCREMENT .)
    COLON           reduce using rule 42 (expression -> ID INCREMENT .)
    COMMA           reduce using rule 42 (expression -> ID INCREMENT .)


state 149

    (43) expression -> ID DECREMENT .

    RPAREN          reduce using rule 43 (expression -> ID DECREMENT .)
    PLUS            reduce using rule 43 (expression -> ID DECREMENT .)
    MINUS           reduce using rule 43 (expression -> ID DECREMENT .)
    TIMES           reduce using rule 43 (expression -> ID DECREMENT .)
    DIVIDE          reduce using rule 43 (expression -> ID DECREMENT .)
    INT_DIVIDE      reduce using rule 43 (expression -> ID DECREMENT .)
    MODULE          reduce using rule 43 (expression -> ID DECREMENT .)
    DOT             reduce using rule 43 (expression -> ID DECREMENT .)
    QUESTION        reduce using rule 43 (expression -> ID DECREMENT .)
    DOUBLE_DOT      reduce using rule 43 (expression -> ID DECREMENT .)
    SEMICOLON       reduce using rule 43 (expression -> ID DECREMENT .)
    COLON           reduce using rule 43 (expression -> ID DECREMENT .)
    COMMA           reduce using rule 43 (expression -> ID DECREMENT .)


state 150

    (52) expression -> INCREMENT ID .

    RPAREN          reduce using rule 52 (expression -> INCREMENT ID .)
    PLUS            reduce using rule 52 (expression -> INCREMENT ID .)
    MINUS           reduce using rule 52 (expression -> INCREMENT ID .)
    TIMES           reduce using rule 52 (expression -> INCREMENT ID .)
    DIVIDE          reduce using rule 52 (expression -> INCREMENT ID .)
    INT_DIVIDE      reduce using rule 52 (expression -> INCREMENT ID .)
    MODULE          reduce using rule 52 (expression -> INCREMENT ID .)
    DOT             reduce using rule 52 (expression -> INCREMENT ID .)
    QUESTION        reduce using rule 52 (expression -> INCREMENT ID .)
    DOUBLE_DOT      reduce using rule 52 (expression -> INCREMENT ID .)
    SEMICOLON       reduce using rule 52 (expression -> INCREMENT ID .)
    COLON           reduce using rule 52 (expression -> INCREMENT ID .)
    COMMA           reduce using rule 52 (expression -> INCREMENT ID .)


state 151

    (53) expression -> DECREMENT ID .

    RPAREN          reduce using rule 53 (expression -> DECREMENT ID .)
    PLUS            reduce using rule 53 (expression -> DECREMENT ID .)
    MINUS           reduce using rule 53 (expression -> DECREMENT ID .)
    TIMES           reduce using rule 53 (expression -> DECREMENT ID .)
    DIVIDE          reduce using rule 53 (expression -> DECREMENT ID .)
    INT_DIVIDE      reduce using rule 53 (expression -> DECREMENT ID .)
    MODULE          reduce using rule 53 (expression -> DECREMENT ID .)
    DOT             reduce using rule 53 (expression -> DECREMENT ID .)
    QUESTION        reduce using rule 53 (expression -> DECREMENT ID .)
    DOUBLE_DOT      reduce using rule 53 (expression -> DECREMENT ID .)
    SEMICOLON       reduce using rule 53 (expression -> DECREMENT ID .)
    COLON           reduce using rule 53 (expression -> DECREMENT ID .)
    COMMA           reduce using rule 53 (expression -> DECREMENT ID .)


state 152

    (104) parameter -> type ID .

    RPAREN          reduce using rule 104 (parameter -> type ID .)
    COMMA           reduce using rule 104 (parameter -> type ID .)
    RBRACKET        reduce using rule 104 (parameter -> type ID .)


state 153

    (105) parameter -> REQUIRED type . ID

    ID              shift and go to state 216


state 154

    (191) input_stmt -> STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 217


state 155

    (192) input_stmt -> VAR ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (121) lambda_function -> VAR ID ASSIGN . LPAREN parameters RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> VAR ID ASSIGN . LPAREN RPAREN ARROW expression SEMICOLON
    (30) variable_def -> VAR ID ASSIGN . expression SEMICOLON
    (126) variable_def -> VAR ID ASSIGN . anonymous_function SEMICOLON
    (174) object_instantiation -> VAR ID ASSIGN . NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> VAR ID ASSIGN . ID LPAREN argument_list_opt RPAREN SEMICOLON
    (184) object_instantiation -> VAR ID ASSIGN . NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> VAR ID ASSIGN . ID LPAREN RPAREN SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (124) anonymous_function -> . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (125) anonymous_function -> . LPAREN RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    STDIN           shift and go to state 219
    LPAREN          shift and go to state 220
    NEW             shift and go to state 223
    ID              shift and go to state 218
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 221
    anonymous_function             shift and go to state 222
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 156

    (24) variable_only_def -> VAR ID SEMICOLON .

    SEMICOLON       reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    PRINT           reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    STDIN           reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    VAR             reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    VOID            reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    LIST            reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    MAP             reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    DYNAMIC         reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    STATIC          reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    ID              reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    RETURN          reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    INCREMENT       reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    DECREMENT       reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    CLASS           reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    BREAK           reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    LPAREN          reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    PLUS            reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    MINUS           reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    TRUE            reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    FALSE           reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    STRING          reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    INT             reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    DOUBLE          reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    BOOL            reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    IF              reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    WHILE           reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    FOR             reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    SET             reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    LBRACE          reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    $end            reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)
    RBRACE          reduce using rule 24 (variable_only_def -> VAR ID SEMICOLON .)


state 157

    (178) object_instantiation -> ID ID ASSIGN . NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> ID ID ASSIGN . ID LPAREN argument_list_opt RPAREN SEMICOLON

    NEW             shift and go to state 225
    ID              shift and go to state 224


state 158

    (112) function_call -> ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 226


state 159

    (113) function_call -> ID LPAREN argument_list . RPAREN SEMICOLON
    (115) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 227
    COMMA           shift and go to state 228


state 160

    (114) argument_list -> expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    RPAREN          reduce using rule 114 (argument_list -> expression .)
    COMMA           reduce using rule 114 (argument_list -> expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 161

    (208) incdec_statement -> ID INCREMENT SEMICOLON .

    SEMICOLON       reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    PRINT           reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    STDIN           reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    VAR             reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    VOID            reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    LIST            reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    MAP             reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    DYNAMIC         reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    STATIC          reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    ID              reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    RETURN          reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    INCREMENT       reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    DECREMENT       reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    CLASS           reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    BREAK           reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    LPAREN          reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    PLUS            reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    MINUS           reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    TRUE            reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    FALSE           reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    NULL_LITERAL    reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    STRING          reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    INT             reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    DOUBLE          reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    BOOL            reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    IF              reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    WHILE           reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    FOR             reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    SET             reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    LBRACE          reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    $end            reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    RBRACE          reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)
    RPAREN          reduce using rule 208 (incdec_statement -> ID INCREMENT SEMICOLON .)


state 162

    (209) incdec_statement -> ID DECREMENT SEMICOLON .

    SEMICOLON       reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    PRINT           reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    STDIN           reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    VAR             reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    VOID            reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    LIST            reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    MAP             reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    DYNAMIC         reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    STATIC          reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    ID              reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    RETURN          reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    INCREMENT       reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    DECREMENT       reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    CLASS           reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    BREAK           reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    LPAREN          reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    PLUS            reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    MINUS           reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    TRUE            reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    FALSE           reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    NULL_LITERAL    reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    STRING          reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    INT             reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    DOUBLE          reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    BOOL            reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    IF              reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    WHILE           reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    FOR             reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    SET             reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    LBRACE          reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    $end            reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    RBRACE          reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)
    RPAREN          reduce using rule 209 (incdec_statement -> ID DECREMENT SEMICOLON .)


state 163

    (181) object_instantiation -> ID ASSIGN ID . LPAREN argument_list_opt RPAREN SEMICOLON
    (183) object_instantiation -> ID ASSIGN ID . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 229


state 164

    (180) object_instantiation -> ID ASSIGN NEW . ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> ID ASSIGN NEW . ID LPAREN RPAREN SEMICOLON

    ID              shift and go to state 230


state 165

    (47) expression -> ID PLUS_EQUAL expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 47 (expression -> ID PLUS_EQUAL expression .)
    RPAREN          reduce using rule 47 (expression -> ID PLUS_EQUAL expression .)
    COLON           reduce using rule 47 (expression -> ID PLUS_EQUAL expression .)
    COMMA           reduce using rule 47 (expression -> ID PLUS_EQUAL expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]
  ! INT_DIVIDE      [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]
  ! DOT             [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]
  ! QUESTION        [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 47 (expression -> ID PLUS_EQUAL expression .) ]


state 166

    (48) expression -> ID MINUS_EQUAL expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 48 (expression -> ID MINUS_EQUAL expression .)
    RPAREN          reduce using rule 48 (expression -> ID MINUS_EQUAL expression .)
    COLON           reduce using rule 48 (expression -> ID MINUS_EQUAL expression .)
    COMMA           reduce using rule 48 (expression -> ID MINUS_EQUAL expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]
  ! INT_DIVIDE      [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]
  ! DOT             [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]
  ! QUESTION        [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 48 (expression -> ID MINUS_EQUAL expression .) ]


state 167

    (49) expression -> ID TIMES_EQUAL expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 49 (expression -> ID TIMES_EQUAL expression .)
    RPAREN          reduce using rule 49 (expression -> ID TIMES_EQUAL expression .)
    COLON           reduce using rule 49 (expression -> ID TIMES_EQUAL expression .)
    COMMA           reduce using rule 49 (expression -> ID TIMES_EQUAL expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]
  ! INT_DIVIDE      [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]
  ! DOT             [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]
  ! QUESTION        [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 49 (expression -> ID TIMES_EQUAL expression .) ]


state 168

    (50) expression -> ID DIVIDE_EQUAL expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .)
    RPAREN          reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .)
    COLON           reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .)
    COMMA           reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]
  ! INT_DIVIDE      [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]
  ! DOT             [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]
  ! QUESTION        [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 50 (expression -> ID DIVIDE_EQUAL expression .) ]


state 169

    (51) expression -> ID MODULE_EQUAL expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 51 (expression -> ID MODULE_EQUAL expression .)
    RPAREN          reduce using rule 51 (expression -> ID MODULE_EQUAL expression .)
    COLON           reduce using rule 51 (expression -> ID MODULE_EQUAL expression .)
    COMMA           reduce using rule 51 (expression -> ID MODULE_EQUAL expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]
  ! INT_DIVIDE      [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]
  ! DOT             [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]
  ! QUESTION        [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 51 (expression -> ID MODULE_EQUAL expression .) ]


state 170

    (193) input_stmt -> type ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (120) lambda_function -> type ID ASSIGN . LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> type ID ASSIGN . LPAREN RPAREN ARROW expression SEMICOLON
    (28) variable_def -> type ID ASSIGN . expression SEMICOLON
    (127) variable_def -> type ID ASSIGN . anonymous_function SEMICOLON
    (175) object_instantiation -> type ID ASSIGN . NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> type ID ASSIGN . ID LPAREN argument_list_opt RPAREN SEMICOLON
    (186) object_instantiation -> type ID ASSIGN . NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> type ID ASSIGN . ID LPAREN RPAREN SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (124) anonymous_function -> . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (125) anonymous_function -> . LPAREN RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    STDIN           shift and go to state 232
    LPAREN          shift and go to state 233
    NEW             shift and go to state 236
    ID              shift and go to state 231
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 234
    anonymous_function             shift and go to state 235
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 171

    (96) function -> type ID LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> type ID LPAREN . RPAREN LBRACE statement_composed RBRACE
    (100) function -> type ID LPAREN . optional_parameters RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (106) optional_parameters -> . LBRACKET parameters RBRACKET
    (107) optional_parameters -> . LBRACE named_parameters RBRACE
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 238
    LBRACKET        shift and go to state 241
    LBRACE          shift and go to state 239
    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 79
    parameters                     shift and go to state 237
    optional_parameters            shift and go to state 240
    parameter                      shift and go to state 75
    set_type                       shift and go to state 51

state 172

    (22) variable_only_def -> type ID SEMICOLON .

    SEMICOLON       reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    PRINT           reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    STDIN           reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    VAR             reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    VOID            reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    LIST            reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    MAP             reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    DYNAMIC         reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    STATIC          reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    ID              reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    RETURN          reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    INCREMENT       reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    DECREMENT       reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    CLASS           reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    BREAK           reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    LPAREN          reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    PLUS            reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    MINUS           reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    TRUE            reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    FALSE           reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    STRING          reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    INT             reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    DOUBLE          reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    BOOL            reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    IF              reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    WHILE           reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    FOR             reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    SET             reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    LBRACE          reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    $end            reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)
    RBRACE          reduce using rule 22 (variable_only_def -> type ID SEMICOLON .)


state 173

    (68) else_block -> ELSE LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 242
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 174

    (145) set_value -> LBRACE value_list RBRACE .

    SEMICOLON       reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    PLUS            reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    MINUS           reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    TIMES           reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    DIVIDE          reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    INT_DIVIDE      reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    MODULE          reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    DOT             reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    QUESTION        reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    DOUBLE_DOT      reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    RPAREN          reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    RBRACE          reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    COMMA           reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    COLON           reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    RBRACKET        reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    GREATER         reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    LESS            reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    GREATER_EQUAL   reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    LESS_EQUAL      reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    EQUALS          reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    NOT_EQUALS      reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    AND             reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)
    OR              reduce using rule 145 (set_value -> LBRACE value_list RBRACE .)


state 175

    (133) value_list -> value_list COMMA . value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value                          shift and go to state 243
    set_value                      shift and go to state 55

state 176

    (97) function -> VOID ID LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (99) function -> VOID ID LPAREN . RPAREN LBRACE statement_composed RBRACE
    (101) function -> VOID ID LPAREN . optional_parameters RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (106) optional_parameters -> . LBRACKET parameters RBRACKET
    (107) optional_parameters -> . LBRACE named_parameters RBRACE
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 245
    LBRACKET        shift and go to state 241
    LBRACE          shift and go to state 239
    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    parameters                     shift and go to state 244
    optional_parameters            shift and go to state 246
    parameter                      shift and go to state 75
    type                           shift and go to state 79
    set_type                       shift and go to state 51

state 177

    (128) list_def -> LIST LBRACKET value_list . RBRACKET SEMICOLON
    (133) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 247
    COMMA           shift and go to state 175


state 178

    (129) list_def -> LIST LESS type . GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> LIST LESS type . GREATER ID SEMICOLON
    (131) list_def -> LIST LESS type . GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON

    GREATER         shift and go to state 248


state 179

    (136) map_def -> MAP LESS type . COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> MAP LESS type . COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON

    COMMA           shift and go to state 249


state 180

    (137) map_def -> MAP ID ASSIGN . LBRACE map_entries RBRACE SEMICOLON

    LBRACE          shift and go to state 250


state 181

    (29) variable_def -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 251
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 182

    (23) variable_only_def -> DYNAMIC ID SEMICOLON .

    SEMICOLON       reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    PRINT           reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    STDIN           reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    VAR             reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    VOID            reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    LIST            reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    MAP             reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    DYNAMIC         reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    STATIC          reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    ID              reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    RETURN          reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    INCREMENT       reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    DECREMENT       reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    CLASS           reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    BREAK           reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    LPAREN          reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    PLUS            reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    MINUS           reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    TRUE            reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    FALSE           reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    STRING          reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    INT             reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    DOUBLE          reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    BOOL            reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    IF              reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    WHILE           reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    FOR             reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    SET             reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    LBRACE          reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    $end            reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)
    RBRACE          reduce using rule 23 (variable_only_def -> DYNAMIC ID SEMICOLON .)


state 183

    (31) variable_def -> STATIC type ID . ASSIGN expression SEMICOLON
    (25) variable_only_def -> STATIC type ID . SEMICOLON

    ASSIGN          shift and go to state 252
    SEMICOLON       shift and go to state 253


state 184

    (32) variable_def -> STATIC VAR ID . ASSIGN expression SEMICOLON
    (26) variable_only_def -> STATIC VAR ID . SEMICOLON

    ASSIGN          shift and go to state 254
    SEMICOLON       shift and go to state 255


state 185

    (33) variable_def -> STATIC DYNAMIC ID . ASSIGN expression SEMICOLON
    (27) variable_only_def -> STATIC DYNAMIC ID . SEMICOLON

    ASSIGN          shift and go to state 256
    SEMICOLON       shift and go to state 257


state 186

    (118) return_statement -> RETURN expression SEMICOLON .

    SEMICOLON       reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    PRINT           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    STDIN           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    VAR             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    VOID            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    LIST            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    MAP             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    DYNAMIC         reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    STATIC          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    ID              reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    INCREMENT       reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    DECREMENT       reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    CLASS           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    PLUS            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    TRUE            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    FALSE           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    INT             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    DOUBLE          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    BOOL            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    SET             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    LBRACE          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)


state 187

    (210) incdec_statement -> INCREMENT ID SEMICOLON .

    SEMICOLON       reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    PRINT           reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    STDIN           reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    VAR             reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    VOID            reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    LIST            reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    MAP             reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    DYNAMIC         reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    STATIC          reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    ID              reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    RETURN          reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    INCREMENT       reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    DECREMENT       reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    CLASS           reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    BREAK           reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    LPAREN          reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    PLUS            reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    MINUS           reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    TRUE            reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    FALSE           reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    STRING          reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    INT             reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    DOUBLE          reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    BOOL            reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    IF              reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    WHILE           reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    FOR             reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    SET             reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    LBRACE          reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    $end            reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    RBRACE          reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)
    RPAREN          reduce using rule 210 (incdec_statement -> INCREMENT ID SEMICOLON .)


state 188

    (211) incdec_statement -> DECREMENT ID SEMICOLON .

    SEMICOLON       reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    PRINT           reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    STDIN           reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    VAR             reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    VOID            reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    LIST            reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    MAP             reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    DYNAMIC         reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    STATIC          reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    ID              reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    RETURN          reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    INCREMENT       reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    DECREMENT       reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    CLASS           reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    BREAK           reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    LPAREN          reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    PLUS            reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    MINUS           reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    TRUE            reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    FALSE           reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    STRING          reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    INT             reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    DOUBLE          reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    BOOL            reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    IF              reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    WHILE           reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    FOR             reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    SET             reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    LBRACE          reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    $end            reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    RBRACE          reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)
    RPAREN          reduce using rule 211 (incdec_statement -> DECREMENT ID SEMICOLON .)


state 189

    (146) class_def -> CLASS ID LBRACE . class_body RBRACE
    (151) class_body -> . class_member
    (152) class_body -> . class_body class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_body                     shift and go to state 259
    class_member                   shift and go to state 260
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 190

    (147) class_def -> CLASS ID EXTENDS . ID LBRACE class_body RBRACE
    (149) class_def -> CLASS ID EXTENDS . ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> CLASS ID EXTENDS . ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE

    ID              shift and go to state 270


state 191

    (148) class_def -> CLASS ID IMPLEMENTS . ID LBRACE class_body RBRACE

    ID              shift and go to state 271


state 192

    (67) if_block -> IF LPAREN conditions . RPAREN LBRACE statement_composed RBRACE
    (70) conditions -> conditions . AND condition
    (71) conditions -> conditions . OR condition

    RPAREN          shift and go to state 272
    AND             shift and go to state 273
    OR              shift and go to state 274


state 193

    (69) conditions -> condition .

    RPAREN          reduce using rule 69 (conditions -> condition .)
    AND             reduce using rule 69 (conditions -> condition .)
    OR              reduce using rule 69 (conditions -> condition .)
    SEMICOLON       reduce using rule 69 (conditions -> condition .)


state 194

    (72) condition -> value . comparison_operator value
    (78) comparison_operator -> . GREATER
    (79) comparison_operator -> . LESS
    (80) comparison_operator -> . GREATER_EQUAL
    (81) comparison_operator -> . LESS_EQUAL
    (82) comparison_operator -> . EQUALS
    (83) comparison_operator -> . NOT_EQUALS

    GREATER         shift and go to state 276
    LESS            shift and go to state 277
    GREATER_EQUAL   shift and go to state 278
    LESS_EQUAL      shift and go to state 279
    EQUALS          shift and go to state 280
    NOT_EQUALS      shift and go to state 281

    comparison_operator            shift and go to state 275

state 195

    (73) condition -> NOT . value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value                          shift and go to state 282
    set_value                      shift and go to state 55

state 196

    (74) condition -> TRUE .
    (205) value -> TRUE .

    RPAREN          reduce using rule 74 (condition -> TRUE .)
    AND             reduce using rule 74 (condition -> TRUE .)
    OR              reduce using rule 74 (condition -> TRUE .)
    SEMICOLON       reduce using rule 74 (condition -> TRUE .)
    GREATER         reduce using rule 205 (value -> TRUE .)
    LESS            reduce using rule 205 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 205 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 205 (value -> TRUE .)
    EQUALS          reduce using rule 205 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 205 (value -> TRUE .)


state 197

    (75) condition -> FALSE .
    (206) value -> FALSE .

    RPAREN          reduce using rule 75 (condition -> FALSE .)
    AND             reduce using rule 75 (condition -> FALSE .)
    OR              reduce using rule 75 (condition -> FALSE .)
    SEMICOLON       reduce using rule 75 (condition -> FALSE .)
    GREATER         reduce using rule 206 (value -> FALSE .)
    LESS            reduce using rule 206 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 206 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 206 (value -> FALSE .)
    EQUALS          reduce using rule 206 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 206 (value -> FALSE .)


state 198

    (76) condition -> ID . comparison_operator value
    (77) condition -> ID . comparison_operator ID
    (204) value -> ID .
    (78) comparison_operator -> . GREATER
    (79) comparison_operator -> . LESS
    (80) comparison_operator -> . GREATER_EQUAL
    (81) comparison_operator -> . LESS_EQUAL
    (82) comparison_operator -> . EQUALS
    (83) comparison_operator -> . NOT_EQUALS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
    GREATER         shift and go to state 276
    LESS            shift and go to state 277
    GREATER_EQUAL   shift and go to state 278
    LESS_EQUAL      shift and go to state 279
    EQUALS          shift and go to state 280
    NOT_EQUALS      shift and go to state 281

  ! GREATER         [ reduce using rule 204 (value -> ID .) ]
  ! LESS            [ reduce using rule 204 (value -> ID .) ]
  ! GREATER_EQUAL   [ reduce using rule 204 (value -> ID .) ]
  ! LESS_EQUAL      [ reduce using rule 204 (value -> ID .) ]
  ! EQUALS          [ reduce using rule 204 (value -> ID .) ]
  ! NOT_EQUALS      [ reduce using rule 204 (value -> ID .) ]

    comparison_operator            shift and go to state 283

state 199

    (84) while_loop -> WHILE LPAREN conditions . RPAREN LBRACE statement_composed RBRACE
    (70) conditions -> conditions . AND condition
    (71) conditions -> conditions . OR condition

    RPAREN          shift and go to state 284
    AND             shift and go to state 273
    OR              shift and go to state 274


state 200

    (85) for_loop -> FOR LPAREN for_init . SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE

    SEMICOLON       shift and go to state 285


state 201

    (86) for_loop -> FOR LPAREN type . ID IN ID RPAREN LBRACE statement_composed RBRACE
    (28) variable_def -> type . ID ASSIGN expression SEMICOLON
    (127) variable_def -> type . ID ASSIGN anonymous_function SEMICOLON

    ID              shift and go to state 286


state 202

    (87) for_init -> variable_def .

    SEMICOLON       reduce using rule 87 (for_init -> variable_def .)


state 203

    (88) for_init -> empty .

    SEMICOLON       reduce using rule 88 (for_init -> empty .)


state 204

    (29) variable_def -> DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 287


state 205

    (30) variable_def -> VAR . ID ASSIGN expression SEMICOLON
    (126) variable_def -> VAR . ID ASSIGN anonymous_function SEMICOLON

    ID              shift and go to state 288


state 206

    (31) variable_def -> STATIC . type ID ASSIGN expression SEMICOLON
    (32) variable_def -> STATIC . VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> STATIC . DYNAMIC ID ASSIGN expression SEMICOLON
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    VAR             shift and go to state 290
    DYNAMIC         shift and go to state 291
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 289
    set_type                       shift and go to state 51

state 207

    (200) set_type -> SET LESS type . GREATER

    GREATER         shift and go to state 292


state 208

    (46) expression -> expression DOT ID LPAREN . argument_list_opt RPAREN
    (112) function_call -> ID LPAREN . RPAREN SEMICOLON
    (113) function_call -> ID LPAREN . argument_list RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 158
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

  ! RPAREN          [ reduce using rule 212 (empty -> .) ]

    expression                     shift and go to state 160
    argument_list_opt              shift and go to state 293
    argument_list                  shift and go to state 294
    empty                          shift and go to state 295
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 209

    (56) expression -> expression QUESTION expression COLON . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 296
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 210

    (188) print_stmt -> PRINT LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 188 (print_stmt -> PRINT LPAREN RPAREN SEMICOLON .)


state 211

    (189) print_stmt -> PRINT LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 297


state 212

    (190) print_stmt -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 298


state 213

    (59) expression -> LPAREN RPAREN ARROW expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .)
    RPAREN          reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .)
    COLON           reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .)
    COMMA           reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! MINUS           [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! TIMES           [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DIVIDE          [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! INT_DIVIDE      [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! MODULE          [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DOT             [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! QUESTION        [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]


state 214

    (58) expression -> LPAREN parameters RPAREN ARROW . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 299
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 215

    (103) parameters -> parameters COMMA parameter .

    RPAREN          reduce using rule 103 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 103 (parameters -> parameters COMMA parameter .)
    RBRACKET        reduce using rule 103 (parameters -> parameters COMMA parameter .)


state 216

    (105) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 105 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 105 (parameter -> REQUIRED type ID .)
    RBRACKET        reduce using rule 105 (parameter -> REQUIRED type ID .)


state 217

    (191) input_stmt -> STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 300


state 218

    (176) object_instantiation -> VAR ID ASSIGN ID . LPAREN argument_list_opt RPAREN SEMICOLON
    (185) object_instantiation -> VAR ID ASSIGN ID . LPAREN RPAREN SEMICOLON
    (42) expression -> ID . INCREMENT
    (43) expression -> ID . DECREMENT
    (47) expression -> ID . PLUS_EQUAL expression
    (48) expression -> ID . MINUS_EQUAL expression
    (49) expression -> ID . TIMES_EQUAL expression
    (50) expression -> ID . DIVIDE_EQUAL expression
    (51) expression -> ID . MODULE_EQUAL expression
    (204) value -> ID .

    LPAREN          shift and go to state 301
    INCREMENT       shift and go to state 148
    DECREMENT       shift and go to state 149
    PLUS_EQUAL      shift and go to state 88
    MINUS_EQUAL     shift and go to state 89
    TIMES_EQUAL     shift and go to state 90
    DIVIDE_EQUAL    shift and go to state 91
    MODULE_EQUAL    shift and go to state 92
    SEMICOLON       reduce using rule 204 (value -> ID .)
    PLUS            reduce using rule 204 (value -> ID .)
    MINUS           reduce using rule 204 (value -> ID .)
    TIMES           reduce using rule 204 (value -> ID .)
    DIVIDE          reduce using rule 204 (value -> ID .)
    INT_DIVIDE      reduce using rule 204 (value -> ID .)
    MODULE          reduce using rule 204 (value -> ID .)
    DOT             reduce using rule 204 (value -> ID .)
    QUESTION        reduce using rule 204 (value -> ID .)
    DOUBLE_DOT      reduce using rule 204 (value -> ID .)


state 219

    (192) input_stmt -> VAR ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 302


state 220

    (121) lambda_function -> VAR ID ASSIGN LPAREN . parameters RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> VAR ID ASSIGN LPAREN . RPAREN ARROW expression SEMICOLON
    (40) expression -> LPAREN . expression RPAREN
    (58) expression -> LPAREN . parameters RPAREN ARROW expression
    (59) expression -> LPAREN . RPAREN ARROW expression
    (124) anonymous_function -> LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (125) anonymous_function -> LPAREN . RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (145) set_value -> . LBRACE value_list RBRACE
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 304
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    REQUIRED        shift and go to state 80
    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 50
    LBRACE          shift and go to state 31
    SET             shift and go to state 56

    parameters                     shift and go to state 303
    expression                     shift and go to state 69
    parameter                      shift and go to state 75
    value                          shift and go to state 23
    type                           shift and go to state 79
    set_value                      shift and go to state 55
    set_type                       shift and go to state 51

state 221

    (30) variable_def -> VAR ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 305
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 222

    (126) variable_def -> VAR ID ASSIGN anonymous_function . SEMICOLON

    SEMICOLON       shift and go to state 306


state 223

    (174) object_instantiation -> VAR ID ASSIGN NEW . ID LPAREN argument_list_opt RPAREN SEMICOLON
    (184) object_instantiation -> VAR ID ASSIGN NEW . ID LPAREN RPAREN SEMICOLON

    ID              shift and go to state 307


state 224

    (179) object_instantiation -> ID ID ASSIGN ID . LPAREN argument_list_opt RPAREN SEMICOLON

    LPAREN          shift and go to state 308


state 225

    (178) object_instantiation -> ID ID ASSIGN NEW . ID LPAREN argument_list_opt RPAREN SEMICOLON

    ID              shift and go to state 309


state 226

    (112) function_call -> ID LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    TIMES           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    DIVIDE          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    INT_DIVIDE      reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    MODULE          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    DOT             reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    QUESTION        reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    DOUBLE_DOT      reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    COLON           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    COMMA           reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 112 (function_call -> ID LPAREN RPAREN SEMICOLON .)


state 227

    (113) function_call -> ID LPAREN argument_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 310


state 228

    (115) argument_list -> argument_list COMMA . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 311
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 229

    (181) object_instantiation -> ID ASSIGN ID LPAREN . argument_list_opt RPAREN SEMICOLON
    (183) object_instantiation -> ID ASSIGN ID LPAREN . RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 313
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

  ! RPAREN          [ reduce using rule 212 (empty -> .) ]

    argument_list_opt              shift and go to state 312
    argument_list                  shift and go to state 314
    empty                          shift and go to state 295
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 230

    (180) object_instantiation -> ID ASSIGN NEW ID . LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> ID ASSIGN NEW ID . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 315


state 231

    (177) object_instantiation -> type ID ASSIGN ID . LPAREN argument_list_opt RPAREN SEMICOLON
    (187) object_instantiation -> type ID ASSIGN ID . LPAREN RPAREN SEMICOLON
    (42) expression -> ID . INCREMENT
    (43) expression -> ID . DECREMENT
    (47) expression -> ID . PLUS_EQUAL expression
    (48) expression -> ID . MINUS_EQUAL expression
    (49) expression -> ID . TIMES_EQUAL expression
    (50) expression -> ID . DIVIDE_EQUAL expression
    (51) expression -> ID . MODULE_EQUAL expression
    (204) value -> ID .

    LPAREN          shift and go to state 316
    INCREMENT       shift and go to state 148
    DECREMENT       shift and go to state 149
    PLUS_EQUAL      shift and go to state 88
    MINUS_EQUAL     shift and go to state 89
    TIMES_EQUAL     shift and go to state 90
    DIVIDE_EQUAL    shift and go to state 91
    MODULE_EQUAL    shift and go to state 92
    SEMICOLON       reduce using rule 204 (value -> ID .)
    PLUS            reduce using rule 204 (value -> ID .)
    MINUS           reduce using rule 204 (value -> ID .)
    TIMES           reduce using rule 204 (value -> ID .)
    DIVIDE          reduce using rule 204 (value -> ID .)
    INT_DIVIDE      reduce using rule 204 (value -> ID .)
    MODULE          reduce using rule 204 (value -> ID .)
    DOT             reduce using rule 204 (value -> ID .)
    QUESTION        reduce using rule 204 (value -> ID .)
    DOUBLE_DOT      reduce using rule 204 (value -> ID .)


state 232

    (193) input_stmt -> type ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 317


state 233

    (120) lambda_function -> type ID ASSIGN LPAREN . parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> type ID ASSIGN LPAREN . RPAREN ARROW expression SEMICOLON
    (40) expression -> LPAREN . expression RPAREN
    (58) expression -> LPAREN . parameters RPAREN ARROW expression
    (59) expression -> LPAREN . RPAREN ARROW expression
    (124) anonymous_function -> LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (125) anonymous_function -> LPAREN . RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (145) set_value -> . LBRACE value_list RBRACE
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 319
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    REQUIRED        shift and go to state 80
    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 50
    LBRACE          shift and go to state 31
    SET             shift and go to state 56

    type                           shift and go to state 79
    parameters                     shift and go to state 318
    expression                     shift and go to state 69
    parameter                      shift and go to state 75
    value                          shift and go to state 23
    set_value                      shift and go to state 55
    set_type                       shift and go to state 51

state 234

    (28) variable_def -> type ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 320
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 235

    (127) variable_def -> type ID ASSIGN anonymous_function . SEMICOLON

    SEMICOLON       shift and go to state 321


state 236

    (175) object_instantiation -> type ID ASSIGN NEW . ID LPAREN argument_list_opt RPAREN SEMICOLON
    (186) object_instantiation -> type ID ASSIGN NEW . ID LPAREN RPAREN SEMICOLON

    ID              shift and go to state 322


state 237

    (96) function -> type ID LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 323
    COMMA           shift and go to state 147


state 238

    (98) function -> type ID LPAREN RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 324


state 239

    (107) optional_parameters -> LBRACE . named_parameters RBRACE
    (108) named_parameters -> . named_parameter
    (109) named_parameters -> . named_parameters COMMA named_parameter
    (110) named_parameter -> . type ID
    (111) named_parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    REQUIRED        shift and go to state 328
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    named_parameters               shift and go to state 325
    named_parameter                shift and go to state 326
    type                           shift and go to state 327
    set_type                       shift and go to state 51

state 240

    (100) function -> type ID LPAREN optional_parameters . RPAREN LBRACE statement_composed RBRACE

    RPAREN          shift and go to state 329


state 241

    (106) optional_parameters -> LBRACKET . parameters RBRACKET
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    parameters                     shift and go to state 330
    parameter                      shift and go to state 75
    type                           shift and go to state 79
    set_type                       shift and go to state 51

state 242

    (68) else_block -> ELSE LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 331
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 243

    (133) value_list -> value_list COMMA value .

    RBRACE          reduce using rule 133 (value_list -> value_list COMMA value .)
    COMMA           reduce using rule 133 (value_list -> value_list COMMA value .)
    RBRACKET        reduce using rule 133 (value_list -> value_list COMMA value .)


state 244

    (97) function -> VOID ID LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 332
    COMMA           shift and go to state 147


state 245

    (99) function -> VOID ID LPAREN RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 333


state 246

    (101) function -> VOID ID LPAREN optional_parameters . RPAREN LBRACE statement_composed RBRACE

    RPAREN          shift and go to state 334


state 247

    (128) list_def -> LIST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 335


state 248

    (129) list_def -> LIST LESS type GREATER . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> LIST LESS type GREATER . ID SEMICOLON
    (131) list_def -> LIST LESS type GREATER . ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON

    ID              shift and go to state 336


state 249

    (136) map_def -> MAP LESS type COMMA . type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> MAP LESS type COMMA . type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 337
    set_type                       shift and go to state 51

state 250

    (137) map_def -> MAP ID ASSIGN LBRACE . map_entries RBRACE SEMICOLON
    (139) map_entries -> . map_entry
    (140) map_entries -> . map_entries COMMA map_entry
    (141) map_entry -> . value COLON value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    map_entries                    shift and go to state 338
    map_entry                      shift and go to state 339
    value                          shift and go to state 340
    set_value                      shift and go to state 55

state 251

    (29) variable_def -> DYNAMIC ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 341
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 252

    (31) variable_def -> STATIC type ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 342
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 253

    (25) variable_only_def -> STATIC type ID SEMICOLON .

    SEMICOLON       reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    PRINT           reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    STDIN           reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    VAR             reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    VOID            reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    LIST            reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    MAP             reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    DYNAMIC         reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    STATIC          reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    ID              reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    RETURN          reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    INCREMENT       reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    DECREMENT       reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    CLASS           reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    BREAK           reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    LPAREN          reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    PLUS            reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    MINUS           reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    TRUE            reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    FALSE           reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    STRING          reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    INT             reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    DOUBLE          reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    BOOL            reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    IF              reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    WHILE           reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    FOR             reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    SET             reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    LBRACE          reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    $end            reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)
    RBRACE          reduce using rule 25 (variable_only_def -> STATIC type ID SEMICOLON .)


state 254

    (32) variable_def -> STATIC VAR ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 343
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 255

    (26) variable_only_def -> STATIC VAR ID SEMICOLON .

    SEMICOLON       reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    PRINT           reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    STDIN           reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    VAR             reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    VOID            reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    LIST            reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    MAP             reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    DYNAMIC         reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    STATIC          reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    ID              reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    RETURN          reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    INCREMENT       reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    DECREMENT       reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    CLASS           reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    BREAK           reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    LPAREN          reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    PLUS            reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    MINUS           reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    TRUE            reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    FALSE           reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    STRING          reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    INT             reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    DOUBLE          reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    BOOL            reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    IF              reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    WHILE           reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    FOR             reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    SET             reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    LBRACE          reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    $end            reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)
    RBRACE          reduce using rule 26 (variable_only_def -> STATIC VAR ID SEMICOLON .)


state 256

    (33) variable_def -> STATIC DYNAMIC ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 344
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 257

    (27) variable_only_def -> STATIC DYNAMIC ID SEMICOLON .

    SEMICOLON       reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    PRINT           reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    STDIN           reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    VAR             reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    VOID            reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    LIST            reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    MAP             reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    DYNAMIC         reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    STATIC          reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    ID              reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    RETURN          reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    INCREMENT       reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    DECREMENT       reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    CLASS           reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    BREAK           reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    LPAREN          reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    PLUS            reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    MINUS           reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    TRUE            reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    FALSE           reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    STRING          reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    INT             reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    DOUBLE          reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    BOOL            reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    IF              reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    WHILE           reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    FOR             reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    SET             reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    LBRACE          reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    $end            reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)
    RBRACE          reduce using rule 27 (variable_only_def -> STATIC DYNAMIC ID SEMICOLON .)


state 258

    (172) constructor -> ID . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> ID . LPAREN RPAREN LBRACE statement_composed RBRACE

    LPAREN          shift and go to state 345


state 259

    (146) class_def -> CLASS ID LBRACE class_body . RBRACE
    (152) class_body -> class_body . class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RBRACE          shift and go to state 346
    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_member                   shift and go to state 347
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 260

    (151) class_body -> class_member .

    RBRACE          reduce using rule 151 (class_body -> class_member .)
    VAR             reduce using rule 151 (class_body -> class_member .)
    FINAL           reduce using rule 151 (class_body -> class_member .)
    CONST           reduce using rule 151 (class_body -> class_member .)
    STATIC          reduce using rule 151 (class_body -> class_member .)
    VOID            reduce using rule 151 (class_body -> class_member .)
    ID              reduce using rule 151 (class_body -> class_member .)
    STRING          reduce using rule 151 (class_body -> class_member .)
    INT             reduce using rule 151 (class_body -> class_member .)
    DOUBLE          reduce using rule 151 (class_body -> class_member .)
    BOOL            reduce using rule 151 (class_body -> class_member .)
    SET             reduce using rule 151 (class_body -> class_member .)


state 261

    (153) class_member -> class_property .

    RBRACE          reduce using rule 153 (class_member -> class_property .)
    VAR             reduce using rule 153 (class_member -> class_property .)
    FINAL           reduce using rule 153 (class_member -> class_property .)
    CONST           reduce using rule 153 (class_member -> class_property .)
    STATIC          reduce using rule 153 (class_member -> class_property .)
    VOID            reduce using rule 153 (class_member -> class_property .)
    ID              reduce using rule 153 (class_member -> class_property .)
    STRING          reduce using rule 153 (class_member -> class_property .)
    INT             reduce using rule 153 (class_member -> class_property .)
    DOUBLE          reduce using rule 153 (class_member -> class_property .)
    BOOL            reduce using rule 153 (class_member -> class_property .)
    SET             reduce using rule 153 (class_member -> class_property .)


state 262

    (154) class_member -> class_method .

    RBRACE          reduce using rule 154 (class_member -> class_method .)
    VAR             reduce using rule 154 (class_member -> class_method .)
    FINAL           reduce using rule 154 (class_member -> class_method .)
    CONST           reduce using rule 154 (class_member -> class_method .)
    STATIC          reduce using rule 154 (class_member -> class_method .)
    VOID            reduce using rule 154 (class_member -> class_method .)
    ID              reduce using rule 154 (class_member -> class_method .)
    STRING          reduce using rule 154 (class_member -> class_method .)
    INT             reduce using rule 154 (class_member -> class_method .)
    DOUBLE          reduce using rule 154 (class_member -> class_method .)
    BOOL            reduce using rule 154 (class_member -> class_method .)
    SET             reduce using rule 154 (class_member -> class_method .)


state 263

    (155) class_member -> constructor .

    RBRACE          reduce using rule 155 (class_member -> constructor .)
    VAR             reduce using rule 155 (class_member -> constructor .)
    FINAL           reduce using rule 155 (class_member -> constructor .)
    CONST           reduce using rule 155 (class_member -> constructor .)
    STATIC          reduce using rule 155 (class_member -> constructor .)
    VOID            reduce using rule 155 (class_member -> constructor .)
    ID              reduce using rule 155 (class_member -> constructor .)
    STRING          reduce using rule 155 (class_member -> constructor .)
    INT             reduce using rule 155 (class_member -> constructor .)
    DOUBLE          reduce using rule 155 (class_member -> constructor .)
    BOOL            reduce using rule 155 (class_member -> constructor .)
    SET             reduce using rule 155 (class_member -> constructor .)


state 264

    (156) class_property -> type . ID SEMICOLON
    (161) class_property -> type . ID ASSIGN expression SEMICOLON
    (166) class_method -> type . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> type . ID LPAREN RPAREN LBRACE statement_composed RBRACE

    ID              shift and go to state 348


state 265

    (157) class_property -> VAR . ID SEMICOLON
    (162) class_property -> VAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 349


state 266

    (158) class_property -> FINAL . type ID SEMICOLON
    (163) class_property -> FINAL . type ID ASSIGN expression SEMICOLON
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 350
    set_type                       shift and go to state 51

state 267

    (159) class_property -> CONST . type ID SEMICOLON
    (164) class_property -> CONST . type ID ASSIGN expression SEMICOLON
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 351
    set_type                       shift and go to state 51

state 268

    (160) class_property -> STATIC . type ID SEMICOLON
    (165) class_property -> STATIC . type ID ASSIGN expression SEMICOLON
    (170) class_method -> STATIC . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> STATIC . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    VOID            shift and go to state 353
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 352
    set_type                       shift and go to state 51

state 269

    (167) class_method -> VOID . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> VOID . ID LPAREN RPAREN LBRACE statement_composed RBRACE

    ID              shift and go to state 354


state 270

    (147) class_def -> CLASS ID EXTENDS ID . LBRACE class_body RBRACE
    (149) class_def -> CLASS ID EXTENDS ID . IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> CLASS ID EXTENDS ID . WITH ID IMPLEMENTS ID LBRACE class_body RBRACE

    LBRACE          shift and go to state 355
    IMPLEMENTS      shift and go to state 356
    WITH            shift and go to state 357


state 271

    (148) class_def -> CLASS ID IMPLEMENTS ID . LBRACE class_body RBRACE

    LBRACE          shift and go to state 358


state 272

    (67) if_block -> IF LPAREN conditions RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 359


state 273

    (70) conditions -> conditions AND . condition
    (72) condition -> . value comparison_operator value
    (73) condition -> . NOT value
    (74) condition -> . TRUE
    (75) condition -> . FALSE
    (76) condition -> . ID comparison_operator value
    (77) condition -> . ID comparison_operator ID
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    NOT             shift and go to state 195
    TRUE            shift and go to state 196
    FALSE           shift and go to state 197
    ID              shift and go to state 198
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    condition                      shift and go to state 360
    value                          shift and go to state 194
    set_value                      shift and go to state 55

state 274

    (71) conditions -> conditions OR . condition
    (72) condition -> . value comparison_operator value
    (73) condition -> . NOT value
    (74) condition -> . TRUE
    (75) condition -> . FALSE
    (76) condition -> . ID comparison_operator value
    (77) condition -> . ID comparison_operator ID
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    NOT             shift and go to state 195
    TRUE            shift and go to state 196
    FALSE           shift and go to state 197
    ID              shift and go to state 198
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    condition                      shift and go to state 361
    value                          shift and go to state 194
    set_value                      shift and go to state 55

state 275

    (72) condition -> value comparison_operator . value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value                          shift and go to state 362
    set_value                      shift and go to state 55

state 276

    (78) comparison_operator -> GREATER .

    INT             reduce using rule 78 (comparison_operator -> GREATER .)
    DOUBLE          reduce using rule 78 (comparison_operator -> GREATER .)
    STRING          reduce using rule 78 (comparison_operator -> GREATER .)
    ID              reduce using rule 78 (comparison_operator -> GREATER .)
    TRUE            reduce using rule 78 (comparison_operator -> GREATER .)
    FALSE           reduce using rule 78 (comparison_operator -> GREATER .)
    LBRACE          reduce using rule 78 (comparison_operator -> GREATER .)


state 277

    (79) comparison_operator -> LESS .

    INT             reduce using rule 79 (comparison_operator -> LESS .)
    DOUBLE          reduce using rule 79 (comparison_operator -> LESS .)
    STRING          reduce using rule 79 (comparison_operator -> LESS .)
    ID              reduce using rule 79 (comparison_operator -> LESS .)
    TRUE            reduce using rule 79 (comparison_operator -> LESS .)
    FALSE           reduce using rule 79 (comparison_operator -> LESS .)
    LBRACE          reduce using rule 79 (comparison_operator -> LESS .)


state 278

    (80) comparison_operator -> GREATER_EQUAL .

    INT             reduce using rule 80 (comparison_operator -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 80 (comparison_operator -> GREATER_EQUAL .)
    STRING          reduce using rule 80 (comparison_operator -> GREATER_EQUAL .)
    ID              reduce using rule 80 (comparison_operator -> GREATER_EQUAL .)
    TRUE            reduce using rule 80 (comparison_operator -> GREATER_EQUAL .)
    FALSE           reduce using rule 80 (comparison_operator -> GREATER_EQUAL .)
    LBRACE          reduce using rule 80 (comparison_operator -> GREATER_EQUAL .)


state 279

    (81) comparison_operator -> LESS_EQUAL .

    INT             reduce using rule 81 (comparison_operator -> LESS_EQUAL .)
    DOUBLE          reduce using rule 81 (comparison_operator -> LESS_EQUAL .)
    STRING          reduce using rule 81 (comparison_operator -> LESS_EQUAL .)
    ID              reduce using rule 81 (comparison_operator -> LESS_EQUAL .)
    TRUE            reduce using rule 81 (comparison_operator -> LESS_EQUAL .)
    FALSE           reduce using rule 81 (comparison_operator -> LESS_EQUAL .)
    LBRACE          reduce using rule 81 (comparison_operator -> LESS_EQUAL .)


state 280

    (82) comparison_operator -> EQUALS .

    INT             reduce using rule 82 (comparison_operator -> EQUALS .)
    DOUBLE          reduce using rule 82 (comparison_operator -> EQUALS .)
    STRING          reduce using rule 82 (comparison_operator -> EQUALS .)
    ID              reduce using rule 82 (comparison_operator -> EQUALS .)
    TRUE            reduce using rule 82 (comparison_operator -> EQUALS .)
    FALSE           reduce using rule 82 (comparison_operator -> EQUALS .)
    LBRACE          reduce using rule 82 (comparison_operator -> EQUALS .)


state 281

    (83) comparison_operator -> NOT_EQUALS .

    INT             reduce using rule 83 (comparison_operator -> NOT_EQUALS .)
    DOUBLE          reduce using rule 83 (comparison_operator -> NOT_EQUALS .)
    STRING          reduce using rule 83 (comparison_operator -> NOT_EQUALS .)
    ID              reduce using rule 83 (comparison_operator -> NOT_EQUALS .)
    TRUE            reduce using rule 83 (comparison_operator -> NOT_EQUALS .)
    FALSE           reduce using rule 83 (comparison_operator -> NOT_EQUALS .)
    LBRACE          reduce using rule 83 (comparison_operator -> NOT_EQUALS .)


state 282

    (73) condition -> NOT value .

    RPAREN          reduce using rule 73 (condition -> NOT value .)
    AND             reduce using rule 73 (condition -> NOT value .)
    OR              reduce using rule 73 (condition -> NOT value .)
    SEMICOLON       reduce using rule 73 (condition -> NOT value .)


state 283

    (76) condition -> ID comparison_operator . value
    (77) condition -> ID comparison_operator . ID
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    ID              shift and go to state 363
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value                          shift and go to state 364
    set_value                      shift and go to state 55

state 284

    (84) while_loop -> WHILE LPAREN conditions RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 365


state 285

    (85) for_loop -> FOR LPAREN for_init SEMICOLON . conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (69) conditions -> . condition
    (70) conditions -> . conditions AND condition
    (71) conditions -> . conditions OR condition
    (72) condition -> . value comparison_operator value
    (73) condition -> . NOT value
    (74) condition -> . TRUE
    (75) condition -> . FALSE
    (76) condition -> . ID comparison_operator value
    (77) condition -> . ID comparison_operator ID
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    NOT             shift and go to state 195
    TRUE            shift and go to state 196
    FALSE           shift and go to state 197
    ID              shift and go to state 198
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    conditions                     shift and go to state 366
    condition                      shift and go to state 193
    value                          shift and go to state 194
    set_value                      shift and go to state 55

state 286

    (86) for_loop -> FOR LPAREN type ID . IN ID RPAREN LBRACE statement_composed RBRACE
    (28) variable_def -> type ID . ASSIGN expression SEMICOLON
    (127) variable_def -> type ID . ASSIGN anonymous_function SEMICOLON

    IN              shift and go to state 367
    ASSIGN          shift and go to state 368


state 287

    (29) variable_def -> DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 181


state 288

    (30) variable_def -> VAR ID . ASSIGN expression SEMICOLON
    (126) variable_def -> VAR ID . ASSIGN anonymous_function SEMICOLON

    ASSIGN          shift and go to state 369


state 289

    (31) variable_def -> STATIC type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 370


state 290

    (32) variable_def -> STATIC VAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 371


state 291

    (33) variable_def -> STATIC DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 372


state 292

    (200) set_type -> SET LESS type GREATER .

    ID              reduce using rule 200 (set_type -> SET LESS type GREATER .)
    GREATER         reduce using rule 200 (set_type -> SET LESS type GREATER .)
    COMMA           reduce using rule 200 (set_type -> SET LESS type GREATER .)


state 293

    (46) expression -> expression DOT ID LPAREN argument_list_opt . RPAREN

    RPAREN          shift and go to state 373


state 294

    (113) function_call -> ID LPAREN argument_list . RPAREN SEMICOLON
    (116) argument_list_opt -> argument_list .
    (115) argument_list -> argument_list . COMMA expression

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 227
    COMMA           shift and go to state 228

  ! RPAREN          [ reduce using rule 116 (argument_list_opt -> argument_list .) ]


state 295

    (117) argument_list_opt -> empty .

    RPAREN          reduce using rule 117 (argument_list_opt -> empty .)


state 296

    (56) expression -> expression QUESTION expression COLON expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 56 (expression -> expression QUESTION expression COLON expression .)
    RPAREN          reduce using rule 56 (expression -> expression QUESTION expression COLON expression .)
    COLON           reduce using rule 56 (expression -> expression QUESTION expression COLON expression .)
    COMMA           reduce using rule 56 (expression -> expression QUESTION expression COLON expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]
  ! MINUS           [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]
  ! TIMES           [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]
  ! DIVIDE          [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]
  ! INT_DIVIDE      [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]
  ! MODULE          [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]
  ! DOT             [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]
  ! QUESTION        [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 56 (expression -> expression QUESTION expression COLON expression .) ]


state 297

    (189) print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    STDIN           reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    VOID            reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    LIST            reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    MAP             reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    STATIC          reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    RETURN          reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    CLASS           reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    BREAK           reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    LPAREN          reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    PLUS            reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    MINUS           reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    TRUE            reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    FALSE           reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    INT             reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    WHILE           reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    SET             reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    LBRACE          reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)
    RBRACE          reduce using rule 189 (print_stmt -> PRINT LPAREN value RPAREN SEMICOLON .)


state 298

    (190) print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STDIN           reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST            reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP             reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STATIC          reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CLASS           reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BREAK           reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LPAREN          reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    TRUE            reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FALSE           reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INT             reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOL            reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET             reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LBRACE          reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 190 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 299

    (58) expression -> LPAREN parameters RPAREN ARROW expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .)
    RPAREN          reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .)
    COLON           reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .)
    COMMA           reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! PLUS            [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! MINUS           [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! TIMES           [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DIVIDE          [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! INT_DIVIDE      [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! MODULE          [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DOT             [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! QUESTION        [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]


state 300

    (191) input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 374


state 301

    (176) object_instantiation -> VAR ID ASSIGN ID LPAREN . argument_list_opt RPAREN SEMICOLON
    (185) object_instantiation -> VAR ID ASSIGN ID LPAREN . RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 376
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

  ! RPAREN          [ reduce using rule 212 (empty -> .) ]

    argument_list_opt              shift and go to state 375
    argument_list                  shift and go to state 314
    empty                          shift and go to state 295
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 302

    (192) input_stmt -> VAR ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 377


state 303

    (121) lambda_function -> VAR ID ASSIGN LPAREN parameters . RPAREN ARROW expression SEMICOLON
    (58) expression -> LPAREN parameters . RPAREN ARROW expression
    (124) anonymous_function -> LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 378
    COMMA           shift and go to state 147


state 304

    (123) lambda_function -> VAR ID ASSIGN LPAREN RPAREN . ARROW expression SEMICOLON
    (59) expression -> LPAREN RPAREN . ARROW expression
    (125) anonymous_function -> LPAREN RPAREN . LBRACE statement_composed RBRACE

    ARROW           shift and go to state 379
    LBRACE          shift and go to state 380


state 305

    (30) variable_def -> VAR ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    STDIN           reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    INCREMENT       reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    DECREMENT       reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    CLASS           reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    PLUS            reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 30 (variable_def -> VAR ID ASSIGN expression SEMICOLON .)


state 306

    (126) variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .

    SEMICOLON       reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    PRINT           reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    STDIN           reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    VAR             reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    VOID            reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    LIST            reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    MAP             reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    DYNAMIC         reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    STATIC          reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    ID              reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    RETURN          reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    INCREMENT       reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    DECREMENT       reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    CLASS           reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    BREAK           reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    LPAREN          reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    PLUS            reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    MINUS           reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    TRUE            reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    FALSE           reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    NULL_LITERAL    reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    STRING          reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    INT             reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    DOUBLE          reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    BOOL            reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    IF              reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    WHILE           reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    FOR             reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    SET             reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    LBRACE          reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    $end            reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)
    RBRACE          reduce using rule 126 (variable_def -> VAR ID ASSIGN anonymous_function SEMICOLON .)


state 307

    (174) object_instantiation -> VAR ID ASSIGN NEW ID . LPAREN argument_list_opt RPAREN SEMICOLON
    (184) object_instantiation -> VAR ID ASSIGN NEW ID . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 381


state 308

    (179) object_instantiation -> ID ID ASSIGN ID LPAREN . argument_list_opt RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    RPAREN          reduce using rule 212 (empty -> .)
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    argument_list_opt              shift and go to state 382
    argument_list                  shift and go to state 314
    empty                          shift and go to state 295
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 309

    (178) object_instantiation -> ID ID ASSIGN NEW ID . LPAREN argument_list_opt RPAREN SEMICOLON

    LPAREN          shift and go to state 383


state 310

    (113) function_call -> ID LPAREN argument_list RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    PRINT           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    STDIN           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    VAR             reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    VOID            reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    LIST            reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    MAP             reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    STATIC          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    ID              reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    CLASS           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    BREAK           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    LPAREN          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    PLUS            reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    MINUS           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    TRUE            reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    FALSE           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    STRING          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    INT             reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    BOOL            reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    IF              reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    FOR             reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    SET             reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    LBRACE          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    $end            reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    TIMES           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    DIVIDE          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    INT_DIVIDE      reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    MODULE          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    DOT             reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    QUESTION        reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    DOUBLE_DOT      reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    RPAREN          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    COLON           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    COMMA           reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)
    RBRACE          reduce using rule 113 (function_call -> ID LPAREN argument_list RPAREN SEMICOLON .)


state 311

    (115) argument_list -> argument_list COMMA expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    RPAREN          reduce using rule 115 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 115 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 312

    (181) object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 384


state 313

    (183) object_instantiation -> ID ASSIGN ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 385


state 314

    (116) argument_list_opt -> argument_list .
    (115) argument_list -> argument_list . COMMA expression

    RPAREN          reduce using rule 116 (argument_list_opt -> argument_list .)
    COMMA           shift and go to state 228


state 315

    (180) object_instantiation -> ID ASSIGN NEW ID LPAREN . argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> ID ASSIGN NEW ID LPAREN . RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 387
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

  ! RPAREN          [ reduce using rule 212 (empty -> .) ]

    argument_list_opt              shift and go to state 386
    argument_list                  shift and go to state 314
    empty                          shift and go to state 295
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 316

    (177) object_instantiation -> type ID ASSIGN ID LPAREN . argument_list_opt RPAREN SEMICOLON
    (187) object_instantiation -> type ID ASSIGN ID LPAREN . RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 389
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

  ! RPAREN          [ reduce using rule 212 (empty -> .) ]

    argument_list_opt              shift and go to state 388
    argument_list                  shift and go to state 314
    empty                          shift and go to state 295
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 317

    (193) input_stmt -> type ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 390


state 318

    (120) lambda_function -> type ID ASSIGN LPAREN parameters . RPAREN ARROW expression SEMICOLON
    (58) expression -> LPAREN parameters . RPAREN ARROW expression
    (124) anonymous_function -> LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 391
    COMMA           shift and go to state 147


state 319

    (122) lambda_function -> type ID ASSIGN LPAREN RPAREN . ARROW expression SEMICOLON
    (59) expression -> LPAREN RPAREN . ARROW expression
    (125) anonymous_function -> LPAREN RPAREN . LBRACE statement_composed RBRACE

    ARROW           shift and go to state 392
    LBRACE          shift and go to state 380


state 320

    (28) variable_def -> type ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    STDIN           reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    INCREMENT       reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    DECREMENT       reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    CLASS           reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    PLUS            reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 28 (variable_def -> type ID ASSIGN expression SEMICOLON .)


state 321

    (127) variable_def -> type ID ASSIGN anonymous_function SEMICOLON .

    SEMICOLON       reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    PRINT           reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    STDIN           reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    VAR             reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    VOID            reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    LIST            reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    MAP             reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    DYNAMIC         reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    STATIC          reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    ID              reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    RETURN          reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    INCREMENT       reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    DECREMENT       reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    CLASS           reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    BREAK           reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    LPAREN          reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    PLUS            reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    MINUS           reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    TRUE            reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    FALSE           reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    NULL_LITERAL    reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    STRING          reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    INT             reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    DOUBLE          reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    BOOL            reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    IF              reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    WHILE           reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    FOR             reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    SET             reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    LBRACE          reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    $end            reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)
    RBRACE          reduce using rule 127 (variable_def -> type ID ASSIGN anonymous_function SEMICOLON .)


state 322

    (175) object_instantiation -> type ID ASSIGN NEW ID . LPAREN argument_list_opt RPAREN SEMICOLON
    (186) object_instantiation -> type ID ASSIGN NEW ID . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 393


state 323

    (96) function -> type ID LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 394


state 324

    (98) function -> type ID LPAREN RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement_composed             shift and go to state 395
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 325

    (107) optional_parameters -> LBRACE named_parameters . RBRACE
    (109) named_parameters -> named_parameters . COMMA named_parameter

    RBRACE          shift and go to state 396
    COMMA           shift and go to state 397


state 326

    (108) named_parameters -> named_parameter .

    RBRACE          reduce using rule 108 (named_parameters -> named_parameter .)
    COMMA           reduce using rule 108 (named_parameters -> named_parameter .)


state 327

    (110) named_parameter -> type . ID

    ID              shift and go to state 398


state 328

    (111) named_parameter -> REQUIRED . type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 399
    set_type                       shift and go to state 51

state 329

    (100) function -> type ID LPAREN optional_parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 400


state 330

    (106) optional_parameters -> LBRACKET parameters . RBRACKET
    (103) parameters -> parameters . COMMA parameter

    RBRACKET        shift and go to state 401
    COMMA           shift and go to state 147


state 331

    (68) else_block -> ELSE LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    ID              reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    INT             reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    IF              reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    SET             reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    $end            reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 68 (else_block -> ELSE LBRACE statement_composed RBRACE .)


state 332

    (97) function -> VOID ID LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 402


state 333

    (99) function -> VOID ID LPAREN RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 403
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 334

    (101) function -> VOID ID LPAREN optional_parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 404


state 335

    (128) list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    STDIN           reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    STATIC          reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    RETURN          reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    INCREMENT       reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    DECREMENT       reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    CLASS           reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    BREAK           reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    LPAREN          reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    PLUS            reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    MINUS           reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    TRUE            reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    FALSE           reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    NULL_LITERAL    reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    SET             reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    LBRACE          reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 128 (list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON .)


state 336

    (129) list_def -> LIST LESS type GREATER ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> LIST LESS type GREATER ID . SEMICOLON
    (131) list_def -> LIST LESS type GREATER ID . ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON

    ASSIGN          shift and go to state 405
    SEMICOLON       shift and go to state 406


state 337

    (136) map_def -> MAP LESS type COMMA type . GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> MAP LESS type COMMA type . GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON

    GREATER         shift and go to state 407


state 338

    (137) map_def -> MAP ID ASSIGN LBRACE map_entries . RBRACE SEMICOLON
    (140) map_entries -> map_entries . COMMA map_entry

    RBRACE          shift and go to state 408
    COMMA           shift and go to state 409


state 339

    (139) map_entries -> map_entry .

    RBRACE          reduce using rule 139 (map_entries -> map_entry .)
    COMMA           reduce using rule 139 (map_entries -> map_entry .)


state 340

    (141) map_entry -> value . COLON value

    COLON           shift and go to state 410


state 341

    (29) variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STDIN           reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INCREMENT       reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DECREMENT       reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    CLASS           reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PLUS            reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 29 (variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON .)


state 342

    (31) variable_def -> STATIC type ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 411
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 343

    (32) variable_def -> STATIC VAR ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 412
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 344

    (33) variable_def -> STATIC DYNAMIC ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 413
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 345

    (172) constructor -> ID LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> ID LPAREN . RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 415
    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    parameters                     shift and go to state 414
    parameter                      shift and go to state 75
    type                           shift and go to state 79
    set_type                       shift and go to state 51

state 346

    (146) class_def -> CLASS ID LBRACE class_body RBRACE .

    SEMICOLON       reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    PRINT           reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    STDIN           reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    VAR             reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    VOID            reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    LIST            reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    MAP             reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    DYNAMIC         reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    STATIC          reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    ID              reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    RETURN          reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    INCREMENT       reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    DECREMENT       reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    CLASS           reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    BREAK           reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    PLUS            reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    MINUS           reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    TRUE            reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    FALSE           reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    NULL_LITERAL    reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    STRING          reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    INT             reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    DOUBLE          reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    BOOL            reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    IF              reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    WHILE           reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    FOR             reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    SET             reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    LBRACE          reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    $end            reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 146 (class_def -> CLASS ID LBRACE class_body RBRACE .)


state 347

    (152) class_body -> class_body class_member .

    RBRACE          reduce using rule 152 (class_body -> class_body class_member .)
    VAR             reduce using rule 152 (class_body -> class_body class_member .)
    FINAL           reduce using rule 152 (class_body -> class_body class_member .)
    CONST           reduce using rule 152 (class_body -> class_body class_member .)
    STATIC          reduce using rule 152 (class_body -> class_body class_member .)
    VOID            reduce using rule 152 (class_body -> class_body class_member .)
    ID              reduce using rule 152 (class_body -> class_body class_member .)
    STRING          reduce using rule 152 (class_body -> class_body class_member .)
    INT             reduce using rule 152 (class_body -> class_body class_member .)
    DOUBLE          reduce using rule 152 (class_body -> class_body class_member .)
    BOOL            reduce using rule 152 (class_body -> class_body class_member .)
    SET             reduce using rule 152 (class_body -> class_body class_member .)


state 348

    (156) class_property -> type ID . SEMICOLON
    (161) class_property -> type ID . ASSIGN expression SEMICOLON
    (166) class_method -> type ID . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> type ID . LPAREN RPAREN LBRACE statement_composed RBRACE

    SEMICOLON       shift and go to state 416
    ASSIGN          shift and go to state 417
    LPAREN          shift and go to state 418


state 349

    (157) class_property -> VAR ID . SEMICOLON
    (162) class_property -> VAR ID . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 419
    ASSIGN          shift and go to state 420


state 350

    (158) class_property -> FINAL type . ID SEMICOLON
    (163) class_property -> FINAL type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 421


state 351

    (159) class_property -> CONST type . ID SEMICOLON
    (164) class_property -> CONST type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 422


state 352

    (160) class_property -> STATIC type . ID SEMICOLON
    (165) class_property -> STATIC type . ID ASSIGN expression SEMICOLON
    (170) class_method -> STATIC type . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE

    ID              shift and go to state 423


state 353

    (171) class_method -> STATIC VOID . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE

    ID              shift and go to state 424


state 354

    (167) class_method -> VOID ID . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> VOID ID . LPAREN RPAREN LBRACE statement_composed RBRACE

    LPAREN          shift and go to state 425


state 355

    (147) class_def -> CLASS ID EXTENDS ID LBRACE . class_body RBRACE
    (151) class_body -> . class_member
    (152) class_body -> . class_body class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_body                     shift and go to state 426
    class_member                   shift and go to state 260
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 356

    (149) class_def -> CLASS ID EXTENDS ID IMPLEMENTS . ID LBRACE class_body RBRACE

    ID              shift and go to state 427


state 357

    (150) class_def -> CLASS ID EXTENDS ID WITH . ID IMPLEMENTS ID LBRACE class_body RBRACE

    ID              shift and go to state 428


state 358

    (148) class_def -> CLASS ID IMPLEMENTS ID LBRACE . class_body RBRACE
    (151) class_body -> . class_member
    (152) class_body -> . class_body class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_body                     shift and go to state 429
    class_member                   shift and go to state 260
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 359

    (67) if_block -> IF LPAREN conditions RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 430
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 360

    (70) conditions -> conditions AND condition .

    RPAREN          reduce using rule 70 (conditions -> conditions AND condition .)
    AND             reduce using rule 70 (conditions -> conditions AND condition .)
    OR              reduce using rule 70 (conditions -> conditions AND condition .)
    SEMICOLON       reduce using rule 70 (conditions -> conditions AND condition .)


state 361

    (71) conditions -> conditions OR condition .

    RPAREN          reduce using rule 71 (conditions -> conditions OR condition .)
    AND             reduce using rule 71 (conditions -> conditions OR condition .)
    OR              reduce using rule 71 (conditions -> conditions OR condition .)
    SEMICOLON       reduce using rule 71 (conditions -> conditions OR condition .)


state 362

    (72) condition -> value comparison_operator value .

    RPAREN          reduce using rule 72 (condition -> value comparison_operator value .)
    AND             reduce using rule 72 (condition -> value comparison_operator value .)
    OR              reduce using rule 72 (condition -> value comparison_operator value .)
    SEMICOLON       reduce using rule 72 (condition -> value comparison_operator value .)


state 363

    (77) condition -> ID comparison_operator ID .
    (204) value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 77 (condition -> ID comparison_operator ID .)
  ! reduce/reduce conflict for AND resolved using rule 77 (condition -> ID comparison_operator ID .)
  ! reduce/reduce conflict for OR resolved using rule 77 (condition -> ID comparison_operator ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 77 (condition -> ID comparison_operator ID .)
    RPAREN          reduce using rule 77 (condition -> ID comparison_operator ID .)
    AND             reduce using rule 77 (condition -> ID comparison_operator ID .)
    OR              reduce using rule 77 (condition -> ID comparison_operator ID .)
    SEMICOLON       reduce using rule 77 (condition -> ID comparison_operator ID .)

  ! RPAREN          [ reduce using rule 204 (value -> ID .) ]
  ! AND             [ reduce using rule 204 (value -> ID .) ]
  ! OR              [ reduce using rule 204 (value -> ID .) ]
  ! SEMICOLON       [ reduce using rule 204 (value -> ID .) ]


state 364

    (76) condition -> ID comparison_operator value .

    RPAREN          reduce using rule 76 (condition -> ID comparison_operator value .)
    AND             reduce using rule 76 (condition -> ID comparison_operator value .)
    OR              reduce using rule 76 (condition -> ID comparison_operator value .)
    SEMICOLON       reduce using rule 76 (condition -> ID comparison_operator value .)


state 365

    (84) while_loop -> WHILE LPAREN conditions RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 431
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 366

    (85) for_loop -> FOR LPAREN for_init SEMICOLON conditions . SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (70) conditions -> conditions . AND condition
    (71) conditions -> conditions . OR condition

    SEMICOLON       shift and go to state 432
    AND             shift and go to state 273
    OR              shift and go to state 274


state 367

    (86) for_loop -> FOR LPAREN type ID IN . ID RPAREN LBRACE statement_composed RBRACE

    ID              shift and go to state 433


state 368

    (28) variable_def -> type ID ASSIGN . expression SEMICOLON
    (127) variable_def -> type ID ASSIGN . anonymous_function SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (124) anonymous_function -> . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (125) anonymous_function -> . LPAREN RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 434
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 234
    anonymous_function             shift and go to state 235
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 369

    (30) variable_def -> VAR ID ASSIGN . expression SEMICOLON
    (126) variable_def -> VAR ID ASSIGN . anonymous_function SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (124) anonymous_function -> . LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (125) anonymous_function -> . LPAREN RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 434
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 221
    anonymous_function             shift and go to state 222
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 370

    (31) variable_def -> STATIC type ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 252


state 371

    (32) variable_def -> STATIC VAR ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 254


state 372

    (33) variable_def -> STATIC DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 256


state 373

    (46) expression -> expression DOT ID LPAREN argument_list_opt RPAREN .

    SEMICOLON       reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    PLUS            reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    MINUS           reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    TIMES           reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    DIVIDE          reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    INT_DIVIDE      reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    MODULE          reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    DOT             reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    QUESTION        reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    DOUBLE_DOT      reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    RPAREN          reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    COLON           reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)
    COMMA           reduce using rule 46 (expression -> expression DOT ID LPAREN argument_list_opt RPAREN .)


state 374

    (191) input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 191 (input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 375

    (176) object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 435


state 376

    (185) object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 436


state 377

    (192) input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 437


state 378

    (121) lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN . ARROW expression SEMICOLON
    (58) expression -> LPAREN parameters RPAREN . ARROW expression
    (124) anonymous_function -> LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    ARROW           shift and go to state 438
    LBRACE          shift and go to state 439


state 379

    (123) lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW . expression SEMICOLON
    (59) expression -> LPAREN RPAREN ARROW . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 440
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 380

    (125) anonymous_function -> LPAREN RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 441
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 381

    (174) object_instantiation -> VAR ID ASSIGN NEW ID LPAREN . argument_list_opt RPAREN SEMICOLON
    (184) object_instantiation -> VAR ID ASSIGN NEW ID LPAREN . RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 443
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

  ! RPAREN          [ reduce using rule 212 (empty -> .) ]

    argument_list_opt              shift and go to state 442
    argument_list                  shift and go to state 314
    empty                          shift and go to state 295
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 382

    (179) object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 444


state 383

    (178) object_instantiation -> ID ID ASSIGN NEW ID LPAREN . argument_list_opt RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    RPAREN          reduce using rule 212 (empty -> .)
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    argument_list_opt              shift and go to state 445
    argument_list                  shift and go to state 314
    empty                          shift and go to state 295
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 384

    (181) object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 446


state 385

    (183) object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 183 (object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON .)


state 386

    (180) object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 447


state 387

    (182) object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 448


state 388

    (177) object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 449


state 389

    (187) object_instantiation -> type ID ASSIGN ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 450


state 390

    (193) input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 451


state 391

    (120) lambda_function -> type ID ASSIGN LPAREN parameters RPAREN . ARROW expression SEMICOLON
    (58) expression -> LPAREN parameters RPAREN . ARROW expression
    (124) anonymous_function -> LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    ARROW           shift and go to state 452
    LBRACE          shift and go to state 439


state 392

    (122) lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW . expression SEMICOLON
    (59) expression -> LPAREN RPAREN ARROW . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 453
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 393

    (175) object_instantiation -> type ID ASSIGN NEW ID LPAREN . argument_list_opt RPAREN SEMICOLON
    (186) object_instantiation -> type ID ASSIGN NEW ID LPAREN . RPAREN SEMICOLON
    (116) argument_list_opt -> . argument_list
    (117) argument_list_opt -> . empty
    (114) argument_list -> . expression
    (115) argument_list -> . argument_list COMMA expression
    (212) empty -> .
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 455
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

  ! RPAREN          [ reduce using rule 212 (empty -> .) ]

    argument_list_opt              shift and go to state 454
    argument_list                  shift and go to state 314
    empty                          shift and go to state 295
    expression                     shift and go to state 160
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 394

    (96) function -> type ID LPAREN parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement_composed             shift and go to state 456
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 395

    (98) function -> type ID LPAREN RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 457
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 396

    (107) optional_parameters -> LBRACE named_parameters RBRACE .

    RPAREN          reduce using rule 107 (optional_parameters -> LBRACE named_parameters RBRACE .)


state 397

    (109) named_parameters -> named_parameters COMMA . named_parameter
    (110) named_parameter -> . type ID
    (111) named_parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    REQUIRED        shift and go to state 328
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    named_parameter                shift and go to state 458
    type                           shift and go to state 327
    set_type                       shift and go to state 51

state 398

    (110) named_parameter -> type ID .

    RBRACE          reduce using rule 110 (named_parameter -> type ID .)
    COMMA           reduce using rule 110 (named_parameter -> type ID .)


state 399

    (111) named_parameter -> REQUIRED type . ID

    ID              shift and go to state 459


state 400

    (100) function -> type ID LPAREN optional_parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement_composed             shift and go to state 460
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 401

    (106) optional_parameters -> LBRACKET parameters RBRACKET .

    RPAREN          reduce using rule 106 (optional_parameters -> LBRACKET parameters RBRACKET .)


state 402

    (97) function -> VOID ID LPAREN parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 461
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 403

    (99) function -> VOID ID LPAREN RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 462
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 404

    (101) function -> VOID ID LPAREN optional_parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 463
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 405

    (129) list_def -> LIST LESS type GREATER ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (131) list_def -> LIST LESS type GREATER ID ASSIGN . LBRACKET list_of_lists RBRACKET SEMICOLON

    LBRACKET        shift and go to state 464


state 406

    (130) list_def -> LIST LESS type GREATER ID SEMICOLON .

    SEMICOLON       reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    PRINT           reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    STDIN           reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    VAR             reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    VOID            reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    LIST            reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    MAP             reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    DYNAMIC         reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    STATIC          reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    ID              reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    RETURN          reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    INCREMENT       reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    DECREMENT       reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    CLASS           reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    BREAK           reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    LPAREN          reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    PLUS            reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    MINUS           reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    TRUE            reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    FALSE           reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    NULL_LITERAL    reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    STRING          reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    INT             reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    DOUBLE          reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    BOOL            reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    IF              reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    WHILE           reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    FOR             reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    SET             reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    LBRACE          reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    $end            reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)
    RBRACE          reduce using rule 130 (list_def -> LIST LESS type GREATER ID SEMICOLON .)


state 407

    (136) map_def -> MAP LESS type COMMA type GREATER . ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> MAP LESS type COMMA type GREATER . ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON

    ID              shift and go to state 465


state 408

    (137) map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 466


state 409

    (140) map_entries -> map_entries COMMA . map_entry
    (141) map_entry -> . value COLON value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    map_entry                      shift and go to state 467
    value                          shift and go to state 340
    set_value                      shift and go to state 55

state 410

    (141) map_entry -> value COLON . value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value                          shift and go to state 468
    set_value                      shift and go to state 55

state 411

    (31) variable_def -> STATIC type ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    STDIN           reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    INCREMENT       reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    DECREMENT       reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    CLASS           reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    PLUS            reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 31 (variable_def -> STATIC type ID ASSIGN expression SEMICOLON .)


state 412

    (32) variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    STDIN           reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    INCREMENT       reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    DECREMENT       reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    CLASS           reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    PLUS            reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 32 (variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON .)


state 413

    (33) variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    STDIN           reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    INCREMENT       reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    DECREMENT       reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    CLASS           reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    PLUS            reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 33 (variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON .)


state 414

    (172) constructor -> ID LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 469
    COMMA           shift and go to state 147


state 415

    (173) constructor -> ID LPAREN RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 470


state 416

    (156) class_property -> type ID SEMICOLON .

    RBRACE          reduce using rule 156 (class_property -> type ID SEMICOLON .)
    VAR             reduce using rule 156 (class_property -> type ID SEMICOLON .)
    FINAL           reduce using rule 156 (class_property -> type ID SEMICOLON .)
    CONST           reduce using rule 156 (class_property -> type ID SEMICOLON .)
    STATIC          reduce using rule 156 (class_property -> type ID SEMICOLON .)
    VOID            reduce using rule 156 (class_property -> type ID SEMICOLON .)
    ID              reduce using rule 156 (class_property -> type ID SEMICOLON .)
    STRING          reduce using rule 156 (class_property -> type ID SEMICOLON .)
    INT             reduce using rule 156 (class_property -> type ID SEMICOLON .)
    DOUBLE          reduce using rule 156 (class_property -> type ID SEMICOLON .)
    BOOL            reduce using rule 156 (class_property -> type ID SEMICOLON .)
    SET             reduce using rule 156 (class_property -> type ID SEMICOLON .)


state 417

    (161) class_property -> type ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 471
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 418

    (166) class_method -> type ID LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> type ID LPAREN . RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 473
    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 79
    parameters                     shift and go to state 472
    parameter                      shift and go to state 75
    set_type                       shift and go to state 51

state 419

    (157) class_property -> VAR ID SEMICOLON .

    RBRACE          reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    VAR             reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    FINAL           reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    CONST           reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    STATIC          reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    VOID            reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    ID              reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    STRING          reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    INT             reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    DOUBLE          reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    BOOL            reduce using rule 157 (class_property -> VAR ID SEMICOLON .)
    SET             reduce using rule 157 (class_property -> VAR ID SEMICOLON .)


state 420

    (162) class_property -> VAR ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 474
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 421

    (158) class_property -> FINAL type ID . SEMICOLON
    (163) class_property -> FINAL type ID . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 475
    ASSIGN          shift and go to state 476


state 422

    (159) class_property -> CONST type ID . SEMICOLON
    (164) class_property -> CONST type ID . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 477
    ASSIGN          shift and go to state 478


state 423

    (160) class_property -> STATIC type ID . SEMICOLON
    (165) class_property -> STATIC type ID . ASSIGN expression SEMICOLON
    (170) class_method -> STATIC type ID . LPAREN parameters RPAREN LBRACE statement_composed RBRACE

    SEMICOLON       shift and go to state 479
    ASSIGN          shift and go to state 480
    LPAREN          shift and go to state 481


state 424

    (171) class_method -> STATIC VOID ID . LPAREN parameters RPAREN LBRACE statement_composed RBRACE

    LPAREN          shift and go to state 482


state 425

    (167) class_method -> VOID ID LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> VOID ID LPAREN . RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 484
    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    parameters                     shift and go to state 483
    parameter                      shift and go to state 75
    type                           shift and go to state 79
    set_type                       shift and go to state 51

state 426

    (147) class_def -> CLASS ID EXTENDS ID LBRACE class_body . RBRACE
    (152) class_body -> class_body . class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RBRACE          shift and go to state 485
    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_member                   shift and go to state 347
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 427

    (149) class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID . LBRACE class_body RBRACE

    LBRACE          shift and go to state 486


state 428

    (150) class_def -> CLASS ID EXTENDS ID WITH ID . IMPLEMENTS ID LBRACE class_body RBRACE

    IMPLEMENTS      shift and go to state 487


state 429

    (148) class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body . RBRACE
    (152) class_body -> class_body . class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RBRACE          shift and go to state 488
    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_member                   shift and go to state 347
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 430

    (67) if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 489
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 431

    (84) while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 490
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 432

    (85) for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON . for_update RPAREN LBRACE statement_composed RBRACE
    (89) for_update -> . incdec_statement
    (90) for_update -> . ID ASSIGN expression
    (91) for_update -> . empty
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (212) empty -> .

    ID              shift and go to state 493
    INCREMENT       shift and go to state 495
    DECREMENT       shift and go to state 496
    RPAREN          reduce using rule 212 (empty -> .)

    for_update                     shift and go to state 491
    incdec_statement               shift and go to state 492
    empty                          shift and go to state 494

state 433

    (86) for_loop -> FOR LPAREN type ID IN ID . RPAREN LBRACE statement_composed RBRACE

    RPAREN          shift and go to state 497


state 434

    (40) expression -> LPAREN . expression RPAREN
    (58) expression -> LPAREN . parameters RPAREN ARROW expression
    (59) expression -> LPAREN . RPAREN ARROW expression
    (124) anonymous_function -> LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (125) anonymous_function -> LPAREN . RPAREN LBRACE statement_composed RBRACE
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (145) set_value -> . LBRACE value_list RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RPAREN          shift and go to state 498
    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    REQUIRED        shift and go to state 80
    LBRACE          shift and go to state 31
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    expression                     shift and go to state 69
    parameters                     shift and go to state 499
    value                          shift and go to state 23
    parameter                      shift and go to state 75
    set_value                      shift and go to state 55
    type                           shift and go to state 79
    set_type                       shift and go to state 51

state 435

    (176) object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 500


state 436

    (185) object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 185 (object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON .)


state 437

    (192) input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 501


state 438

    (121) lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW . expression SEMICOLON
    (58) expression -> LPAREN parameters RPAREN ARROW . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 502
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 439

    (124) anonymous_function -> LPAREN parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 503
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 440

    (123) lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression . SEMICOLON
    (59) expression -> LPAREN RPAREN ARROW expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       shift and go to state 504
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! SEMICOLON       [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! PLUS            [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! MINUS           [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! TIMES           [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DIVIDE          [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! INT_DIVIDE      [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! MODULE          [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DOT             [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! QUESTION        [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]


state 441

    (125) anonymous_function -> LPAREN RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 505
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 442

    (174) object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 506


state 443

    (184) object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 507


state 444

    (179) object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 508


state 445

    (178) object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 509


state 446

    (181) object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STDIN           reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VAR             reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VOID            reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LIST            reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MAP             reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STATIC          reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    ID              reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    CLASS           reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STRING          reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INT             reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BOOL            reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    IF              reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    SET             reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    $end            reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 181 (object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)


state 447

    (180) object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 510


state 448

    (182) object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 182 (object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)


state 449

    (177) object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 511


state 450

    (187) object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 187 (object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON .)


state 451

    (193) input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 512


state 452

    (120) lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW . expression SEMICOLON
    (58) expression -> LPAREN parameters RPAREN ARROW . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 513
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 453

    (122) lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression . SEMICOLON
    (59) expression -> LPAREN RPAREN ARROW expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       shift and go to state 514
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! SEMICOLON       [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! PLUS            [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! MINUS           [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! TIMES           [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DIVIDE          [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! INT_DIVIDE      [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! MODULE          [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DOT             [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! QUESTION        [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 59 (expression -> LPAREN RPAREN ARROW expression .) ]


state 454

    (175) object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 515


state 455

    (186) object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 516


state 456

    (96) function -> type ID LPAREN parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 517
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 457

    (98) function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 98 (function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)


state 458

    (109) named_parameters -> named_parameters COMMA named_parameter .

    RBRACE          reduce using rule 109 (named_parameters -> named_parameters COMMA named_parameter .)
    COMMA           reduce using rule 109 (named_parameters -> named_parameters COMMA named_parameter .)


state 459

    (111) named_parameter -> REQUIRED type ID .

    RBRACE          reduce using rule 111 (named_parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 111 (named_parameter -> REQUIRED type ID .)


state 460

    (100) function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 518
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 461

    (97) function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 519
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 462

    (99) function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 99 (function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)


state 463

    (101) function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 520
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 464

    (129) list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (131) list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET . list_of_lists RBRACKET SEMICOLON
    (132) value_list -> . value
    (133) value_list -> . value_list COMMA value
    (134) list_of_lists -> . LBRACKET value_list RBRACKET
    (135) list_of_lists -> . list_of_lists COMMA LBRACKET value_list RBRACKET
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LBRACKET        shift and go to state 521
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value_list                     shift and go to state 522
    list_of_lists                  shift and go to state 523
    value                          shift and go to state 97
    set_value                      shift and go to state 55

state 465

    (136) map_def -> MAP LESS type COMMA type GREATER ID . ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> MAP LESS type COMMA type GREATER ID . ASSIGN LBRACE map_of_lists RBRACE SEMICOLON

    ASSIGN          shift and go to state 524


state 466

    (137) map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .

    SEMICOLON       reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    PRINT           reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    STDIN           reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    VAR             reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    VOID            reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    LIST            reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    MAP             reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    DYNAMIC         reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    STATIC          reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    ID              reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    RETURN          reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    INCREMENT       reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    DECREMENT       reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    CLASS           reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    BREAK           reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    LPAREN          reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    PLUS            reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    MINUS           reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    TRUE            reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    FALSE           reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    NULL_LITERAL    reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    STRING          reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    INT             reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    BOOL            reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    IF              reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    WHILE           reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    FOR             reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    SET             reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    LBRACE          reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    $end            reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    RBRACE          reduce using rule 137 (map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)


state 467

    (140) map_entries -> map_entries COMMA map_entry .

    RBRACE          reduce using rule 140 (map_entries -> map_entries COMMA map_entry .)
    COMMA           reduce using rule 140 (map_entries -> map_entries COMMA map_entry .)


state 468

    (141) map_entry -> value COLON value .

    RBRACE          reduce using rule 141 (map_entry -> value COLON value .)
    COMMA           reduce using rule 141 (map_entry -> value COLON value .)


state 469

    (172) constructor -> ID LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 525


state 470

    (173) constructor -> ID LPAREN RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 526
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 471

    (161) class_property -> type ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 527
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 472

    (166) class_method -> type ID LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 528
    COMMA           shift and go to state 147


state 473

    (168) class_method -> type ID LPAREN RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 529


state 474

    (162) class_property -> VAR ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 530
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 475

    (158) class_property -> FINAL type ID SEMICOLON .

    RBRACE          reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    VAR             reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    FINAL           reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    CONST           reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    STATIC          reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    VOID            reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    ID              reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    STRING          reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    INT             reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    DOUBLE          reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    BOOL            reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)
    SET             reduce using rule 158 (class_property -> FINAL type ID SEMICOLON .)


state 476

    (163) class_property -> FINAL type ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 531
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 477

    (159) class_property -> CONST type ID SEMICOLON .

    RBRACE          reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    VAR             reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    FINAL           reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    CONST           reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    STATIC          reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    VOID            reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    ID              reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    STRING          reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    INT             reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    DOUBLE          reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    BOOL            reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)
    SET             reduce using rule 159 (class_property -> CONST type ID SEMICOLON .)


state 478

    (164) class_property -> CONST type ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 532
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 479

    (160) class_property -> STATIC type ID SEMICOLON .

    RBRACE          reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    VAR             reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    FINAL           reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    CONST           reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    STATIC          reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    VOID            reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    ID              reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    STRING          reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    INT             reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    DOUBLE          reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    BOOL            reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)
    SET             reduce using rule 160 (class_property -> STATIC type ID SEMICOLON .)


state 480

    (165) class_property -> STATIC type ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 533
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 481

    (170) class_method -> STATIC type ID LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    type                           shift and go to state 79
    parameters                     shift and go to state 534
    parameter                      shift and go to state 75
    set_type                       shift and go to state 51

state 482

    (171) class_method -> STATIC VOID ID LPAREN . parameters RPAREN LBRACE statement_composed RBRACE
    (102) parameters -> . parameter
    (103) parameters -> . parameters COMMA parameter
    (104) parameter -> . type ID
    (105) parameter -> . REQUIRED type ID
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    REQUIRED        shift and go to state 80
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    parameters                     shift and go to state 535
    parameter                      shift and go to state 75
    type                           shift and go to state 79
    set_type                       shift and go to state 51

state 483

    (167) class_method -> VOID ID LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 536
    COMMA           shift and go to state 147


state 484

    (169) class_method -> VOID ID LPAREN RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 537


state 485

    (147) class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .

    SEMICOLON       reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    PRINT           reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    STDIN           reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    VAR             reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    VOID            reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    LIST            reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    MAP             reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    DYNAMIC         reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    STATIC          reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    ID              reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    RETURN          reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    INCREMENT       reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    DECREMENT       reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    CLASS           reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    BREAK           reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    PLUS            reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    MINUS           reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    TRUE            reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    FALSE           reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    NULL_LITERAL    reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    STRING          reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    INT             reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    DOUBLE          reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    BOOL            reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    IF              reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    WHILE           reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    FOR             reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    SET             reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    LBRACE          reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    $end            reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 147 (class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE .)


state 486

    (149) class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE . class_body RBRACE
    (151) class_body -> . class_member
    (152) class_body -> . class_body class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_body                     shift and go to state 538
    class_member                   shift and go to state 260
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 487

    (150) class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS . ID LBRACE class_body RBRACE

    ID              shift and go to state 539


state 488

    (148) class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .

    SEMICOLON       reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    PRINT           reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STDIN           reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    VAR             reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    VOID            reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LIST            reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    MAP             reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DYNAMIC         reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STATIC          reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    ID              reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    RETURN          reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    INCREMENT       reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DECREMENT       reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    CLASS           reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    BREAK           reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    PLUS            reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    MINUS           reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    TRUE            reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    FALSE           reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    NULL_LITERAL    reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STRING          reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    INT             reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DOUBLE          reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    BOOL            reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    IF              reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    WHILE           reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    FOR             reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    SET             reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LBRACE          reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    $end            reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 148 (class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE .)


state 489

    (67) if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .

    ELSE            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    SEMICOLON       reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)


state 490

    (84) while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 84 (while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE .)


state 491

    (85) for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update . RPAREN LBRACE statement_composed RBRACE

    RPAREN          shift and go to state 540


state 492

    (89) for_update -> incdec_statement .

    RPAREN          reduce using rule 89 (for_update -> incdec_statement .)


state 493

    (90) for_update -> ID . ASSIGN expression
    (208) incdec_statement -> ID . INCREMENT SEMICOLON
    (209) incdec_statement -> ID . DECREMENT SEMICOLON

    ASSIGN          shift and go to state 541
    INCREMENT       shift and go to state 542
    DECREMENT       shift and go to state 543


state 494

    (91) for_update -> empty .

    RPAREN          reduce using rule 91 (for_update -> empty .)


state 495

    (210) incdec_statement -> INCREMENT . ID SEMICOLON

    ID              shift and go to state 544


state 496

    (211) incdec_statement -> DECREMENT . ID SEMICOLON

    ID              shift and go to state 545


state 497

    (86) for_loop -> FOR LPAREN type ID IN ID RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 546


state 498

    (59) expression -> LPAREN RPAREN . ARROW expression
    (125) anonymous_function -> LPAREN RPAREN . LBRACE statement_composed RBRACE

    ARROW           shift and go to state 145
    LBRACE          shift and go to state 380


state 499

    (58) expression -> LPAREN parameters . RPAREN ARROW expression
    (124) anonymous_function -> LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 547
    COMMA           shift and go to state 147


state 500

    (176) object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STDIN           reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VAR             reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VOID            reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LIST            reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MAP             reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STATIC          reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    ID              reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    CLASS           reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STRING          reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INT             reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BOOL            reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    IF              reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    SET             reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    $end            reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 176 (object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)


state 501

    (192) input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 548


state 502

    (121) lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression . SEMICOLON
    (58) expression -> LPAREN parameters RPAREN ARROW expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       shift and go to state 549
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! SEMICOLON       [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! PLUS            [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! MINUS           [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! TIMES           [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DIVIDE          [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! INT_DIVIDE      [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! MODULE          [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DOT             [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! QUESTION        [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]


state 503

    (124) anonymous_function -> LPAREN parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 550
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 504

    (123) lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .

    SEMICOLON       reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    PRINT           reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    STDIN           reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    VAR             reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    VOID            reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    LIST            reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    MAP             reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    DYNAMIC         reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    STATIC          reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    ID              reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    RETURN          reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    INCREMENT       reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    DECREMENT       reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    CLASS           reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    BREAK           reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    LPAREN          reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    PLUS            reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    MINUS           reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    TRUE            reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    FALSE           reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    STRING          reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    INT             reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    DOUBLE          reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    BOOL            reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    IF              reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    WHILE           reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    FOR             reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    SET             reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    LBRACE          reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    $end            reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    RBRACE          reduce using rule 123 (lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)


state 505

    (125) anonymous_function -> LPAREN RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 125 (anonymous_function -> LPAREN RPAREN LBRACE statement_composed RBRACE .)


state 506

    (174) object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 551


state 507

    (184) object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 184 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)


state 508

    (179) object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STDIN           reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VAR             reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VOID            reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LIST            reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MAP             reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STATIC          reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    ID              reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    CLASS           reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STRING          reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INT             reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BOOL            reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    IF              reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    SET             reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    $end            reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 179 (object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)


state 509

    (178) object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 552


state 510

    (180) object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STDIN           reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VAR             reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VOID            reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LIST            reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MAP             reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STATIC          reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    ID              reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    CLASS           reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STRING          reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INT             reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BOOL            reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    IF              reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    SET             reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    $end            reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 180 (object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)


state 511

    (177) object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STDIN           reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VAR             reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VOID            reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LIST            reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MAP             reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STATIC          reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    ID              reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    CLASS           reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STRING          reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INT             reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BOOL            reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    IF              reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    SET             reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    $end            reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 177 (object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON .)


state 512

    (193) input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 553


state 513

    (120) lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression . SEMICOLON
    (58) expression -> LPAREN parameters RPAREN ARROW expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
  ! shift/reduce conflict for DOUBLE_DOT resolved as shift
    SEMICOLON       shift and go to state 554
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67

  ! SEMICOLON       [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! PLUS            [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! MINUS           [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! TIMES           [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DIVIDE          [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! INT_DIVIDE      [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! MODULE          [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DOT             [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! QUESTION        [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]
  ! DOUBLE_DOT      [ reduce using rule 58 (expression -> LPAREN parameters RPAREN ARROW expression .) ]


state 514

    (122) lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .

    SEMICOLON       reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    PRINT           reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    STDIN           reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    VAR             reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    VOID            reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    LIST            reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    MAP             reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    DYNAMIC         reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    STATIC          reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    ID              reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    RETURN          reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    INCREMENT       reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    DECREMENT       reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    CLASS           reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    BREAK           reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    LPAREN          reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    PLUS            reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    MINUS           reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    TRUE            reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    FALSE           reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    STRING          reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    INT             reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    DOUBLE          reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    BOOL            reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    IF              reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    WHILE           reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    FOR             reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    SET             reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    LBRACE          reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    $end            reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)
    RBRACE          reduce using rule 122 (lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON .)


state 515

    (175) object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 555


state 516

    (186) object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 186 (object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON .)


state 517

    (96) function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 96 (function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)


state 518

    (100) function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 100 (function -> type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)


state 519

    (97) function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 97 (function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)


state 520

    (101) function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 101 (function -> VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE .)


state 521

    (134) list_of_lists -> LBRACKET . value_list RBRACKET
    (132) value_list -> . value
    (133) value_list -> . value_list COMMA value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value_list                     shift and go to state 556
    value                          shift and go to state 97
    set_value                      shift and go to state 55

state 522

    (129) list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON
    (133) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 557
    COMMA           shift and go to state 175


state 523

    (131) list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists . RBRACKET SEMICOLON
    (135) list_of_lists -> list_of_lists . COMMA LBRACKET value_list RBRACKET

    RBRACKET        shift and go to state 558
    COMMA           shift and go to state 559


state 524

    (136) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN . LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN . LBRACE map_of_lists RBRACE SEMICOLON

    LBRACE          shift and go to state 560


state 525

    (172) constructor -> ID LPAREN parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 561
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 526

    (173) constructor -> ID LPAREN RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 562
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 527

    (161) class_property -> type ID ASSIGN expression SEMICOLON .

    RBRACE          reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 161 (class_property -> type ID ASSIGN expression SEMICOLON .)


state 528

    (166) class_method -> type ID LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 563


state 529

    (168) class_method -> type ID LPAREN RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement_composed             shift and go to state 564
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 530

    (162) class_property -> VAR ID ASSIGN expression SEMICOLON .

    RBRACE          reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 162 (class_property -> VAR ID ASSIGN expression SEMICOLON .)


state 531

    (163) class_property -> FINAL type ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 565
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 532

    (164) class_property -> CONST type ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 566
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 533

    (165) class_property -> STATIC type ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    SEMICOLON       shift and go to state 567
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 534

    (170) class_method -> STATIC type ID LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 568
    COMMA           shift and go to state 147


state 535

    (171) class_method -> STATIC VOID ID LPAREN parameters . RPAREN LBRACE statement_composed RBRACE
    (103) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 569
    COMMA           shift and go to state 147


state 536

    (167) class_method -> VOID ID LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 570


state 537

    (169) class_method -> VOID ID LPAREN RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 571
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 538

    (149) class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body . RBRACE
    (152) class_body -> class_body . class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RBRACE          shift and go to state 572
    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_member                   shift and go to state 347
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 539

    (150) class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID . LBRACE class_body RBRACE

    LBRACE          shift and go to state 573


state 540

    (85) for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 574


state 541

    (90) for_update -> ID ASSIGN . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LPAREN          shift and go to state 22
    ID              shift and go to state 72
    INCREMENT       shift and go to state 73
    DECREMENT       shift and go to state 74
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    LBRACE          shift and go to state 31

    expression                     shift and go to state 575
    value                          shift and go to state 23
    set_value                      shift and go to state 55

state 542

    (208) incdec_statement -> ID INCREMENT . SEMICOLON

    SEMICOLON       shift and go to state 161


state 543

    (209) incdec_statement -> ID DECREMENT . SEMICOLON

    SEMICOLON       shift and go to state 162


state 544

    (210) incdec_statement -> INCREMENT ID . SEMICOLON

    SEMICOLON       shift and go to state 187


state 545

    (211) incdec_statement -> DECREMENT ID . SEMICOLON

    SEMICOLON       shift and go to state 188


state 546

    (86) for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement_composed             shift and go to state 576
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 547

    (58) expression -> LPAREN parameters RPAREN . ARROW expression
    (124) anonymous_function -> LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    ARROW           shift and go to state 214
    LBRACE          shift and go to state 439


state 548

    (192) input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 192 (input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 549

    (121) lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .

    SEMICOLON       reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    PRINT           reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    STDIN           reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    VAR             reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    VOID            reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    LIST            reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    MAP             reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    DYNAMIC         reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    STATIC          reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    ID              reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    RETURN          reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    INCREMENT       reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    DECREMENT       reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    CLASS           reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    BREAK           reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    LPAREN          reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    PLUS            reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    MINUS           reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    TRUE            reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    FALSE           reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    STRING          reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    INT             reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    DOUBLE          reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    BOOL            reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    IF              reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    WHILE           reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    FOR             reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    SET             reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    LBRACE          reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    $end            reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    RBRACE          reduce using rule 121 (lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)


state 550

    (124) anonymous_function -> LPAREN parameters RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 124 (anonymous_function -> LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)


state 551

    (174) object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STDIN           reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VAR             reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VOID            reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LIST            reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MAP             reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STATIC          reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    ID              reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    CLASS           reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STRING          reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INT             reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BOOL            reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    IF              reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    SET             reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    $end            reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 174 (object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)


state 552

    (178) object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STDIN           reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VAR             reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VOID            reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LIST            reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MAP             reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STATIC          reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    ID              reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    CLASS           reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STRING          reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INT             reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BOOL            reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    IF              reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    SET             reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    $end            reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 178 (object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)


state 553

    (193) input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STDIN           reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STATIC          reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    CLASS           reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SET             reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 193 (input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 554

    (120) lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .

    SEMICOLON       reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    PRINT           reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    STDIN           reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    VAR             reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    VOID            reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    LIST            reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    MAP             reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    DYNAMIC         reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    STATIC          reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    ID              reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    RETURN          reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    INCREMENT       reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    DECREMENT       reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    CLASS           reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    BREAK           reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    LPAREN          reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    PLUS            reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    MINUS           reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    TRUE            reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    FALSE           reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    NULL_LITERAL    reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    STRING          reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    INT             reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    DOUBLE          reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    BOOL            reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    IF              reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    WHILE           reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    FOR             reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    SET             reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    LBRACE          reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    $end            reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)
    RBRACE          reduce using rule 120 (lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON .)


state 555

    (175) object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STDIN           reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VAR             reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    VOID            reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LIST            reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MAP             reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STATIC          reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    ID              reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    CLASS           reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    NULL_LITERAL    reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    STRING          reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    INT             reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    BOOL            reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    IF              reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    SET             reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    $end            reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 175 (object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON .)


state 556

    (134) list_of_lists -> LBRACKET value_list . RBRACKET
    (133) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 577
    COMMA           shift and go to state 175


state 557

    (129) list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 578


state 558

    (131) list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 579


state 559

    (135) list_of_lists -> list_of_lists COMMA . LBRACKET value_list RBRACKET

    LBRACKET        shift and go to state 580


state 560

    (136) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE . map_entries RBRACE SEMICOLON
    (138) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE . map_of_lists RBRACE SEMICOLON
    (139) map_entries -> . map_entry
    (140) map_entries -> . map_entries COMMA map_entry
    (142) map_of_lists -> . map_list_entry
    (143) map_of_lists -> . map_of_lists COMMA map_list_entry
    (141) map_entry -> . value COLON value
    (144) map_list_entry -> . value COLON LBRACKET value_list RBRACKET
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    map_entries                    shift and go to state 581
    map_of_lists                   shift and go to state 582
    map_entry                      shift and go to state 339
    map_list_entry                 shift and go to state 583
    value                          shift and go to state 584
    set_value                      shift and go to state 55

state 561

    (172) constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 585
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 562

    (173) constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .

    RBRACE          reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    FINAL           reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    CONST           reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 173 (constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE .)


state 563

    (166) class_method -> type ID LPAREN parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement_composed             shift and go to state 586
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 564

    (168) class_method -> type ID LPAREN RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 587
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 565

    (163) class_property -> FINAL type ID ASSIGN expression SEMICOLON .

    RBRACE          reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 163 (class_property -> FINAL type ID ASSIGN expression SEMICOLON .)


state 566

    (164) class_property -> CONST type ID ASSIGN expression SEMICOLON .

    RBRACE          reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 164 (class_property -> CONST type ID ASSIGN expression SEMICOLON .)


state 567

    (165) class_property -> STATIC type ID ASSIGN expression SEMICOLON .

    RBRACE          reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    STATIC          reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)
    SET             reduce using rule 165 (class_property -> STATIC type ID ASSIGN expression SEMICOLON .)


state 568

    (170) class_method -> STATIC type ID LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 588


state 569

    (171) class_method -> STATIC VOID ID LPAREN parameters RPAREN . LBRACE statement_composed RBRACE

    LBRACE          shift and go to state 589


state 570

    (167) class_method -> VOID ID LPAREN parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 590
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 571

    (169) class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 591
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 572

    (149) class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .

    SEMICOLON       reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    PRINT           reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STDIN           reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    VAR             reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    VOID            reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LIST            reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    MAP             reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DYNAMIC         reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STATIC          reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    ID              reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    RETURN          reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    INCREMENT       reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DECREMENT       reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    CLASS           reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    BREAK           reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    PLUS            reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    MINUS           reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    TRUE            reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    FALSE           reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    NULL_LITERAL    reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STRING          reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    INT             reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DOUBLE          reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    BOOL            reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    IF              reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    WHILE           reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    FOR             reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    SET             reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LBRACE          reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    $end            reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 149 (class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE .)


state 573

    (150) class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE . class_body RBRACE
    (151) class_body -> . class_member
    (152) class_body -> . class_body class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_body                     shift and go to state 592
    class_member                   shift and go to state 260
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 574

    (85) for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 593
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 575

    (90) for_update -> ID ASSIGN expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . INT_DIVIDE expression
    (39) expression -> expression . MODULE expression
    (44) expression -> expression . DOT ID
    (45) expression -> expression . DOT function_call
    (46) expression -> expression . DOT ID LPAREN argument_list_opt RPAREN
    (56) expression -> expression . QUESTION expression COLON expression
    (57) expression -> expression . DOUBLE_DOT expression

    RPAREN          reduce using rule 90 (for_update -> ID ASSIGN expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    INT_DIVIDE      shift and go to state 63
    MODULE          shift and go to state 64
    DOT             shift and go to state 65
    QUESTION        shift and go to state 66
    DOUBLE_DOT      shift and go to state 67


state 576

    (86) for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 594
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 577

    (134) list_of_lists -> LBRACKET value_list RBRACKET .

    RBRACKET        reduce using rule 134 (list_of_lists -> LBRACKET value_list RBRACKET .)
    COMMA           reduce using rule 134 (list_of_lists -> LBRACKET value_list RBRACKET .)


state 578

    (129) list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STDIN           reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STATIC          reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RETURN          reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INCREMENT       reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DECREMENT       reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    CLASS           reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BREAK           reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LPAREN          reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PLUS            reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MINUS           reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    TRUE            reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FALSE           reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    NULL_LITERAL    reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    SET             reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LBRACE          reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 129 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 579

    (131) list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    PRINT           reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    STDIN           reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    VAR             reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    VOID            reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    LIST            reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    MAP             reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    STATIC          reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    ID              reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    RETURN          reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    INCREMENT       reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    DECREMENT       reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    CLASS           reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    BREAK           reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    LPAREN          reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    PLUS            reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    MINUS           reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    TRUE            reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    FALSE           reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    NULL_LITERAL    reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    STRING          reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    INT             reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    BOOL            reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    IF              reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    WHILE           reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    FOR             reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    SET             reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    LBRACE          reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    $end            reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 131 (list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON .)


state 580

    (135) list_of_lists -> list_of_lists COMMA LBRACKET . value_list RBRACKET
    (132) value_list -> . value
    (133) value_list -> . value_list COMMA value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value_list                     shift and go to state 595
    value                          shift and go to state 97
    set_value                      shift and go to state 55

state 581

    (136) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries . RBRACE SEMICOLON
    (140) map_entries -> map_entries . COMMA map_entry

    RBRACE          shift and go to state 596
    COMMA           shift and go to state 409


state 582

    (138) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists . RBRACE SEMICOLON
    (143) map_of_lists -> map_of_lists . COMMA map_list_entry

    RBRACE          shift and go to state 598
    COMMA           shift and go to state 597


state 583

    (142) map_of_lists -> map_list_entry .

    RBRACE          reduce using rule 142 (map_of_lists -> map_list_entry .)
    COMMA           reduce using rule 142 (map_of_lists -> map_list_entry .)


state 584

    (141) map_entry -> value . COLON value
    (144) map_list_entry -> value . COLON LBRACKET value_list RBRACKET

    COLON           shift and go to state 599


state 585

    (172) constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .

    RBRACE          reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FINAL           reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    CONST           reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 172 (constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)


state 586

    (166) class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 600
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 587

    (168) class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .

    RBRACE          reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    FINAL           reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    CONST           reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 168 (class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE .)


state 588

    (170) class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement_composed             shift and go to state 601
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 589

    (171) class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE . statement_composed RBRACE
    (2) statement_composed -> . statement
    (3) statement_composed -> . statement_composed statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    SEMICOLON       shift and go to state 13
    RBRACE          reduce using rule 21 (statement -> .)
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement_composed             shift and go to state 602
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 590

    (167) class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 603
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 591

    (169) class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .

    RBRACE          reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    FINAL           reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    CONST           reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 169 (class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE .)


state 592

    (150) class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body . RBRACE
    (152) class_body -> class_body . class_member
    (153) class_member -> . class_property
    (154) class_member -> . class_method
    (155) class_member -> . constructor
    (156) class_property -> . type ID SEMICOLON
    (157) class_property -> . VAR ID SEMICOLON
    (158) class_property -> . FINAL type ID SEMICOLON
    (159) class_property -> . CONST type ID SEMICOLON
    (160) class_property -> . STATIC type ID SEMICOLON
    (161) class_property -> . type ID ASSIGN expression SEMICOLON
    (162) class_property -> . VAR ID ASSIGN expression SEMICOLON
    (163) class_property -> . FINAL type ID ASSIGN expression SEMICOLON
    (164) class_property -> . CONST type ID ASSIGN expression SEMICOLON
    (165) class_property -> . STATIC type ID ASSIGN expression SEMICOLON
    (166) class_method -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (167) class_method -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (168) class_method -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (169) class_method -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (170) class_method -> . STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (171) class_method -> . STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (172) constructor -> . ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (173) constructor -> . ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER

    RBRACE          shift and go to state 604
    VAR             shift and go to state 265
    FINAL           shift and go to state 266
    CONST           shift and go to state 267
    STATIC          shift and go to state 268
    VOID            shift and go to state 269
    ID              shift and go to state 258
    STRING          shift and go to state 113
    INT             shift and go to state 114
    DOUBLE          shift and go to state 115
    BOOL            shift and go to state 50
    SET             shift and go to state 56

    class_member                   shift and go to state 347
    class_property                 shift and go to state 261
    class_method                   shift and go to state 262
    constructor                    shift and go to state 263
    type                           shift and go to state 264
    set_type                       shift and go to state 51

state 593

    (85) for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 605
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 594

    (86) for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 86 (for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE .)


state 595

    (135) list_of_lists -> list_of_lists COMMA LBRACKET value_list . RBRACKET
    (133) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 606
    COMMA           shift and go to state 175


state 596

    (136) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 607


state 597

    (143) map_of_lists -> map_of_lists COMMA . map_list_entry
    (144) map_list_entry -> . value COLON LBRACKET value_list RBRACKET
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    map_list_entry                 shift and go to state 608
    value                          shift and go to state 609
    set_value                      shift and go to state 55

state 598

    (138) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 610


state 599

    (141) map_entry -> value COLON . value
    (144) map_list_entry -> value COLON . LBRACKET value_list RBRACKET
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    LBRACKET        shift and go to state 611
    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value                          shift and go to state 468
    set_value                      shift and go to state 55

state 600

    (166) class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .

    RBRACE          reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FINAL           reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    CONST           reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 166 (class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)


state 601

    (170) class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 612
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    type                           shift and go to state 27
    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 602

    (171) class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed . RBRACE
    (3) statement_composed -> statement_composed . statement
    (4) statement -> . print_stmt
    (5) statement -> . input_stmt
    (6) statement -> . control_structures
    (7) statement -> . function
    (8) statement -> . lambda_function
    (9) statement -> . list_def
    (10) statement -> . map_def
    (11) statement -> . variable_def
    (12) statement -> . variable_only_def
    (13) statement -> . SEMICOLON
    (14) statement -> . function_call
    (15) statement -> . return_statement
    (16) statement -> . incdec_statement
    (17) statement -> . class_def
    (18) statement -> . object_instantiation
    (19) statement -> . break_stmt
    (20) statement -> . expression SEMICOLON
    (21) statement -> .
    (188) print_stmt -> . PRINT LPAREN RPAREN SEMICOLON
    (189) print_stmt -> . PRINT LPAREN value RPAREN SEMICOLON
    (190) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (191) input_stmt -> . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (192) input_stmt -> . VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (193) input_stmt -> . type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (63) control_structures -> . if_block
    (64) control_structures -> . if_block else_block
    (65) control_structures -> . while_loop
    (66) control_structures -> . for_loop
    (96) function -> . type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (97) function -> . VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
    (98) function -> . type ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (99) function -> . VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
    (100) function -> . type ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (101) function -> . VOID ID LPAREN optional_parameters RPAREN LBRACE statement_composed RBRACE
    (120) lambda_function -> . type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (121) lambda_function -> . VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
    (122) lambda_function -> . type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (123) lambda_function -> . VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
    (128) list_def -> . LIST LBRACKET value_list RBRACKET SEMICOLON
    (129) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (130) list_def -> . LIST LESS type GREATER ID SEMICOLON
    (131) list_def -> . LIST LESS type GREATER ID ASSIGN LBRACKET list_of_lists RBRACKET SEMICOLON
    (136) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (137) map_def -> . MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
    (138) map_def -> . MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON
    (28) variable_def -> . type ID ASSIGN expression SEMICOLON
    (29) variable_def -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (30) variable_def -> . VAR ID ASSIGN expression SEMICOLON
    (31) variable_def -> . STATIC type ID ASSIGN expression SEMICOLON
    (32) variable_def -> . STATIC VAR ID ASSIGN expression SEMICOLON
    (33) variable_def -> . STATIC DYNAMIC ID ASSIGN expression SEMICOLON
    (126) variable_def -> . VAR ID ASSIGN anonymous_function SEMICOLON
    (127) variable_def -> . type ID ASSIGN anonymous_function SEMICOLON
    (22) variable_only_def -> . type ID SEMICOLON
    (23) variable_only_def -> . DYNAMIC ID SEMICOLON
    (24) variable_only_def -> . VAR ID SEMICOLON
    (25) variable_only_def -> . STATIC type ID SEMICOLON
    (26) variable_only_def -> . STATIC VAR ID SEMICOLON
    (27) variable_only_def -> . STATIC DYNAMIC ID SEMICOLON
    (112) function_call -> . ID LPAREN RPAREN SEMICOLON
    (113) function_call -> . ID LPAREN argument_list RPAREN SEMICOLON
    (118) return_statement -> . RETURN expression SEMICOLON
    (119) return_statement -> . RETURN SEMICOLON
    (208) incdec_statement -> . ID INCREMENT SEMICOLON
    (209) incdec_statement -> . ID DECREMENT SEMICOLON
    (210) incdec_statement -> . INCREMENT ID SEMICOLON
    (211) incdec_statement -> . DECREMENT ID SEMICOLON
    (146) class_def -> . CLASS ID LBRACE class_body RBRACE
    (147) class_def -> . CLASS ID EXTENDS ID LBRACE class_body RBRACE
    (148) class_def -> . CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (149) class_def -> . CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
    (150) class_def -> . CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE
    (174) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (175) object_instantiation -> . type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (176) object_instantiation -> . VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (177) object_instantiation -> . type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (178) object_instantiation -> . ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (179) object_instantiation -> . ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (180) object_instantiation -> . ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
    (181) object_instantiation -> . ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
    (182) object_instantiation -> . ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (183) object_instantiation -> . ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (184) object_instantiation -> . VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (185) object_instantiation -> . VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (186) object_instantiation -> . type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
    (187) object_instantiation -> . type ID ASSIGN ID LPAREN RPAREN SEMICOLON
    (92) break_stmt -> . BREAK SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression INT_DIVIDE expression
    (39) expression -> . expression MODULE expression
    (40) expression -> . LPAREN expression RPAREN
    (41) expression -> . value
    (42) expression -> . ID INCREMENT
    (43) expression -> . ID DECREMENT
    (44) expression -> . expression DOT ID
    (45) expression -> . expression DOT function_call
    (46) expression -> . expression DOT ID LPAREN argument_list_opt RPAREN
    (47) expression -> . ID PLUS_EQUAL expression
    (48) expression -> . ID MINUS_EQUAL expression
    (49) expression -> . ID TIMES_EQUAL expression
    (50) expression -> . ID DIVIDE_EQUAL expression
    (51) expression -> . ID MODULE_EQUAL expression
    (52) expression -> . INCREMENT ID
    (53) expression -> . DECREMENT ID
    (54) expression -> . PLUS ID
    (55) expression -> . MINUS ID
    (56) expression -> . expression QUESTION expression COLON expression
    (57) expression -> . expression DOUBLE_DOT expression
    (58) expression -> . LPAREN parameters RPAREN ARROW expression
    (59) expression -> . LPAREN RPAREN ARROW expression
    (60) expression -> . TRUE
    (61) expression -> . FALSE
    (62) expression -> . NULL_LITERAL
    (194) type -> . STRING
    (195) type -> . INT
    (196) type -> . DOUBLE
    (197) type -> . BOOL
    (198) type -> . set_type
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (84) while_loop -> . WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
    (85) for_loop -> . FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
    (86) for_loop -> . FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (199) set_type -> . SET
    (200) set_type -> . SET LESS type GREATER
    (145) set_value -> . LBRACE value_list RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for STDIN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for DYNAMIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NULL_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RBRACE          shift and go to state 613
    SEMICOLON       shift and go to state 13
    PRINT           shift and go to state 21
    STDIN           shift and go to state 24
    VAR             shift and go to state 25
    VOID            shift and go to state 32
    LIST            shift and go to state 33
    MAP             shift and go to state 34
    DYNAMIC         shift and go to state 35
    STATIC          shift and go to state 36
    ID              shift and go to state 26
    RETURN          shift and go to state 37
    INCREMENT       shift and go to state 38
    DECREMENT       shift and go to state 39
    CLASS           shift and go to state 40
    BREAK           shift and go to state 41
    LPAREN          shift and go to state 22
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    NULL_LITERAL    shift and go to state 46
    STRING          shift and go to state 47
    INT             shift and go to state 48
    DOUBLE          shift and go to state 49
    BOOL            shift and go to state 50
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SET             shift and go to state 56
    LBRACE          shift and go to state 31

  ! RBRACE          [ reduce using rule 21 (statement -> .) ]
  ! SEMICOLON       [ reduce using rule 21 (statement -> .) ]
  ! PRINT           [ reduce using rule 21 (statement -> .) ]
  ! STDIN           [ reduce using rule 21 (statement -> .) ]
  ! VAR             [ reduce using rule 21 (statement -> .) ]
  ! VOID            [ reduce using rule 21 (statement -> .) ]
  ! LIST            [ reduce using rule 21 (statement -> .) ]
  ! MAP             [ reduce using rule 21 (statement -> .) ]
  ! DYNAMIC         [ reduce using rule 21 (statement -> .) ]
  ! STATIC          [ reduce using rule 21 (statement -> .) ]
  ! ID              [ reduce using rule 21 (statement -> .) ]
  ! RETURN          [ reduce using rule 21 (statement -> .) ]
  ! INCREMENT       [ reduce using rule 21 (statement -> .) ]
  ! DECREMENT       [ reduce using rule 21 (statement -> .) ]
  ! CLASS           [ reduce using rule 21 (statement -> .) ]
  ! BREAK           [ reduce using rule 21 (statement -> .) ]
  ! LPAREN          [ reduce using rule 21 (statement -> .) ]
  ! PLUS            [ reduce using rule 21 (statement -> .) ]
  ! MINUS           [ reduce using rule 21 (statement -> .) ]
  ! TRUE            [ reduce using rule 21 (statement -> .) ]
  ! FALSE           [ reduce using rule 21 (statement -> .) ]
  ! NULL_LITERAL    [ reduce using rule 21 (statement -> .) ]
  ! STRING          [ reduce using rule 21 (statement -> .) ]
  ! INT             [ reduce using rule 21 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 21 (statement -> .) ]
  ! BOOL            [ reduce using rule 21 (statement -> .) ]
  ! IF              [ reduce using rule 21 (statement -> .) ]
  ! WHILE           [ reduce using rule 21 (statement -> .) ]
  ! FOR             [ reduce using rule 21 (statement -> .) ]
  ! SET             [ reduce using rule 21 (statement -> .) ]
  ! LBRACE          [ reduce using rule 21 (statement -> .) ]

    statement                      shift and go to state 57
    print_stmt                     shift and go to state 4
    input_stmt                     shift and go to state 5
    control_structures             shift and go to state 6
    function                       shift and go to state 7
    lambda_function                shift and go to state 8
    list_def                       shift and go to state 9
    map_def                        shift and go to state 10
    variable_def                   shift and go to state 11
    variable_only_def              shift and go to state 12
    function_call                  shift and go to state 14
    return_statement               shift and go to state 15
    incdec_statement               shift and go to state 16
    class_def                      shift and go to state 17
    object_instantiation           shift and go to state 18
    break_stmt                     shift and go to state 19
    expression                     shift and go to state 20
    value                          shift and go to state 23
    type                           shift and go to state 27
    if_block                       shift and go to state 28
    while_loop                     shift and go to state 29
    for_loop                       shift and go to state 30
    set_type                       shift and go to state 51
    set_value                      shift and go to state 55

state 603

    (167) class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .

    RBRACE          reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FINAL           reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    CONST           reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 167 (class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)


state 604

    (150) class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .

    SEMICOLON       reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    PRINT           reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STDIN           reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    VAR             reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    VOID            reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LIST            reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    MAP             reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DYNAMIC         reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STATIC          reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    ID              reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    RETURN          reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    INCREMENT       reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DECREMENT       reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    CLASS           reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    BREAK           reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    PLUS            reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    MINUS           reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    TRUE            reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    FALSE           reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    NULL_LITERAL    reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    STRING          reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    INT             reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    DOUBLE          reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    BOOL            reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    IF              reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    WHILE           reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    FOR             reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    SET             reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    LBRACE          reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    $end            reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 150 (class_def -> CLASS ID EXTENDS ID WITH ID IMPLEMENTS ID LBRACE class_body RBRACE .)


state 605

    (85) for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .

    SEMICOLON       reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    PRINT           reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    STDIN           reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    LIST            reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    MAP             reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    DYNAMIC         reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    RETURN          reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    INCREMENT       reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    DECREMENT       reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    CLASS           reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    BREAK           reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    LPAREN          reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    PLUS            reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    MINUS           reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    TRUE            reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    FALSE           reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    NULL_LITERAL    reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    IF              reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    WHILE           reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    FOR             reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    LBRACE          reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    $end            reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)
    RBRACE          reduce using rule 85 (for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE .)


state 606

    (135) list_of_lists -> list_of_lists COMMA LBRACKET value_list RBRACKET .

    RBRACKET        reduce using rule 135 (list_of_lists -> list_of_lists COMMA LBRACKET value_list RBRACKET .)
    COMMA           reduce using rule 135 (list_of_lists -> list_of_lists COMMA LBRACKET value_list RBRACKET .)


state 607

    (136) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .

    SEMICOLON       reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    PRINT           reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    STDIN           reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    VAR             reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    VOID            reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    LIST            reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    MAP             reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    DYNAMIC         reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    STATIC          reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    ID              reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    RETURN          reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    INCREMENT       reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    DECREMENT       reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    CLASS           reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    BREAK           reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    LPAREN          reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    PLUS            reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    MINUS           reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    TRUE            reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    FALSE           reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    NULL_LITERAL    reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    STRING          reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    INT             reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    BOOL            reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    IF              reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    WHILE           reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    FOR             reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    SET             reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    LBRACE          reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    $end            reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)
    RBRACE          reduce using rule 136 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON .)


state 608

    (143) map_of_lists -> map_of_lists COMMA map_list_entry .

    RBRACE          reduce using rule 143 (map_of_lists -> map_of_lists COMMA map_list_entry .)
    COMMA           reduce using rule 143 (map_of_lists -> map_of_lists COMMA map_list_entry .)


state 609

    (144) map_list_entry -> value . COLON LBRACKET value_list RBRACKET

    COLON           shift and go to state 614


state 610

    (138) map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .

    SEMICOLON       reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    PRINT           reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    STDIN           reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    VAR             reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    VOID            reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    LIST            reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    MAP             reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    DYNAMIC         reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    STATIC          reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    ID              reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    RETURN          reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    INCREMENT       reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    DECREMENT       reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    CLASS           reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    BREAK           reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    LPAREN          reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    PLUS            reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    MINUS           reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    TRUE            reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    FALSE           reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    NULL_LITERAL    reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    STRING          reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    INT             reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    BOOL            reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    IF              reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    WHILE           reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    FOR             reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    SET             reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    LBRACE          reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    $end            reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)
    RBRACE          reduce using rule 138 (map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_of_lists RBRACE SEMICOLON .)


state 611

    (144) map_list_entry -> value COLON LBRACKET . value_list RBRACKET
    (132) value_list -> . value
    (133) value_list -> . value_list COMMA value
    (201) value -> . INT
    (202) value -> . DOUBLE
    (203) value -> . STRING
    (204) value -> . ID
    (205) value -> . TRUE
    (206) value -> . FALSE
    (207) value -> . set_value
    (145) set_value -> . LBRACE value_list RBRACE

    INT             shift and go to state 98
    DOUBLE          shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    LBRACE          shift and go to state 31

    value                          shift and go to state 97
    value_list                     shift and go to state 615
    set_value                      shift and go to state 55

state 612

    (170) class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .

    RBRACE          reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FINAL           reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    CONST           reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 170 (class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)


state 613

    (171) class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .

    RBRACE          reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VAR             reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    FINAL           reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    CONST           reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STATIC          reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    VOID            reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    ID              reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    STRING          reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    INT             reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    DOUBLE          reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    BOOL            reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)
    SET             reduce using rule 171 (class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE .)


state 614

    (144) map_list_entry -> value COLON . LBRACKET value_list RBRACKET

    LBRACKET        shift and go to state 611


state 615

    (144) map_list_entry -> value COLON LBRACKET value_list . RBRACKET
    (133) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 616
    COMMA           shift and go to state 175


state 616

    (144) map_list_entry -> value COLON LBRACKET value_list RBRACKET .

    RBRACE          reduce using rule 144 (map_list_entry -> value COLON LBRACKET value_list RBRACKET .)
    COMMA           reduce using rule 144 (map_list_entry -> value COLON LBRACKET value_list RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for LIST in state 0 resolved as shift
WARNING: shift/reduce conflict for MAP in state 0 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 0 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 0 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 0 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 0 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 0 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 0 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 0 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for SET in state 0 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 0 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 2 resolved as shift
WARNING: shift/reduce conflict for VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for VOID in state 2 resolved as shift
WARNING: shift/reduce conflict for LIST in state 2 resolved as shift
WARNING: shift/reduce conflict for MAP in state 2 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 2 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 2 resolved as shift
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 2 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 2 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 2 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 2 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 2 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 2 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 2 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 2 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 2 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING in state 2 resolved as shift
WARNING: shift/reduce conflict for INT in state 2 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for SET in state 2 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 2 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 85 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 86 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 118 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 119 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 128 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 128 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 128 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 128 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 128 resolved as shift
WARNING: shift/reduce conflict for DOT in state 128 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 128 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 128 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 129 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 129 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 129 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 129 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 129 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 129 resolved as shift
WARNING: shift/reduce conflict for DOT in state 129 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 129 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 129 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 130 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 130 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 130 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 130 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 130 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 130 resolved as shift
WARNING: shift/reduce conflict for DOT in state 130 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 130 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 130 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 131 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 131 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 131 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 131 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 131 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 131 resolved as shift
WARNING: shift/reduce conflict for DOT in state 131 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 131 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 131 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 132 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 132 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 132 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 132 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 132 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 132 resolved as shift
WARNING: shift/reduce conflict for DOT in state 132 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 132 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 132 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 133 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 133 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 133 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 133 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 133 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 133 resolved as shift
WARNING: shift/reduce conflict for DOT in state 133 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 133 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 133 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 137 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 137 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 137 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 137 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 137 resolved as shift
WARNING: shift/reduce conflict for DOT in state 137 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 137 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 137 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 139 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 165 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 165 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 165 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 165 resolved as shift
WARNING: shift/reduce conflict for DOT in state 165 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 165 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 165 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 166 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 166 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 166 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 166 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 166 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 166 resolved as shift
WARNING: shift/reduce conflict for DOT in state 166 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 166 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 166 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 167 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 167 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 167 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 167 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 167 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 167 resolved as shift
WARNING: shift/reduce conflict for DOT in state 167 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 167 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 167 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 168 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 168 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 168 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 168 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 168 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 168 resolved as shift
WARNING: shift/reduce conflict for DOT in state 168 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 168 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 168 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 169 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 169 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 169 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 169 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 169 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 169 resolved as shift
WARNING: shift/reduce conflict for DOT in state 169 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 169 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 169 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 173 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 173 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 173 resolved as shift
WARNING: shift/reduce conflict for VAR in state 173 resolved as shift
WARNING: shift/reduce conflict for VOID in state 173 resolved as shift
WARNING: shift/reduce conflict for LIST in state 173 resolved as shift
WARNING: shift/reduce conflict for MAP in state 173 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 173 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 173 resolved as shift
WARNING: shift/reduce conflict for ID in state 173 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 173 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 173 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 173 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 173 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 173 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 173 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 173 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 173 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 173 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 173 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 173 resolved as shift
WARNING: shift/reduce conflict for STRING in state 173 resolved as shift
WARNING: shift/reduce conflict for INT in state 173 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 173 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 173 resolved as shift
WARNING: shift/reduce conflict for IF in state 173 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 173 resolved as shift
WARNING: shift/reduce conflict for FOR in state 173 resolved as shift
WARNING: shift/reduce conflict for SET in state 173 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 198 resolved as shift
WARNING: shift/reduce conflict for LESS in state 198 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 198 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 198 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 198 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 198 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 208 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 213 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 213 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 213 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 213 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 213 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 213 resolved as shift
WARNING: shift/reduce conflict for DOT in state 213 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 213 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 213 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 229 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 242 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 242 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 242 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 242 resolved as shift
WARNING: shift/reduce conflict for VAR in state 242 resolved as shift
WARNING: shift/reduce conflict for VOID in state 242 resolved as shift
WARNING: shift/reduce conflict for LIST in state 242 resolved as shift
WARNING: shift/reduce conflict for MAP in state 242 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 242 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 242 resolved as shift
WARNING: shift/reduce conflict for ID in state 242 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 242 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 242 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 242 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 242 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 242 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 242 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 242 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 242 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 242 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 242 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 242 resolved as shift
WARNING: shift/reduce conflict for STRING in state 242 resolved as shift
WARNING: shift/reduce conflict for INT in state 242 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 242 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 242 resolved as shift
WARNING: shift/reduce conflict for IF in state 242 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 242 resolved as shift
WARNING: shift/reduce conflict for FOR in state 242 resolved as shift
WARNING: shift/reduce conflict for SET in state 242 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 242 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 294 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 296 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 296 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 296 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 296 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 296 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 296 resolved as shift
WARNING: shift/reduce conflict for DOT in state 296 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 296 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 296 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 299 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 299 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 299 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 299 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 299 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 299 resolved as shift
WARNING: shift/reduce conflict for DOT in state 299 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 299 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 299 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 301 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 315 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 316 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 324 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 324 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 324 resolved as shift
WARNING: shift/reduce conflict for VAR in state 324 resolved as shift
WARNING: shift/reduce conflict for VOID in state 324 resolved as shift
WARNING: shift/reduce conflict for LIST in state 324 resolved as shift
WARNING: shift/reduce conflict for MAP in state 324 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 324 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 324 resolved as shift
WARNING: shift/reduce conflict for ID in state 324 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 324 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 324 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 324 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 324 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 324 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 324 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 324 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 324 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 324 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 324 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 324 resolved as shift
WARNING: shift/reduce conflict for STRING in state 324 resolved as shift
WARNING: shift/reduce conflict for INT in state 324 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 324 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 324 resolved as shift
WARNING: shift/reduce conflict for IF in state 324 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 324 resolved as shift
WARNING: shift/reduce conflict for FOR in state 324 resolved as shift
WARNING: shift/reduce conflict for SET in state 324 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 324 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 333 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 333 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 333 resolved as shift
WARNING: shift/reduce conflict for VAR in state 333 resolved as shift
WARNING: shift/reduce conflict for VOID in state 333 resolved as shift
WARNING: shift/reduce conflict for LIST in state 333 resolved as shift
WARNING: shift/reduce conflict for MAP in state 333 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 333 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 333 resolved as shift
WARNING: shift/reduce conflict for ID in state 333 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 333 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 333 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 333 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 333 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 333 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 333 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 333 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 333 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 333 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 333 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 333 resolved as shift
WARNING: shift/reduce conflict for STRING in state 333 resolved as shift
WARNING: shift/reduce conflict for INT in state 333 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 333 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 333 resolved as shift
WARNING: shift/reduce conflict for IF in state 333 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 333 resolved as shift
WARNING: shift/reduce conflict for FOR in state 333 resolved as shift
WARNING: shift/reduce conflict for SET in state 333 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 333 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 359 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 359 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 359 resolved as shift
WARNING: shift/reduce conflict for VAR in state 359 resolved as shift
WARNING: shift/reduce conflict for VOID in state 359 resolved as shift
WARNING: shift/reduce conflict for LIST in state 359 resolved as shift
WARNING: shift/reduce conflict for MAP in state 359 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 359 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 359 resolved as shift
WARNING: shift/reduce conflict for ID in state 359 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 359 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 359 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 359 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 359 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 359 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 359 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 359 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 359 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 359 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 359 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 359 resolved as shift
WARNING: shift/reduce conflict for STRING in state 359 resolved as shift
WARNING: shift/reduce conflict for INT in state 359 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 359 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 359 resolved as shift
WARNING: shift/reduce conflict for IF in state 359 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 359 resolved as shift
WARNING: shift/reduce conflict for FOR in state 359 resolved as shift
WARNING: shift/reduce conflict for SET in state 359 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 359 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 365 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 365 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 365 resolved as shift
WARNING: shift/reduce conflict for VAR in state 365 resolved as shift
WARNING: shift/reduce conflict for VOID in state 365 resolved as shift
WARNING: shift/reduce conflict for LIST in state 365 resolved as shift
WARNING: shift/reduce conflict for MAP in state 365 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 365 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 365 resolved as shift
WARNING: shift/reduce conflict for ID in state 365 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 365 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 365 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 365 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 365 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 365 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 365 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 365 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 365 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 365 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 365 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 365 resolved as shift
WARNING: shift/reduce conflict for STRING in state 365 resolved as shift
WARNING: shift/reduce conflict for INT in state 365 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 365 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 365 resolved as shift
WARNING: shift/reduce conflict for IF in state 365 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 365 resolved as shift
WARNING: shift/reduce conflict for FOR in state 365 resolved as shift
WARNING: shift/reduce conflict for SET in state 365 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 365 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 380 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 380 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 380 resolved as shift
WARNING: shift/reduce conflict for VAR in state 380 resolved as shift
WARNING: shift/reduce conflict for VOID in state 380 resolved as shift
WARNING: shift/reduce conflict for LIST in state 380 resolved as shift
WARNING: shift/reduce conflict for MAP in state 380 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 380 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 380 resolved as shift
WARNING: shift/reduce conflict for ID in state 380 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 380 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 380 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 380 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 380 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 380 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 380 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 380 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 380 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 380 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 380 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 380 resolved as shift
WARNING: shift/reduce conflict for STRING in state 380 resolved as shift
WARNING: shift/reduce conflict for INT in state 380 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 380 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 380 resolved as shift
WARNING: shift/reduce conflict for IF in state 380 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 380 resolved as shift
WARNING: shift/reduce conflict for FOR in state 380 resolved as shift
WARNING: shift/reduce conflict for SET in state 380 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 380 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 381 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 393 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 394 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 394 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 394 resolved as shift
WARNING: shift/reduce conflict for VAR in state 394 resolved as shift
WARNING: shift/reduce conflict for VOID in state 394 resolved as shift
WARNING: shift/reduce conflict for LIST in state 394 resolved as shift
WARNING: shift/reduce conflict for MAP in state 394 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 394 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 394 resolved as shift
WARNING: shift/reduce conflict for ID in state 394 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 394 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 394 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 394 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 394 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 394 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 394 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 394 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 394 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 394 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 394 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 394 resolved as shift
WARNING: shift/reduce conflict for STRING in state 394 resolved as shift
WARNING: shift/reduce conflict for INT in state 394 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 394 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 394 resolved as shift
WARNING: shift/reduce conflict for IF in state 394 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 394 resolved as shift
WARNING: shift/reduce conflict for FOR in state 394 resolved as shift
WARNING: shift/reduce conflict for SET in state 394 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 394 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 395 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 395 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 395 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 395 resolved as shift
WARNING: shift/reduce conflict for VAR in state 395 resolved as shift
WARNING: shift/reduce conflict for VOID in state 395 resolved as shift
WARNING: shift/reduce conflict for LIST in state 395 resolved as shift
WARNING: shift/reduce conflict for MAP in state 395 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 395 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 395 resolved as shift
WARNING: shift/reduce conflict for ID in state 395 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 395 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 395 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 395 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 395 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 395 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 395 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 395 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 395 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 395 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 395 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 395 resolved as shift
WARNING: shift/reduce conflict for STRING in state 395 resolved as shift
WARNING: shift/reduce conflict for INT in state 395 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 395 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 395 resolved as shift
WARNING: shift/reduce conflict for IF in state 395 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 395 resolved as shift
WARNING: shift/reduce conflict for FOR in state 395 resolved as shift
WARNING: shift/reduce conflict for SET in state 395 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 395 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 400 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 400 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 400 resolved as shift
WARNING: shift/reduce conflict for VAR in state 400 resolved as shift
WARNING: shift/reduce conflict for VOID in state 400 resolved as shift
WARNING: shift/reduce conflict for LIST in state 400 resolved as shift
WARNING: shift/reduce conflict for MAP in state 400 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 400 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 400 resolved as shift
WARNING: shift/reduce conflict for ID in state 400 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 400 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 400 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 400 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 400 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 400 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 400 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 400 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 400 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 400 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 400 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 400 resolved as shift
WARNING: shift/reduce conflict for STRING in state 400 resolved as shift
WARNING: shift/reduce conflict for INT in state 400 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 400 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 400 resolved as shift
WARNING: shift/reduce conflict for IF in state 400 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 400 resolved as shift
WARNING: shift/reduce conflict for FOR in state 400 resolved as shift
WARNING: shift/reduce conflict for SET in state 400 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 400 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 402 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 402 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 402 resolved as shift
WARNING: shift/reduce conflict for VAR in state 402 resolved as shift
WARNING: shift/reduce conflict for VOID in state 402 resolved as shift
WARNING: shift/reduce conflict for LIST in state 402 resolved as shift
WARNING: shift/reduce conflict for MAP in state 402 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 402 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 402 resolved as shift
WARNING: shift/reduce conflict for ID in state 402 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 402 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 402 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 402 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 402 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 402 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 402 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 402 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 402 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 402 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 402 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 402 resolved as shift
WARNING: shift/reduce conflict for STRING in state 402 resolved as shift
WARNING: shift/reduce conflict for INT in state 402 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 402 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 402 resolved as shift
WARNING: shift/reduce conflict for IF in state 402 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 402 resolved as shift
WARNING: shift/reduce conflict for FOR in state 402 resolved as shift
WARNING: shift/reduce conflict for SET in state 402 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 402 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 403 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 403 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 403 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 403 resolved as shift
WARNING: shift/reduce conflict for VAR in state 403 resolved as shift
WARNING: shift/reduce conflict for VOID in state 403 resolved as shift
WARNING: shift/reduce conflict for LIST in state 403 resolved as shift
WARNING: shift/reduce conflict for MAP in state 403 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 403 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 403 resolved as shift
WARNING: shift/reduce conflict for ID in state 403 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 403 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 403 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 403 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 403 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 403 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 403 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 403 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 403 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 403 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 403 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 403 resolved as shift
WARNING: shift/reduce conflict for STRING in state 403 resolved as shift
WARNING: shift/reduce conflict for INT in state 403 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 403 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 403 resolved as shift
WARNING: shift/reduce conflict for IF in state 403 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 403 resolved as shift
WARNING: shift/reduce conflict for FOR in state 403 resolved as shift
WARNING: shift/reduce conflict for SET in state 403 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 403 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 404 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 404 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 404 resolved as shift
WARNING: shift/reduce conflict for VAR in state 404 resolved as shift
WARNING: shift/reduce conflict for VOID in state 404 resolved as shift
WARNING: shift/reduce conflict for LIST in state 404 resolved as shift
WARNING: shift/reduce conflict for MAP in state 404 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 404 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 404 resolved as shift
WARNING: shift/reduce conflict for ID in state 404 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 404 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 404 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 404 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 404 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 404 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 404 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 404 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 404 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 404 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 404 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 404 resolved as shift
WARNING: shift/reduce conflict for STRING in state 404 resolved as shift
WARNING: shift/reduce conflict for INT in state 404 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 404 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 404 resolved as shift
WARNING: shift/reduce conflict for IF in state 404 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 404 resolved as shift
WARNING: shift/reduce conflict for FOR in state 404 resolved as shift
WARNING: shift/reduce conflict for SET in state 404 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 404 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 430 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 430 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 430 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 430 resolved as shift
WARNING: shift/reduce conflict for VAR in state 430 resolved as shift
WARNING: shift/reduce conflict for VOID in state 430 resolved as shift
WARNING: shift/reduce conflict for LIST in state 430 resolved as shift
WARNING: shift/reduce conflict for MAP in state 430 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 430 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 430 resolved as shift
WARNING: shift/reduce conflict for ID in state 430 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 430 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 430 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 430 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 430 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 430 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 430 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 430 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 430 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 430 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 430 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 430 resolved as shift
WARNING: shift/reduce conflict for STRING in state 430 resolved as shift
WARNING: shift/reduce conflict for INT in state 430 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 430 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 430 resolved as shift
WARNING: shift/reduce conflict for IF in state 430 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 430 resolved as shift
WARNING: shift/reduce conflict for FOR in state 430 resolved as shift
WARNING: shift/reduce conflict for SET in state 430 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 430 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 431 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 431 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 431 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 431 resolved as shift
WARNING: shift/reduce conflict for VAR in state 431 resolved as shift
WARNING: shift/reduce conflict for VOID in state 431 resolved as shift
WARNING: shift/reduce conflict for LIST in state 431 resolved as shift
WARNING: shift/reduce conflict for MAP in state 431 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 431 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 431 resolved as shift
WARNING: shift/reduce conflict for ID in state 431 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 431 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 431 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 431 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 431 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 431 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 431 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 431 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 431 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 431 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 431 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 431 resolved as shift
WARNING: shift/reduce conflict for STRING in state 431 resolved as shift
WARNING: shift/reduce conflict for INT in state 431 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 431 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 431 resolved as shift
WARNING: shift/reduce conflict for IF in state 431 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 431 resolved as shift
WARNING: shift/reduce conflict for FOR in state 431 resolved as shift
WARNING: shift/reduce conflict for SET in state 431 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 431 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 439 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 439 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 439 resolved as shift
WARNING: shift/reduce conflict for VAR in state 439 resolved as shift
WARNING: shift/reduce conflict for VOID in state 439 resolved as shift
WARNING: shift/reduce conflict for LIST in state 439 resolved as shift
WARNING: shift/reduce conflict for MAP in state 439 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 439 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 439 resolved as shift
WARNING: shift/reduce conflict for ID in state 439 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 439 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 439 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 439 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 439 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 439 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 439 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 439 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 439 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 439 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 439 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 439 resolved as shift
WARNING: shift/reduce conflict for STRING in state 439 resolved as shift
WARNING: shift/reduce conflict for INT in state 439 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 439 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 439 resolved as shift
WARNING: shift/reduce conflict for IF in state 439 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 439 resolved as shift
WARNING: shift/reduce conflict for FOR in state 439 resolved as shift
WARNING: shift/reduce conflict for SET in state 439 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 439 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 440 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 440 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 440 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 440 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 440 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 440 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 440 resolved as shift
WARNING: shift/reduce conflict for DOT in state 440 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 440 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 440 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 441 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 441 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 441 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 441 resolved as shift
WARNING: shift/reduce conflict for VAR in state 441 resolved as shift
WARNING: shift/reduce conflict for VOID in state 441 resolved as shift
WARNING: shift/reduce conflict for LIST in state 441 resolved as shift
WARNING: shift/reduce conflict for MAP in state 441 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 441 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 441 resolved as shift
WARNING: shift/reduce conflict for ID in state 441 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 441 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 441 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 441 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 441 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 441 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 441 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 441 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 441 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 441 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 441 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 441 resolved as shift
WARNING: shift/reduce conflict for STRING in state 441 resolved as shift
WARNING: shift/reduce conflict for INT in state 441 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 441 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 441 resolved as shift
WARNING: shift/reduce conflict for IF in state 441 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 441 resolved as shift
WARNING: shift/reduce conflict for FOR in state 441 resolved as shift
WARNING: shift/reduce conflict for SET in state 441 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 441 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 453 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 453 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 453 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 453 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 453 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 453 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 453 resolved as shift
WARNING: shift/reduce conflict for DOT in state 453 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 453 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 453 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 456 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 456 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 456 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 456 resolved as shift
WARNING: shift/reduce conflict for VAR in state 456 resolved as shift
WARNING: shift/reduce conflict for VOID in state 456 resolved as shift
WARNING: shift/reduce conflict for LIST in state 456 resolved as shift
WARNING: shift/reduce conflict for MAP in state 456 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 456 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 456 resolved as shift
WARNING: shift/reduce conflict for ID in state 456 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 456 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 456 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 456 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 456 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 456 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 456 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 456 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 456 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 456 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 456 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 456 resolved as shift
WARNING: shift/reduce conflict for STRING in state 456 resolved as shift
WARNING: shift/reduce conflict for INT in state 456 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 456 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 456 resolved as shift
WARNING: shift/reduce conflict for IF in state 456 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 456 resolved as shift
WARNING: shift/reduce conflict for FOR in state 456 resolved as shift
WARNING: shift/reduce conflict for SET in state 456 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 456 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 460 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 460 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 460 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 460 resolved as shift
WARNING: shift/reduce conflict for VAR in state 460 resolved as shift
WARNING: shift/reduce conflict for VOID in state 460 resolved as shift
WARNING: shift/reduce conflict for LIST in state 460 resolved as shift
WARNING: shift/reduce conflict for MAP in state 460 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 460 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 460 resolved as shift
WARNING: shift/reduce conflict for ID in state 460 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 460 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 460 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 460 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 460 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 460 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 460 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 460 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 460 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 460 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 460 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 460 resolved as shift
WARNING: shift/reduce conflict for STRING in state 460 resolved as shift
WARNING: shift/reduce conflict for INT in state 460 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 460 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 460 resolved as shift
WARNING: shift/reduce conflict for IF in state 460 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 460 resolved as shift
WARNING: shift/reduce conflict for FOR in state 460 resolved as shift
WARNING: shift/reduce conflict for SET in state 460 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 460 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 461 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 461 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 461 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 461 resolved as shift
WARNING: shift/reduce conflict for VAR in state 461 resolved as shift
WARNING: shift/reduce conflict for VOID in state 461 resolved as shift
WARNING: shift/reduce conflict for LIST in state 461 resolved as shift
WARNING: shift/reduce conflict for MAP in state 461 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 461 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 461 resolved as shift
WARNING: shift/reduce conflict for ID in state 461 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 461 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 461 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 461 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 461 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 461 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 461 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 461 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 461 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 461 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 461 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 461 resolved as shift
WARNING: shift/reduce conflict for STRING in state 461 resolved as shift
WARNING: shift/reduce conflict for INT in state 461 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 461 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 461 resolved as shift
WARNING: shift/reduce conflict for IF in state 461 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 461 resolved as shift
WARNING: shift/reduce conflict for FOR in state 461 resolved as shift
WARNING: shift/reduce conflict for SET in state 461 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 461 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 463 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 463 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 463 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 463 resolved as shift
WARNING: shift/reduce conflict for VAR in state 463 resolved as shift
WARNING: shift/reduce conflict for VOID in state 463 resolved as shift
WARNING: shift/reduce conflict for LIST in state 463 resolved as shift
WARNING: shift/reduce conflict for MAP in state 463 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 463 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 463 resolved as shift
WARNING: shift/reduce conflict for ID in state 463 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 463 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 463 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 463 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 463 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 463 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 463 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 463 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 463 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 463 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 463 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 463 resolved as shift
WARNING: shift/reduce conflict for STRING in state 463 resolved as shift
WARNING: shift/reduce conflict for INT in state 463 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 463 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 463 resolved as shift
WARNING: shift/reduce conflict for IF in state 463 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 463 resolved as shift
WARNING: shift/reduce conflict for FOR in state 463 resolved as shift
WARNING: shift/reduce conflict for SET in state 463 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 463 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 470 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 470 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 470 resolved as shift
WARNING: shift/reduce conflict for VAR in state 470 resolved as shift
WARNING: shift/reduce conflict for VOID in state 470 resolved as shift
WARNING: shift/reduce conflict for LIST in state 470 resolved as shift
WARNING: shift/reduce conflict for MAP in state 470 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 470 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 470 resolved as shift
WARNING: shift/reduce conflict for ID in state 470 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 470 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 470 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 470 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 470 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 470 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 470 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 470 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 470 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 470 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 470 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 470 resolved as shift
WARNING: shift/reduce conflict for STRING in state 470 resolved as shift
WARNING: shift/reduce conflict for INT in state 470 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 470 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 470 resolved as shift
WARNING: shift/reduce conflict for IF in state 470 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 470 resolved as shift
WARNING: shift/reduce conflict for FOR in state 470 resolved as shift
WARNING: shift/reduce conflict for SET in state 470 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 470 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 502 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 502 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 502 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 502 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 502 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 502 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 502 resolved as shift
WARNING: shift/reduce conflict for DOT in state 502 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 502 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 502 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 503 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 503 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 503 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 503 resolved as shift
WARNING: shift/reduce conflict for VAR in state 503 resolved as shift
WARNING: shift/reduce conflict for VOID in state 503 resolved as shift
WARNING: shift/reduce conflict for LIST in state 503 resolved as shift
WARNING: shift/reduce conflict for MAP in state 503 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 503 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 503 resolved as shift
WARNING: shift/reduce conflict for ID in state 503 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 503 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 503 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 503 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 503 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 503 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 503 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 503 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 503 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 503 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 503 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 503 resolved as shift
WARNING: shift/reduce conflict for STRING in state 503 resolved as shift
WARNING: shift/reduce conflict for INT in state 503 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 503 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 503 resolved as shift
WARNING: shift/reduce conflict for IF in state 503 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 503 resolved as shift
WARNING: shift/reduce conflict for FOR in state 503 resolved as shift
WARNING: shift/reduce conflict for SET in state 503 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 503 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 513 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 513 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 513 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 513 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 513 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 513 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 513 resolved as shift
WARNING: shift/reduce conflict for DOT in state 513 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 513 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_DOT in state 513 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 525 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 525 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 525 resolved as shift
WARNING: shift/reduce conflict for VAR in state 525 resolved as shift
WARNING: shift/reduce conflict for VOID in state 525 resolved as shift
WARNING: shift/reduce conflict for LIST in state 525 resolved as shift
WARNING: shift/reduce conflict for MAP in state 525 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 525 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 525 resolved as shift
WARNING: shift/reduce conflict for ID in state 525 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 525 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 525 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 525 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 525 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 525 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 525 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 525 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 525 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 525 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 525 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 525 resolved as shift
WARNING: shift/reduce conflict for STRING in state 525 resolved as shift
WARNING: shift/reduce conflict for INT in state 525 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 525 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 525 resolved as shift
WARNING: shift/reduce conflict for IF in state 525 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 525 resolved as shift
WARNING: shift/reduce conflict for FOR in state 525 resolved as shift
WARNING: shift/reduce conflict for SET in state 525 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 525 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 526 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 526 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 526 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 526 resolved as shift
WARNING: shift/reduce conflict for VAR in state 526 resolved as shift
WARNING: shift/reduce conflict for VOID in state 526 resolved as shift
WARNING: shift/reduce conflict for LIST in state 526 resolved as shift
WARNING: shift/reduce conflict for MAP in state 526 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 526 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 526 resolved as shift
WARNING: shift/reduce conflict for ID in state 526 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 526 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 526 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 526 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 526 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 526 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 526 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 526 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 526 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 526 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 526 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 526 resolved as shift
WARNING: shift/reduce conflict for STRING in state 526 resolved as shift
WARNING: shift/reduce conflict for INT in state 526 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 526 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 526 resolved as shift
WARNING: shift/reduce conflict for IF in state 526 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 526 resolved as shift
WARNING: shift/reduce conflict for FOR in state 526 resolved as shift
WARNING: shift/reduce conflict for SET in state 526 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 526 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 529 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 529 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 529 resolved as shift
WARNING: shift/reduce conflict for VAR in state 529 resolved as shift
WARNING: shift/reduce conflict for VOID in state 529 resolved as shift
WARNING: shift/reduce conflict for LIST in state 529 resolved as shift
WARNING: shift/reduce conflict for MAP in state 529 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 529 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 529 resolved as shift
WARNING: shift/reduce conflict for ID in state 529 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 529 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 529 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 529 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 529 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 529 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 529 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 529 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 529 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 529 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 529 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 529 resolved as shift
WARNING: shift/reduce conflict for STRING in state 529 resolved as shift
WARNING: shift/reduce conflict for INT in state 529 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 529 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 529 resolved as shift
WARNING: shift/reduce conflict for IF in state 529 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 529 resolved as shift
WARNING: shift/reduce conflict for FOR in state 529 resolved as shift
WARNING: shift/reduce conflict for SET in state 529 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 529 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 537 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 537 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 537 resolved as shift
WARNING: shift/reduce conflict for VAR in state 537 resolved as shift
WARNING: shift/reduce conflict for VOID in state 537 resolved as shift
WARNING: shift/reduce conflict for LIST in state 537 resolved as shift
WARNING: shift/reduce conflict for MAP in state 537 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 537 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 537 resolved as shift
WARNING: shift/reduce conflict for ID in state 537 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 537 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 537 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 537 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 537 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 537 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 537 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 537 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 537 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 537 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 537 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 537 resolved as shift
WARNING: shift/reduce conflict for STRING in state 537 resolved as shift
WARNING: shift/reduce conflict for INT in state 537 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 537 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 537 resolved as shift
WARNING: shift/reduce conflict for IF in state 537 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 537 resolved as shift
WARNING: shift/reduce conflict for FOR in state 537 resolved as shift
WARNING: shift/reduce conflict for SET in state 537 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 537 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 546 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 546 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 546 resolved as shift
WARNING: shift/reduce conflict for VAR in state 546 resolved as shift
WARNING: shift/reduce conflict for VOID in state 546 resolved as shift
WARNING: shift/reduce conflict for LIST in state 546 resolved as shift
WARNING: shift/reduce conflict for MAP in state 546 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 546 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 546 resolved as shift
WARNING: shift/reduce conflict for ID in state 546 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 546 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 546 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 546 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 546 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 546 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 546 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 546 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 546 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 546 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 546 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 546 resolved as shift
WARNING: shift/reduce conflict for STRING in state 546 resolved as shift
WARNING: shift/reduce conflict for INT in state 546 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 546 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 546 resolved as shift
WARNING: shift/reduce conflict for IF in state 546 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 546 resolved as shift
WARNING: shift/reduce conflict for FOR in state 546 resolved as shift
WARNING: shift/reduce conflict for SET in state 546 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 546 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 561 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 561 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 561 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 561 resolved as shift
WARNING: shift/reduce conflict for VAR in state 561 resolved as shift
WARNING: shift/reduce conflict for VOID in state 561 resolved as shift
WARNING: shift/reduce conflict for LIST in state 561 resolved as shift
WARNING: shift/reduce conflict for MAP in state 561 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 561 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 561 resolved as shift
WARNING: shift/reduce conflict for ID in state 561 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 561 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 561 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 561 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 561 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 561 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 561 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 561 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 561 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 561 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 561 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 561 resolved as shift
WARNING: shift/reduce conflict for STRING in state 561 resolved as shift
WARNING: shift/reduce conflict for INT in state 561 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 561 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 561 resolved as shift
WARNING: shift/reduce conflict for IF in state 561 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 561 resolved as shift
WARNING: shift/reduce conflict for FOR in state 561 resolved as shift
WARNING: shift/reduce conflict for SET in state 561 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 561 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 563 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 563 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 563 resolved as shift
WARNING: shift/reduce conflict for VAR in state 563 resolved as shift
WARNING: shift/reduce conflict for VOID in state 563 resolved as shift
WARNING: shift/reduce conflict for LIST in state 563 resolved as shift
WARNING: shift/reduce conflict for MAP in state 563 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 563 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 563 resolved as shift
WARNING: shift/reduce conflict for ID in state 563 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 563 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 563 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 563 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 563 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 563 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 563 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 563 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 563 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 563 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 563 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 563 resolved as shift
WARNING: shift/reduce conflict for STRING in state 563 resolved as shift
WARNING: shift/reduce conflict for INT in state 563 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 563 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 563 resolved as shift
WARNING: shift/reduce conflict for IF in state 563 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 563 resolved as shift
WARNING: shift/reduce conflict for FOR in state 563 resolved as shift
WARNING: shift/reduce conflict for SET in state 563 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 563 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 564 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 564 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 564 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 564 resolved as shift
WARNING: shift/reduce conflict for VAR in state 564 resolved as shift
WARNING: shift/reduce conflict for VOID in state 564 resolved as shift
WARNING: shift/reduce conflict for LIST in state 564 resolved as shift
WARNING: shift/reduce conflict for MAP in state 564 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 564 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 564 resolved as shift
WARNING: shift/reduce conflict for ID in state 564 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 564 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 564 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 564 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 564 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 564 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 564 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 564 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 564 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 564 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 564 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 564 resolved as shift
WARNING: shift/reduce conflict for STRING in state 564 resolved as shift
WARNING: shift/reduce conflict for INT in state 564 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 564 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 564 resolved as shift
WARNING: shift/reduce conflict for IF in state 564 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 564 resolved as shift
WARNING: shift/reduce conflict for FOR in state 564 resolved as shift
WARNING: shift/reduce conflict for SET in state 564 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 564 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 570 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 570 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 570 resolved as shift
WARNING: shift/reduce conflict for VAR in state 570 resolved as shift
WARNING: shift/reduce conflict for VOID in state 570 resolved as shift
WARNING: shift/reduce conflict for LIST in state 570 resolved as shift
WARNING: shift/reduce conflict for MAP in state 570 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 570 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 570 resolved as shift
WARNING: shift/reduce conflict for ID in state 570 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 570 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 570 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 570 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 570 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 570 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 570 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 570 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 570 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 570 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 570 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 570 resolved as shift
WARNING: shift/reduce conflict for STRING in state 570 resolved as shift
WARNING: shift/reduce conflict for INT in state 570 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 570 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 570 resolved as shift
WARNING: shift/reduce conflict for IF in state 570 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 570 resolved as shift
WARNING: shift/reduce conflict for FOR in state 570 resolved as shift
WARNING: shift/reduce conflict for SET in state 570 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 570 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 571 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 571 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 571 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 571 resolved as shift
WARNING: shift/reduce conflict for VAR in state 571 resolved as shift
WARNING: shift/reduce conflict for VOID in state 571 resolved as shift
WARNING: shift/reduce conflict for LIST in state 571 resolved as shift
WARNING: shift/reduce conflict for MAP in state 571 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 571 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 571 resolved as shift
WARNING: shift/reduce conflict for ID in state 571 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 571 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 571 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 571 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 571 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 571 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 571 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 571 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 571 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 571 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 571 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 571 resolved as shift
WARNING: shift/reduce conflict for STRING in state 571 resolved as shift
WARNING: shift/reduce conflict for INT in state 571 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 571 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 571 resolved as shift
WARNING: shift/reduce conflict for IF in state 571 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 571 resolved as shift
WARNING: shift/reduce conflict for FOR in state 571 resolved as shift
WARNING: shift/reduce conflict for SET in state 571 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 571 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 574 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 574 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 574 resolved as shift
WARNING: shift/reduce conflict for VAR in state 574 resolved as shift
WARNING: shift/reduce conflict for VOID in state 574 resolved as shift
WARNING: shift/reduce conflict for LIST in state 574 resolved as shift
WARNING: shift/reduce conflict for MAP in state 574 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 574 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 574 resolved as shift
WARNING: shift/reduce conflict for ID in state 574 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 574 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 574 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 574 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 574 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 574 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 574 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 574 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 574 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 574 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 574 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 574 resolved as shift
WARNING: shift/reduce conflict for STRING in state 574 resolved as shift
WARNING: shift/reduce conflict for INT in state 574 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 574 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 574 resolved as shift
WARNING: shift/reduce conflict for IF in state 574 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 574 resolved as shift
WARNING: shift/reduce conflict for FOR in state 574 resolved as shift
WARNING: shift/reduce conflict for SET in state 574 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 574 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 576 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 576 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 576 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 576 resolved as shift
WARNING: shift/reduce conflict for VAR in state 576 resolved as shift
WARNING: shift/reduce conflict for VOID in state 576 resolved as shift
WARNING: shift/reduce conflict for LIST in state 576 resolved as shift
WARNING: shift/reduce conflict for MAP in state 576 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 576 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 576 resolved as shift
WARNING: shift/reduce conflict for ID in state 576 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 576 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 576 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 576 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 576 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 576 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 576 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 576 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 576 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 576 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 576 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 576 resolved as shift
WARNING: shift/reduce conflict for STRING in state 576 resolved as shift
WARNING: shift/reduce conflict for INT in state 576 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 576 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 576 resolved as shift
WARNING: shift/reduce conflict for IF in state 576 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 576 resolved as shift
WARNING: shift/reduce conflict for FOR in state 576 resolved as shift
WARNING: shift/reduce conflict for SET in state 576 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 576 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 586 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 586 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 586 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 586 resolved as shift
WARNING: shift/reduce conflict for VAR in state 586 resolved as shift
WARNING: shift/reduce conflict for VOID in state 586 resolved as shift
WARNING: shift/reduce conflict for LIST in state 586 resolved as shift
WARNING: shift/reduce conflict for MAP in state 586 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 586 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 586 resolved as shift
WARNING: shift/reduce conflict for ID in state 586 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 586 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 586 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 586 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 586 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 586 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 586 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 586 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 586 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 586 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 586 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 586 resolved as shift
WARNING: shift/reduce conflict for STRING in state 586 resolved as shift
WARNING: shift/reduce conflict for INT in state 586 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 586 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 586 resolved as shift
WARNING: shift/reduce conflict for IF in state 586 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 586 resolved as shift
WARNING: shift/reduce conflict for FOR in state 586 resolved as shift
WARNING: shift/reduce conflict for SET in state 586 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 586 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 588 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 588 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 588 resolved as shift
WARNING: shift/reduce conflict for VAR in state 588 resolved as shift
WARNING: shift/reduce conflict for VOID in state 588 resolved as shift
WARNING: shift/reduce conflict for LIST in state 588 resolved as shift
WARNING: shift/reduce conflict for MAP in state 588 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 588 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 588 resolved as shift
WARNING: shift/reduce conflict for ID in state 588 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 588 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 588 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 588 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 588 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 588 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 588 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 588 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 588 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 588 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 588 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 588 resolved as shift
WARNING: shift/reduce conflict for STRING in state 588 resolved as shift
WARNING: shift/reduce conflict for INT in state 588 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 588 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 588 resolved as shift
WARNING: shift/reduce conflict for IF in state 588 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 588 resolved as shift
WARNING: shift/reduce conflict for FOR in state 588 resolved as shift
WARNING: shift/reduce conflict for SET in state 588 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 588 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 589 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 589 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 589 resolved as shift
WARNING: shift/reduce conflict for VAR in state 589 resolved as shift
WARNING: shift/reduce conflict for VOID in state 589 resolved as shift
WARNING: shift/reduce conflict for LIST in state 589 resolved as shift
WARNING: shift/reduce conflict for MAP in state 589 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 589 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 589 resolved as shift
WARNING: shift/reduce conflict for ID in state 589 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 589 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 589 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 589 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 589 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 589 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 589 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 589 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 589 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 589 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 589 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 589 resolved as shift
WARNING: shift/reduce conflict for STRING in state 589 resolved as shift
WARNING: shift/reduce conflict for INT in state 589 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 589 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 589 resolved as shift
WARNING: shift/reduce conflict for IF in state 589 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 589 resolved as shift
WARNING: shift/reduce conflict for FOR in state 589 resolved as shift
WARNING: shift/reduce conflict for SET in state 589 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 589 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 590 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 590 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 590 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 590 resolved as shift
WARNING: shift/reduce conflict for VAR in state 590 resolved as shift
WARNING: shift/reduce conflict for VOID in state 590 resolved as shift
WARNING: shift/reduce conflict for LIST in state 590 resolved as shift
WARNING: shift/reduce conflict for MAP in state 590 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 590 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 590 resolved as shift
WARNING: shift/reduce conflict for ID in state 590 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 590 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 590 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 590 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 590 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 590 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 590 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 590 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 590 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 590 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 590 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 590 resolved as shift
WARNING: shift/reduce conflict for STRING in state 590 resolved as shift
WARNING: shift/reduce conflict for INT in state 590 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 590 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 590 resolved as shift
WARNING: shift/reduce conflict for IF in state 590 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 590 resolved as shift
WARNING: shift/reduce conflict for FOR in state 590 resolved as shift
WARNING: shift/reduce conflict for SET in state 590 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 590 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 593 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 593 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 593 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 593 resolved as shift
WARNING: shift/reduce conflict for VAR in state 593 resolved as shift
WARNING: shift/reduce conflict for VOID in state 593 resolved as shift
WARNING: shift/reduce conflict for LIST in state 593 resolved as shift
WARNING: shift/reduce conflict for MAP in state 593 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 593 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 593 resolved as shift
WARNING: shift/reduce conflict for ID in state 593 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 593 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 593 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 593 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 593 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 593 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 593 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 593 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 593 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 593 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 593 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 593 resolved as shift
WARNING: shift/reduce conflict for STRING in state 593 resolved as shift
WARNING: shift/reduce conflict for INT in state 593 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 593 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 593 resolved as shift
WARNING: shift/reduce conflict for IF in state 593 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 593 resolved as shift
WARNING: shift/reduce conflict for FOR in state 593 resolved as shift
WARNING: shift/reduce conflict for SET in state 593 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 593 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 601 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 601 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 601 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 601 resolved as shift
WARNING: shift/reduce conflict for VAR in state 601 resolved as shift
WARNING: shift/reduce conflict for VOID in state 601 resolved as shift
WARNING: shift/reduce conflict for LIST in state 601 resolved as shift
WARNING: shift/reduce conflict for MAP in state 601 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 601 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 601 resolved as shift
WARNING: shift/reduce conflict for ID in state 601 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 601 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 601 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 601 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 601 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 601 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 601 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 601 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 601 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 601 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 601 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 601 resolved as shift
WARNING: shift/reduce conflict for STRING in state 601 resolved as shift
WARNING: shift/reduce conflict for INT in state 601 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 601 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 601 resolved as shift
WARNING: shift/reduce conflict for IF in state 601 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 601 resolved as shift
WARNING: shift/reduce conflict for FOR in state 601 resolved as shift
WARNING: shift/reduce conflict for SET in state 601 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 601 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 602 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 602 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 602 resolved as shift
WARNING: shift/reduce conflict for STDIN in state 602 resolved as shift
WARNING: shift/reduce conflict for VAR in state 602 resolved as shift
WARNING: shift/reduce conflict for VOID in state 602 resolved as shift
WARNING: shift/reduce conflict for LIST in state 602 resolved as shift
WARNING: shift/reduce conflict for MAP in state 602 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC in state 602 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 602 resolved as shift
WARNING: shift/reduce conflict for ID in state 602 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 602 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 602 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 602 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 602 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 602 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 602 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 602 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 602 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 602 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 602 resolved as shift
WARNING: shift/reduce conflict for NULL_LITERAL in state 602 resolved as shift
WARNING: shift/reduce conflict for STRING in state 602 resolved as shift
WARNING: shift/reduce conflict for INT in state 602 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 602 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 602 resolved as shift
WARNING: shift/reduce conflict for IF in state 602 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 602 resolved as shift
WARNING: shift/reduce conflict for FOR in state 602 resolved as shift
WARNING: shift/reduce conflict for SET in state 602 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 602 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (compiler -> statement_composed)
WARNING: rejected rule (statement -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 44 resolved using rule (expression -> TRUE)
WARNING: rejected rule (value -> TRUE) in state 44
WARNING: reduce/reduce conflict in state 45 resolved using rule (expression -> FALSE)
WARNING: rejected rule (value -> FALSE) in state 45
WARNING: reduce/reduce conflict in state 142 resolved using rule (expression -> TRUE)
WARNING: rejected rule (value -> TRUE) in state 142
WARNING: reduce/reduce conflict in state 143 resolved using rule (expression -> FALSE)
WARNING: rejected rule (value -> FALSE) in state 143
WARNING: reduce/reduce conflict in state 363 resolved using rule (condition -> ID comparison_operator ID)
WARNING: rejected rule (value -> ID) in state 363
