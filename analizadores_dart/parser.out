Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    BITNOT
    BREAK
    CASE
    CATCH
    CIRCUMFLEX
    CONTINUE
    DEFAULT
    DIVIDE_EQUAL
    DO
    DOLLAR_SIGN
    DOUBLE_COLON
    ENUM
    EXPORT
    FINALLY
    FUNCTION
    IMPORT
    IS
    LENGTH
    LIBRARY
    MINUS_EQUAL
    MODULE_EQUAL
    OF
    PART
    PLUS_EQUAL
    QUESTION
    QUOTATION_MARK
    SET
    SINGLE_QUOTE
    SUPER
    SWITCH
    THIS
    THROW
    TIMES_EQUAL
    TRY
    WITH

Grammar

Rule 0     S' -> compiler
Rule 1     compiler -> statement_composed
Rule 2     statement_composed -> statement
Rule 3     statement_composed -> statement_composed statement
Rule 4     statement -> print_stmt
Rule 5     statement -> input_stmt
Rule 6     statement -> control_structures
Rule 7     statement -> function
Rule 8     statement -> lambda_function
Rule 9     statement -> list_def
Rule 10    statement -> map_def
Rule 11    statement -> variable_def
Rule 12    statement -> SEMICOLON
Rule 13    statement -> function_call
Rule 14    statement -> return_statement
Rule 15    statement -> incdec_statement
Rule 16    statement -> class_def
Rule 17    statement -> object_instantiation
Rule 18    variable_def -> type ID ASSIGN expression SEMICOLON
Rule 19    variable_def -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 20    variable_def -> VAR ID ASSIGN expression SEMICOLON
Rule 21    variable_def -> STATIC type ID ASSIGN expression SEMICOLON
Rule 22    variable_def -> STATIC VAR ID ASSIGN expression SEMICOLON
Rule 23    variable_def -> STATIC DYNAMIC ID ASSIGN expression SEMICOLON
Rule 24    print_stmt -> PRINT LPAREN RPAREN SEMICOLON
Rule 25    print_stmt -> PRINT LPAREN value RPAREN SEMICOLON
Rule 26    print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 27    input_stmt -> STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 28    input_stmt -> VAR ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 29    input_stmt -> type ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 30    expression -> expression PLUS expression
Rule 31    expression -> expression MINUS expression
Rule 32    expression -> expression TIMES expression
Rule 33    expression -> expression DIVIDE expression
Rule 34    expression -> expression INT_DIVIDE expression
Rule 35    expression -> expression MODULE expression
Rule 36    expression -> LPAREN expression RPAREN
Rule 37    expression -> value
Rule 38    control_structures -> if_block
Rule 39    control_structures -> if_block else_block
Rule 40    control_structures -> while_loop
Rule 41    control_structures -> for_loop
Rule 42    if_block -> IF LPAREN conditions RPAREN LBRACE statement_composed RBRACE
Rule 43    else_block -> ELSE LBRACE statement_composed RBRACE
Rule 44    conditions -> condition
Rule 45    conditions -> conditions AND condition
Rule 46    conditions -> conditions OR condition
Rule 47    condition -> value comparison_operator value
Rule 48    condition -> NOT value
Rule 49    comparison_operator -> GREATER
Rule 50    comparison_operator -> LESS
Rule 51    comparison_operator -> GREATER_EQUAL
Rule 52    comparison_operator -> LESS_EQUAL
Rule 53    comparison_operator -> EQUALS
Rule 54    comparison_operator -> NOT_EQUALS
Rule 55    function -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 56    function -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 57    function -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 58    function -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 59    parameters -> parameter
Rule 60    parameters -> parameters COMMA parameter
Rule 61    parameter -> type ID
Rule 62    parameter -> REQUIRED type ID
Rule 63    expression -> ID INCREMENT
Rule 64    expression -> ID DECREMENT
Rule 65    expression -> INCREMENT ID
Rule 66    expression -> DECREMENT ID
Rule 67    incdec_statement -> ID INCREMENT SEMICOLON
Rule 68    incdec_statement -> ID DECREMENT SEMICOLON
Rule 69    incdec_statement -> INCREMENT ID SEMICOLON
Rule 70    incdec_statement -> DECREMENT ID SEMICOLON
Rule 71    function_call -> ID LPAREN RPAREN SEMICOLON
Rule 72    function_call -> ID LPAREN argument_list RPAREN SEMICOLON
Rule 73    argument_list -> expression
Rule 74    argument_list -> argument_list COMMA expression
Rule 75    return_statement -> RETURN expression SEMICOLON
Rule 76    return_statement -> RETURN SEMICOLON
Rule 77    while_loop -> WHILE LPAREN conditions RPAREN LBRACE statement_composed RBRACE
Rule 78    object_instantiation -> VAR ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 79    object_instantiation -> type ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 80    object_instantiation -> VAR ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 81    object_instantiation -> type ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 82    object_instantiation -> ID ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 83    object_instantiation -> ID ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 84    object_instantiation -> ID ASSIGN NEW ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 85    object_instantiation -> ID ASSIGN ID LPAREN argument_list_opt RPAREN SEMICOLON
Rule 86    object_instantiation -> ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
Rule 87    object_instantiation -> ID ASSIGN ID LPAREN RPAREN SEMICOLON
Rule 88    object_instantiation -> VAR ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
Rule 89    object_instantiation -> VAR ID ASSIGN ID LPAREN RPAREN SEMICOLON
Rule 90    object_instantiation -> type ID ASSIGN NEW ID LPAREN RPAREN SEMICOLON
Rule 91    object_instantiation -> type ID ASSIGN ID LPAREN RPAREN SEMICOLON
Rule 92    class_body -> class_member
Rule 93    class_body -> class_body class_member
Rule 94    class_def -> CLASS ID LBRACE class_body RBRACE
Rule 95    class_def -> CLASS ID EXTENDS ID LBRACE class_body RBRACE
Rule 96    class_def -> CLASS ID IMPLEMENTS ID LBRACE class_body RBRACE
Rule 97    class_def -> CLASS ID EXTENDS ID IMPLEMENTS ID LBRACE class_body RBRACE
Rule 98    for_loop -> FOR LPAREN for_init SEMICOLON conditions SEMICOLON for_update RPAREN LBRACE statement_composed RBRACE
Rule 99    for_loop -> FOR LPAREN type ID IN ID RPAREN LBRACE statement_composed RBRACE
Rule 100   for_init -> variable_def
Rule 101   for_init -> empty
Rule 102   for_update -> incdec_statement
Rule 103   for_update -> ID ASSIGN expression
Rule 104   for_update -> empty
Rule 105   class_member -> class_property
Rule 106   class_member -> class_method
Rule 107   class_member -> constructor
Rule 108   class_property -> type ID SEMICOLON
Rule 109   class_property -> VAR ID SEMICOLON
Rule 110   class_property -> FINAL type ID SEMICOLON
Rule 111   class_property -> CONST type ID SEMICOLON
Rule 112   class_property -> STATIC type ID SEMICOLON
Rule 113   class_property -> type ID ASSIGN expression SEMICOLON
Rule 114   class_property -> VAR ID ASSIGN expression SEMICOLON
Rule 115   class_property -> FINAL type ID ASSIGN expression SEMICOLON
Rule 116   class_property -> CONST type ID ASSIGN expression SEMICOLON
Rule 117   class_property -> STATIC type ID ASSIGN expression SEMICOLON
Rule 118   class_method -> type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 119   class_method -> VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 120   class_method -> type ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 121   class_method -> VOID ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 122   class_method -> STATIC type ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 123   class_method -> STATIC VOID ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 124   constructor -> ID LPAREN parameters RPAREN LBRACE statement_composed RBRACE
Rule 125   constructor -> ID LPAREN RPAREN LBRACE statement_composed RBRACE
Rule 126   type -> STRING
Rule 127   type -> INT
Rule 128   type -> DOUBLE
Rule 129   type -> BOOL
Rule 130   argument_list_opt -> argument_list
Rule 131   argument_list_opt -> empty
Rule 132   empty -> <empty>
Rule 133   list_def -> LIST LBRACKET value_list RBRACKET SEMICOLON
Rule 134   list_def -> LIST LESS type GREATER ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 135   value_list -> value
Rule 136   value_list -> value_list COMMA value
Rule 137   map_def -> MAP LESS type COMMA type GREATER ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
Rule 138   map_def -> MAP ID ASSIGN LBRACE map_entries RBRACE SEMICOLON
Rule 139   map_entries -> map_entry
Rule 140   map_entries -> map_entries COMMA map_entry
Rule 141   map_entry -> value COLON value
Rule 142   value -> INT
Rule 143   value -> FLOAT
Rule 144   value -> STRING
Rule 145   value -> ID
Rule 146   value -> TRUE
Rule 147   value -> FALSE
Rule 148   lambda_function -> type ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
Rule 149   lambda_function -> VAR ID ASSIGN LPAREN parameters RPAREN ARROW expression SEMICOLON
Rule 150   lambda_function -> type ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON
Rule 151   lambda_function -> VAR ID ASSIGN LPAREN RPAREN ARROW expression SEMICOLON

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 45
ARROW                : 148 149 150 151
AS                   : 
ASSERT               : 
ASSIGN               : 18 19 20 21 22 23 28 29 78 79 80 81 82 83 84 85 86 87 88 89 90 91 103 113 114 115 116 117 134 137 138 148 149 150 151
BITNOT               : 
BOOL                 : 129
BREAK                : 
CASE                 : 
CATCH                : 
CIRCUMFLEX           : 
CLASS                : 94 95 96 97
COLON                : 141
COMMA                : 60 74 136 137 140
CONST                : 111 116
CONTINUE             : 
DECREMENT            : 64 66 68 70
DEFAULT              : 
DIVIDE               : 33
DIVIDE_EQUAL         : 
DO                   : 
DOLLAR_SIGN          : 
DOT                  : 27 28 29
DOUBLE               : 128
DOUBLE_COLON         : 
DYNAMIC              : 19 23
ELSE                 : 43
ENUM                 : 
EQUALS               : 53
EXPORT               : 
EXTENDS              : 95 97
FALSE                : 147
FINAL                : 110 115
FINALLY              : 
FOR                  : 98 99
FUNCTION             : 
GREATER              : 49 134 137
GREATER_EQUAL        : 51
ID                   : 18 19 20 21 22 23 28 29 55 56 57 58 61 62 63 64 65 66 67 68 69 70 71 72 78 78 79 79 80 80 81 81 82 82 82 83 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 94 95 95 96 96 97 97 97 99 99 103 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 134 137 138 145 148 149 150 151
IF                   : 42
IMPLEMENTS           : 96 97
IMPORT               : 
IN                   : 99
INCREMENT            : 63 65 67 69
INT                  : 127 142
INT_DIVIDE           : 34
IS                   : 
LBRACE               : 42 43 55 56 57 58 77 94 95 96 97 98 99 118 119 120 121 122 123 124 125 137 138
LBRACKET             : 133 134
LENGTH               : 
LESS                 : 50 134 137
LESS_EQUAL           : 52
LIBRARY              : 
LIST                 : 133 134
LPAREN               : 24 25 26 27 28 29 36 42 55 56 57 58 71 72 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 98 99 118 119 120 121 122 123 124 125 148 149 150 151
MAP                  : 137 138
MINUS                : 31
MINUS_EQUAL          : 
MODULE               : 35
MODULE_EQUAL         : 
NEW                  : 78 79 82 84 86 88 90
NOT                  : 48
NOT_EQUALS           : 54
OF                   : 
OR                   : 46
PART                 : 
PLUS                 : 30
PLUS_EQUAL           : 
PRINT                : 24 25 26
QUESTION             : 
QUOTATION_MARK       : 
RBRACE               : 42 43 55 56 57 58 77 94 95 96 97 98 99 118 119 120 121 122 123 124 125 137 138
RBRACKET             : 133 134
READLINESYNC         : 27 28 29
REQUIRED             : 62
RETURN               : 75 76
RPAREN               : 24 25 26 27 28 29 36 42 55 56 57 58 71 72 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 98 99 118 119 120 121 122 123 124 125 148 149 150 151
SEMICOLON            : 12 18 19 20 21 22 23 24 25 26 27 28 29 67 68 69 70 71 72 75 76 78 79 80 81 82 83 84 85 86 87 88 89 90 91 98 98 108 109 110 111 112 113 114 115 116 117 133 134 137 138 148 149 150 151
SET                  : 
SINGLE_QUOTE         : 
STATIC               : 21 22 23 112 117 122 123
STDIN                : 27 28 29
STRING               : 126 144
SUPER                : 
SWITCH               : 
THIS                 : 
THROW                : 
TIMES                : 32
TIMES_EQUAL          : 
TRUE                 : 146
TRY                  : 
VAR                  : 20 22 28 78 80 88 89 109 114 149 151
VOID                 : 56 58 119 121 123
WHILE                : 77
WITH                 : 
error                : 

Nonterminals, with rules where they appear

FLOAT                : 143
argument_list        : 72 74 130
argument_list_opt    : 78 79 80 81 82 83 84 85
class_body           : 93 94 95 96 97
class_def            : 16
class_member         : 92 93
class_method         : 106
class_property       : 105
comparison_operator  : 47
compiler             : 0
condition            : 44 45 46
conditions           : 42 45 46 77 98
constructor          : 107
control_structures   : 6
else_block           : 39
empty                : 101 104 131
expression           : 18 19 20 21 22 23 26 30 30 31 31 32 32 33 33 34 34 35 35 36 73 74 75 103 113 114 115 116 117 148 149 150 151
for_init             : 98
for_loop             : 41
for_update           : 98
function             : 7
function_call        : 13
if_block             : 38 39
incdec_statement     : 15 102
input_stmt           : 5
lambda_function      : 8
list_def             : 9
map_def              : 10
map_entries          : 137 138 140
map_entry            : 139 140
object_instantiation : 17
parameter            : 59 60
parameters           : 55 56 60 118 119 122 123 124 148 149
print_stmt           : 4
return_statement     : 14
statement            : 2 3
statement_composed   : 1 3 42 43 55 56 57 58 77 98 99 118 119 120 121 122 123 124 125
type                 : 18 21 29 55 57 61 62 79 81 90 91 99 108 110 111 112 113 115 116 117 118 120 122 134 137 137 148 150
value                : 25 37 47 47 48 135 136 141 141
value_list           : 133 134 136
variable_def         : 11 100
while_loop           : 40

